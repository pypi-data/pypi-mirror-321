# Generated by cloudcoil-model-codegen v0.0.32
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseModel
from cloudcoil.resources import Resource


class CommonMetadata(BaseModel):
    annotations: Annotated[
        Optional[Dict[str, str]],
        Field(description="Annotations to be added to the object's metadata."),
    ] = None
    labels: Annotated[
        Optional[Dict[str, str]],
        Field(description="Labels to be added to the object's metadata."),
    ] = None


class SecretRef(BaseModel):
    name: Annotated[str, Field(description="Name of the referent.")]


class Decryption(BaseModel):
    provider: Annotated[
        Literal["sops"],
        Field(description="Provider is the name of the decryption engine."),
    ]
    secret_ref: Annotated[
        Optional[SecretRef],
        Field(
            alias="secretRef",
            description="The secret name containing the private OpenPGP keys used for decryption.",
        ),
    ] = None


class DependsOn(BaseModel):
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class HealthCheck(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(
            alias="apiVersion",
            description="API version of the referent, if not specified the Kubernetes preferred version will be used.",
        ),
    ] = None
    kind: Annotated[str, Field(description="Kind of the referent.")]
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, when not specified it acts as LocalObjectReference."
        ),
    ] = None


class Image(BaseModel):
    digest: Annotated[
        Optional[str],
        Field(
            description="Digest is the value used to replace the original image tag.\nIf digest is present NewTag value is ignored."
        ),
    ] = None
    name: Annotated[str, Field(description="Name is a tag-less image name.")]
    new_name: Annotated[
        Optional[str],
        Field(
            alias="newName",
            description="NewName is the value used to replace the original name.",
        ),
    ] = None
    new_tag: Annotated[
        Optional[str],
        Field(
            alias="newTag",
            description="NewTag is the value used to replace the original tag.",
        ),
    ] = None


class SecretRefModel(BaseModel):
    key: Annotated[
        Optional[str],
        Field(
            description="Key in the Secret, when not specified an implementation-specific default key is used."
        ),
    ] = None
    name: Annotated[str, Field(description="Name of the Secret.")]


class KubeConfig(BaseModel):
    secret_ref: Annotated[
        SecretRefModel,
        Field(
            alias="secretRef",
            description="SecretRef holds the name of a secret that contains a key with\nthe kubeconfig file as the value. If no key is set, the key will default\nto 'value'.\nIt is recommended that the kubeconfig is self-contained, and the secret\nis regularly updated if credentials such as a cloud-access-token expire.\nCloud specific `cmd-path` auth helpers will not function without adding\nbinaries and credentials to the Pod that is responsible for reconciling\nKubernetes resources.",
        ),
    ]


class Target(BaseModel):
    annotation_selector: Annotated[
        Optional[str],
        Field(
            alias="annotationSelector",
            description="AnnotationSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches with the resource annotations.",
        ),
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description="Group is the API group to select resources from.\nTogether with Version and Kind it is capable of unambiguously identifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description="Kind of the API Group to select resources from.\nTogether with Group and Version it is capable of unambiguously\nidentifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None
    label_selector: Annotated[
        Optional[str],
        Field(
            alias="labelSelector",
            description="LabelSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches with the resource labels.",
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="Name to match resources with.")] = None
    namespace: Annotated[
        Optional[str], Field(description="Namespace to select resources from.")
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="Version of the API Group to select resources from.\nTogether with Group and Kind it is capable of unambiguously identifying and/or selecting resources.\nhttps://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md"
        ),
    ] = None


class Patch(BaseModel):
    patch: Annotated[
        str,
        Field(
            description="Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with\nan array of operation objects."
        ),
    ]
    target: Annotated[
        Optional[Target],
        Field(
            description="Target points to the resources that the patch document should be applied to."
        ),
    ] = None


class PatchModel(BaseModel):
    from_: Annotated[
        Optional[str],
        Field(
            alias="from",
            description="From contains a JSON-pointer value that references a location within the target document where the operation is\nperformed. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.",
        ),
    ] = None
    op: Annotated[
        Literal["test", "remove", "add", "replace", "move", "copy"],
        Field(
            description='Op indicates the operation to perform. Its value MUST be one of "add", "remove", "replace", "move", "copy", or\n"test".\nhttps://datatracker.ietf.org/doc/html/rfc6902#section-4'
        ),
    ]
    path: Annotated[
        str,
        Field(
            description="Path contains the JSON-pointer value that references a location within the target document where the operation\nis performed. The meaning of the value depends on the value of Op."
        ),
    ]
    value: Annotated[
        Optional[Any],
        Field(
            description="Value contains a valid JSON structure. The meaning of the value depends on the value of Op, and is NOT taken into\naccount by all operations."
        ),
    ] = None


class PatchesJson6902(BaseModel):
    patch: Annotated[
        List[PatchModel],
        Field(
            description="Patch contains the JSON6902 patch document with an array of operation objects."
        ),
    ]
    target: Annotated[
        Target,
        Field(
            description="Target points to the resources that the patch document should be applied to."
        ),
    ]


class SubstituteFrom(BaseModel):
    kind: Annotated[
        Literal["Secret", "ConfigMap"],
        Field(description="Kind of the values referent, valid values are ('Secret', 'ConfigMap')."),
    ]
    name: Annotated[
        str,
        Field(
            description="Name of the values referent. Should reside in the same namespace as the\nreferring resource.",
            max_length=253,
            min_length=1,
        ),
    ]
    optional: Annotated[
        Optional[bool],
        Field(
            description="Optional indicates whether the referenced resource must exist, or whether to\ntolerate its absence. If true and the referenced resource is absent, proceed\nas if the resource was present but empty, without any variables defined."
        ),
    ] = False


class PostBuild(BaseModel):
    substitute: Annotated[
        Optional[Dict[str, str]],
        Field(
            description="Substitute holds a map of key/value pairs.\nThe variables defined in your YAML manifests\nthat match any of the keys defined in the map\nwill be substituted with the set value.\nIncludes support for bash string replacement functions\ne.g. ${var:=default}, ${var:position} and ${var/substring/replacement}."
        ),
    ] = None
    substitute_from: Annotated[
        Optional[List[SubstituteFrom]],
        Field(
            alias="substituteFrom",
            description="SubstituteFrom holds references to ConfigMaps and Secrets containing\nthe variables and their values to be substituted in the YAML manifests.\nThe ConfigMap and the Secret data keys represent the var names and they\nmust match the vars declared in the manifests for the substitution to happen.",
        ),
    ] = None


class SourceRef(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="API version of the referent."),
    ] = None
    kind: Annotated[
        Literal["OCIRepository", "GitRepository", "Bucket"],
        Field(description="Kind of the referent."),
    ]
    name: Annotated[str, Field(description="Name of the referent.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference."
        ),
    ] = None


class KustomizationSpec(BaseModel):
    common_metadata: Annotated[
        Optional[CommonMetadata],
        Field(
            alias="commonMetadata",
            description="CommonMetadata specifies the common labels and annotations that are applied to all resources.\nAny existing label or annotation will be overridden if its key matches a common one.",
        ),
    ] = None
    components: Annotated[
        Optional[List[str]],
        Field(
            description="Components specifies relative paths to specifications of other Components."
        ),
    ] = None
    decryption: Annotated[
        Optional[Decryption],
        Field(description="Decrypt Kubernetes secrets before applying them on the cluster."),
    ] = None
    depends_on: Annotated[
        Optional[List[DependsOn]],
        Field(
            alias="dependsOn",
            description="DependsOn may contain a meta.NamespacedObjectReference slice\nwith references to Kustomization resources that must be ready before this\nKustomization can be reconciled.",
        ),
    ] = None
    force: Annotated[
        Optional[bool],
        Field(
            description="Force instructs the controller to recreate resources\nwhen patching fails due to an immutable field change."
        ),
    ] = False
    health_checks: Annotated[
        Optional[List[HealthCheck]],
        Field(
            alias="healthChecks",
            description="A list of resources to be included in the health assessment.",
        ),
    ] = None
    images: Annotated[
        Optional[List[Image]],
        Field(
            description="Images is a list of (image name, new name, new tag or digest)\nfor changing image names, tags or digests. This can also be achieved with a\npatch, but this operator is simpler to specify."
        ),
    ] = None
    interval: Annotated[
        str,
        Field(
            description="The interval at which to reconcile the Kustomization.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ]
    kube_config: Annotated[
        Optional[KubeConfig],
        Field(
            alias="kubeConfig",
            description="The KubeConfig for reconciling the Kustomization on a remote cluster.\nWhen used in combination with KustomizationSpec.ServiceAccountName,\nforces the controller to act on behalf of that Service Account at the\ntarget cluster.\nIf the --default-service-account flag is set, its value will be used as\na controller level fallback for when KustomizationSpec.ServiceAccountName\nis empty.",
        ),
    ] = None
    patches: Annotated[
        Optional[List[Patch]],
        Field(
            description="Strategic merge and JSON patches, defined as inline YAML objects,\ncapable of targeting objects based on kind, label and annotation selectors."
        ),
    ] = None
    patches_json6902: Annotated[
        Optional[List[PatchesJson6902]],
        Field(
            alias="patchesJson6902",
            description="JSON 6902 patches, defined as inline YAML objects.\nDeprecated: Use Patches instead.",
        ),
    ] = None
    patches_strategic_merge: Annotated[
        Optional[List[Any]],
        Field(
            alias="patchesStrategicMerge",
            description="Strategic merge patches, defined as inline YAML objects.\nDeprecated: Use Patches instead.",
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Path to the directory containing the kustomization.yaml file, or the\nset of plain YAMLs a kustomization.yaml should be generated for.\nDefaults to 'None', which translates to the root path of the SourceRef."
        ),
    ] = None
    post_build: Annotated[
        Optional[PostBuild],
        Field(
            alias="postBuild",
            description="PostBuild describes which actions to perform on the YAML manifest\ngenerated by building the kustomize overlay.",
        ),
    ] = None
    prune: Annotated[bool, Field(description="Prune enables garbage collection.")]
    retry_interval: Annotated[
        Optional[str],
        Field(
            alias="retryInterval",
            description="The interval at which to retry a previously failed reconciliation.\nWhen not specified, the controller uses the KustomizationSpec.Interval\nvalue to retry failures.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ] = None
    service_account_name: Annotated[
        Optional[str],
        Field(
            alias="serviceAccountName",
            description="The name of the Kubernetes service account to impersonate\nwhen reconciling this Kustomization.",
        ),
    ] = None
    source_ref: Annotated[
        SourceRef,
        Field(
            alias="sourceRef",
            description="Reference of the source where the kustomization file is.",
        ),
    ]
    suspend: Annotated[
        Optional[bool],
        Field(
            description="This flag tells the controller to suspend subsequent kustomize executions,\nit does not apply to already started executions. Defaults to false."
        ),
    ] = None
    target_namespace: Annotated[
        Optional[str],
        Field(
            alias="targetNamespace",
            description="TargetNamespace sets or overrides the namespace in the\nkustomization.yaml file.",
            max_length=63,
            min_length=1,
        ),
    ] = None
    timeout: Annotated[
        Optional[str],
        Field(
            description="Timeout for validation, apply and health checking operations.\nDefaults to 'Interval' duration.",
            pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$",
        ),
    ] = None
    validation: Annotated[
        Optional[Literal["none", "client", "server"]],
        Field(description="Deprecated: Not used in v1beta2."),
    ] = None
    wait: Annotated[
        Optional[bool],
        Field(
            description="Wait instructs the controller to check the health of all the reconciled resources.\nWhen enabled, the HealthChecks are ignored. Defaults to false."
        ),
    ] = None


class Condition(BaseModel):
    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class Entry(BaseModel):
    id: Annotated[
        str,
        Field(
            description="ID is the string representation of the Kubernetes resource object's metadata,\nin the format '<namespace>_<name>_<group>_<kind>'."
        ),
    ]
    v: Annotated[
        str,
        Field(description="Version is the API version of the Kubernetes resource object's kind."),
    ]


class Inventory(BaseModel):
    entries: Annotated[
        List[Entry],
        Field(description="Entries of Kubernetes resource object references."),
    ]


class KustomizationStatus(BaseModel):
    conditions: Optional[List[Condition]] = None
    inventory: Annotated[
        Optional[Inventory],
        Field(
            description="Inventory contains the list of Kubernetes resource object references that have been successfully applied."
        ),
    ] = None
    last_applied_revision: Annotated[
        Optional[str],
        Field(
            alias="lastAppliedRevision",
            description="The last successfully applied revision.\nEquals the Revision of the applied Artifact from the referenced Source.",
        ),
    ] = None
    last_attempted_revision: Annotated[
        Optional[str],
        Field(
            alias="lastAttemptedRevision",
            description="LastAttemptedRevision is the revision of the last reconciliation attempt.",
        ),
    ] = None
    last_handled_reconcile_at: Annotated[
        Optional[str],
        Field(
            alias="lastHandledReconcileAt",
            description="LastHandledReconcileAt holds the value of the most recent\nreconcile request value, so a change of the annotation value\ncan be detected.",
        ),
    ] = None
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="ObservedGeneration is the last reconciled generation.",
        ),
    ] = None


class Kustomization(Resource):
    api_version: Annotated[
        Optional[Literal["kustomize.toolkit.fluxcd.io/v1beta2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kustomize.toolkit.fluxcd.io/v1beta2"
    kind: Annotated[
        Optional[Literal["Kustomization"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "Kustomization"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[KustomizationSpec] = None
    status: Optional[KustomizationStatus] = None
