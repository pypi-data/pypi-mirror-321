{"version":3,"file":"8XME16gW.js","mappings":";;;;;;;;;;;;;;;;;AA0BA;;;;;ACoQA;AAGA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;;AAGA;;;;;;;;;;;;;AAaA;;;AAGA;;AAGA;AA5RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqJA;;;ACxIA;AACA;;;;;;AAMA;AACA;;;AAIA;AAEA;;;;AAIA;AACA;;;AAIA;AACA;AACA;AAGA;AAGA;AACA;;AAEA;;;AAIA;;AAGA;AACA;;AAGA;;;;AAMA;AACA;AAEA;;AAIA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;AA8DA","sources":["webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-button.ts","webpack://lcn-frontend/dialog.ts","webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-md-dialog.ts","webpack://lcn-frontend/./homeassistant-frontend/src/dialogs/generic/dialog-box.ts"],"sourcesContent":["import { Button } from \"@material/mwc-button\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\nimport { styles } from \"@material/mwc-button/styles.css\";\n\n@customElement(\"ha-button\")\nexport class HaButton extends Button {\n  static override styles = [\n    styles,\n    css`\n      ::slotted([slot=\"icon\"]) {\n        margin-inline-start: 0px;\n        margin-inline-end: 8px;\n        direction: var(--direction);\n        display: block;\n      }\n      .mdc-button {\n        height: var(--button-height, 36px);\n      }\n      .trailing-icon {\n        display: flex;\n      }\n      .slot-container {\n        overflow: var(--button-slot-container-overflow, visible);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button\": HaButton;\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../divider/divider.js';\n\nimport {html, isServer, LitElement, nothing} from 'lit';\nimport {property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nimport {ARIAMixinStrict} from '../../internal/aria/aria.js';\nimport {mixinDelegatesAria} from '../../internal/aria/delegate.js';\nimport {redispatchEvent} from '../../internal/events/redispatch-event.js';\n\nimport {\n  DIALOG_DEFAULT_CLOSE_ANIMATION,\n  DIALOG_DEFAULT_OPEN_ANIMATION,\n  DialogAnimation,\n  DialogAnimationArgs,\n} from './animations.js';\n\n// Separate variable needed for closure.\nconst dialogBaseClass = mixinDelegatesAria(LitElement);\n\n/**\n * A dialog component.\n *\n * @fires open {Event} Dispatched when the dialog is opening before any animations.\n * @fires opened {Event} Dispatched when the dialog has opened after any animations.\n * @fires close {Event} Dispatched when the dialog is closing before any animations.\n * @fires closed {Event} Dispatched when the dialog has closed after any animations.\n * @fires cancel {Event} Dispatched when the dialog has been canceled by clicking\n * on the scrim or pressing Escape.\n */\nexport class Dialog extends dialogBaseClass {\n  // We do not use `delegatesFocus: true` due to a Chromium bug with\n  // selecting text.\n  // See https://bugs.chromium.org/p/chromium/issues/detail?id=950357\n\n  /**\n   * Opens the dialog when set to `true` and closes it when set to `false`.\n   */\n  @property({type: Boolean})\n  get open() {\n    return this.isOpen;\n  }\n\n  set open(open: boolean) {\n    if (open === this.isOpen) {\n      return;\n    }\n\n    this.isOpen = open;\n    if (open) {\n      this.setAttribute('open', '');\n      this.show();\n    } else {\n      this.removeAttribute('open');\n      this.close();\n    }\n  }\n\n  /**\n   * Skips the opening and closing animations.\n   */\n  @property({type: Boolean}) quick = false;\n\n  /**\n   * Gets or sets the dialog's return value, usually to indicate which button\n   * a user pressed to close it.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/returnValue\n   */\n  @property({attribute: false}) returnValue = '';\n\n  /**\n   * The type of dialog for accessibility. Set this to `alert` to announce a\n   * dialog as an alert dialog.\n   */\n  @property() type?: 'alert';\n\n  /**\n   * Disables focus trapping, which by default keeps keyboard Tab navigation\n   * within the dialog.\n   *\n   * When disabled, after focusing the last element of a dialog, pressing Tab\n   * again will release focus from the window back to the browser (such as the\n   * URL bar).\n   *\n   * Focus trapping is recommended for accessibility, and should not typically\n   * be disabled. Only turn this off if the use case of a dialog is more\n   * accessible without focus trapping.\n   */\n  @property({type: Boolean, attribute: 'no-focus-trap'})\n  noFocusTrap = false;\n\n  /**\n   * Gets the opening animation for a dialog. Set to a new function to customize\n   * the animation.\n   */\n  getOpenAnimation = () => DIALOG_DEFAULT_OPEN_ANIMATION;\n\n  /**\n   * Gets the closing animation for a dialog. Set to a new function to customize\n   * the animation.\n   */\n  getCloseAnimation = () => DIALOG_DEFAULT_CLOSE_ANIMATION;\n\n  private isOpen = false;\n  private isOpening = false;\n  // getIsConnectedPromise() immediately sets the resolve property.\n  private isConnectedPromiseResolve!: () => void;\n  private isConnectedPromise = this.getIsConnectedPromise();\n  @query('dialog') private readonly dialog!: HTMLDialogElement | null;\n  @query('.scrim') private readonly scrim!: HTMLDialogElement | null;\n  @query('.container') private readonly container!: HTMLDialogElement | null;\n  @query('.headline') private readonly headline!: HTMLDialogElement | null;\n  @query('.content') private readonly content!: HTMLDialogElement | null;\n  @query('.actions') private readonly actions!: HTMLDialogElement | null;\n  @state() private isAtScrollTop = false;\n  @state() private isAtScrollBottom = false;\n  @query('.scroller') private readonly scroller!: HTMLElement | null;\n  @query('.top.anchor') private readonly topAnchor!: HTMLElement | null;\n  @query('.bottom.anchor') private readonly bottomAnchor!: HTMLElement | null;\n  @query('.focus-trap')\n  private readonly firstFocusTrap!: HTMLElement | null;\n  private nextClickIsFromContent = false;\n  private intersectionObserver?: IntersectionObserver;\n  // Dialogs should not be SSR'd while open, so we can just use runtime checks.\n  @state() private hasHeadline = false;\n  @state() private hasActions = false;\n  @state() private hasIcon = false;\n  private cancelAnimations?: AbortController;\n\n  // See https://bugs.chromium.org/p/chromium/issues/detail?id=1512224\n  // Chrome v120 has a bug where escape keys do not trigger cancels. If we get\n  // a dialog \"close\" event that is triggered without a \"cancel\" after an escape\n  // keydown, then we need to manually trigger our closing logic.\n  //\n  // This bug occurs when pressing escape to close a dialog without first\n  // interacting with the dialog's content.\n  //\n  // Cleanup tracking:\n  // https://github.com/material-components/material-web/issues/5330\n  // This can be removed when full CloseWatcher support added and the above bug\n  // in Chromium is fixed to fire 'cancel' with one escape press and close with\n  // multiple.\n  private escapePressedWithoutCancel = false;\n  // This TreeWalker is used to walk through a dialog's children to find\n  // focusable elements. TreeWalker is faster than `querySelectorAll('*')`.\n  // We check for isServer because there isn't a \"document\" during an SSR\n  // run.\n  private readonly treewalker = isServer\n    ? null\n    : document.createTreeWalker(this, NodeFilter.SHOW_ELEMENT);\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.addEventListener('submit', this.handleSubmit);\n    }\n  }\n\n  /**\n   * Opens the dialog and fires a cancelable `open` event. After a dialog's\n   * animation, an `opened` event is fired.\n   *\n   * Add an `autofocus` attribute to a child of the dialog that should\n   * receive focus after opening.\n   *\n   * @return A Promise that resolves after the animation is finished and the\n   *     `opened` event was fired.\n   */\n  async show() {\n    this.isOpening = true;\n    // Dialogs can be opened before being attached to the DOM, so we need to\n    // wait until we're connected before calling `showModal()`.\n    await this.isConnectedPromise;\n    await this.updateComplete;\n    const dialog = this.dialog!;\n    // Check if already opened or if `dialog.close()` was called while awaiting.\n    if (dialog.open || !this.isOpening) {\n      this.isOpening = false;\n      return;\n    }\n\n    const preventOpen = !this.dispatchEvent(\n      new Event('open', {cancelable: true}),\n    );\n    if (preventOpen) {\n      this.open = false;\n      this.isOpening = false;\n      return;\n    }\n\n    // All Material dialogs are modal.\n    dialog.showModal();\n    this.open = true;\n    // Reset scroll position if re-opening a dialog with the same content.\n    if (this.scroller) {\n      this.scroller.scrollTop = 0;\n    }\n    // Native modal dialogs ignore autofocus and instead force focus to the\n    // first focusable child. Override this behavior if there is a child with\n    // an autofocus attribute.\n    this.querySelector<HTMLElement>('[autofocus]')?.focus();\n\n    await this.animateDialog(this.getOpenAnimation());\n    this.dispatchEvent(new Event('opened'));\n    this.isOpening = false;\n  }\n\n  /**\n   * Closes the dialog and fires a cancelable `close` event. After a dialog's\n   * animation, a `closed` event is fired.\n   *\n   * @param returnValue A return value usually indicating which button was used\n   *     to close a dialog. If a dialog is canceled by clicking the scrim or\n   *     pressing Escape, it will not change the return value after closing.\n   * @return A Promise that resolves after the animation is finished and the\n   *     `closed` event was fired.\n   */\n  async close(returnValue = this.returnValue) {\n    this.isOpening = false;\n    if (!this.isConnected) {\n      // Disconnected dialogs do not fire close events or animate.\n      this.open = false;\n      return;\n    }\n\n    await this.updateComplete;\n    const dialog = this.dialog!;\n    // Check if already closed or if `dialog.show()` was called while awaiting.\n    if (!dialog.open || this.isOpening) {\n      this.open = false;\n      return;\n    }\n\n    const prevReturnValue = this.returnValue;\n    this.returnValue = returnValue;\n    const preventClose = !this.dispatchEvent(\n      new Event('close', {cancelable: true}),\n    );\n    if (preventClose) {\n      this.returnValue = prevReturnValue;\n      return;\n    }\n\n    await this.animateDialog(this.getCloseAnimation());\n    dialog.close(returnValue);\n    this.open = false;\n    this.dispatchEvent(new Event('closed'));\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    this.isConnectedPromiseResolve();\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    this.isConnectedPromise = this.getIsConnectedPromise();\n  }\n\n  protected override render() {\n    const scrollable =\n      this.open && !(this.isAtScrollTop && this.isAtScrollBottom);\n    const classes = {\n      'has-headline': this.hasHeadline,\n      'has-actions': this.hasActions,\n      'has-icon': this.hasIcon,\n      'scrollable': scrollable,\n      'show-top-divider': scrollable && !this.isAtScrollTop,\n      'show-bottom-divider': scrollable && !this.isAtScrollBottom,\n    };\n\n    // The focus trap sentinels are only added after the dialog opens, since\n    // dialog.showModal() will try to autofocus them, even with tabindex=\"-1\".\n    const showFocusTrap = this.open && !this.noFocusTrap;\n    const focusTrap = html`\n      <div\n        class=\"focus-trap\"\n        tabindex=\"0\"\n        aria-hidden=\"true\"\n        @focus=${this.handleFocusTrapFocus}></div>\n    `;\n\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return html`\n      <div class=\"scrim\"></div>\n      <dialog\n        class=${classMap(classes)}\n        aria-label=${ariaLabel || nothing}\n        aria-labelledby=${this.hasHeadline ? 'headline' : nothing}\n        role=${this.type === 'alert' ? 'alertdialog' : nothing}\n        @cancel=${this.handleCancel}\n        @click=${this.handleDialogClick}\n        @close=${this.handleClose}\n        @keydown=${this.handleKeydown}\n        .returnValue=${this.returnValue || nothing}>\n        ${showFocusTrap ? focusTrap : nothing}\n        <div class=\"container\" @click=${this.handleContentClick}>\n          <div class=\"headline\">\n            <div class=\"icon\" aria-hidden=\"true\">\n              <slot name=\"icon\" @slotchange=${this.handleIconChange}></slot>\n            </div>\n            <h2 id=\"headline\" aria-hidden=${!this.hasHeadline || nothing}>\n              <slot\n                name=\"headline\"\n                @slotchange=${this.handleHeadlineChange}></slot>\n            </h2>\n            <md-divider></md-divider>\n          </div>\n          <div class=\"scroller\">\n            <div class=\"content\">\n              <div class=\"top anchor\"></div>\n              <slot name=\"content\"></slot>\n              <div class=\"bottom anchor\"></div>\n            </div>\n          </div>\n          <div class=\"actions\">\n            <md-divider></md-divider>\n            <slot name=\"actions\" @slotchange=${this.handleActionsChange}></slot>\n          </div>\n        </div>\n        ${showFocusTrap ? focusTrap : nothing}\n      </dialog>\n    `;\n  }\n\n  protected override firstUpdated() {\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          this.handleAnchorIntersection(entry);\n        }\n      },\n      {root: this.scroller!},\n    );\n\n    this.intersectionObserver.observe(this.topAnchor!);\n    this.intersectionObserver.observe(this.bottomAnchor!);\n  }\n\n  private handleDialogClick() {\n    if (this.nextClickIsFromContent) {\n      // Avoid doing a layout calculation below if we know the click came from\n      // content.\n      this.nextClickIsFromContent = false;\n      return;\n    }\n\n    // Click originated on the backdrop. Native `<dialog>`s will not cancel,\n    // but Material dialogs do.\n    const preventDefault = !this.dispatchEvent(\n      new Event('cancel', {cancelable: true}),\n    );\n    if (preventDefault) {\n      return;\n    }\n\n    this.close();\n  }\n\n  private handleContentClick() {\n    this.nextClickIsFromContent = true;\n  }\n\n  private handleSubmit(event: SubmitEvent) {\n    const form = event.target as HTMLFormElement;\n    const {submitter} = event;\n    if (form.method !== 'dialog' || !submitter) {\n      return;\n    }\n\n    // Close reason is the submitter's value attribute, or the dialog's\n    // `returnValue` if there is no attribute.\n    this.close(submitter.getAttribute('value') ?? this.returnValue);\n  }\n\n  private handleCancel(event: Event) {\n    if (event.target !== this.dialog) {\n      // Ignore any cancel events dispatched by content.\n      return;\n    }\n\n    this.escapePressedWithoutCancel = false;\n    const preventDefault = !redispatchEvent(this, event);\n    // We always prevent default on the original dialog event since we'll\n    // animate closing it before it actually closes.\n    event.preventDefault();\n    if (preventDefault) {\n      return;\n    }\n\n    this.close();\n  }\n\n  private handleClose() {\n    if (!this.escapePressedWithoutCancel) {\n      return;\n    }\n\n    this.escapePressedWithoutCancel = false;\n    this.dialog?.dispatchEvent(new Event('cancel', {cancelable: true}));\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    if (event.key !== 'Escape') {\n      return;\n    }\n\n    // An escape key was pressed. If a \"close\" event fires next without a\n    // \"cancel\" event first, then we know we're in the Chrome v120 bug.\n    this.escapePressedWithoutCancel = true;\n    // Wait a full task for the cancel/close event listeners to fire, then\n    // reset the flag.\n    setTimeout(() => {\n      this.escapePressedWithoutCancel = false;\n    });\n  }\n\n  private async animateDialog(animation: DialogAnimation) {\n    // Always cancel the previous animations. Animations can include `fill`\n    // modes that need to be cleared when `quick` is toggled. If not, content\n    // that faded out will remain hidden when a `quick` dialog re-opens after\n    // previously opening and closing without `quick`.\n    this.cancelAnimations?.abort();\n    this.cancelAnimations = new AbortController();\n    if (this.quick) {\n      return;\n    }\n\n    const {dialog, scrim, container, headline, content, actions} = this;\n    if (!dialog || !scrim || !container || !headline || !content || !actions) {\n      return;\n    }\n\n    const {\n      container: containerAnimate,\n      dialog: dialogAnimate,\n      scrim: scrimAnimate,\n      headline: headlineAnimate,\n      content: contentAnimate,\n      actions: actionsAnimate,\n    } = animation;\n\n    const elementAndAnimation: Array<[Element, DialogAnimationArgs[]]> = [\n      [dialog, dialogAnimate ?? []],\n      [scrim, scrimAnimate ?? []],\n      [container, containerAnimate ?? []],\n      [headline, headlineAnimate ?? []],\n      [content, contentAnimate ?? []],\n      [actions, actionsAnimate ?? []],\n    ];\n\n    const animations: Animation[] = [];\n    for (const [element, animation] of elementAndAnimation) {\n      for (const animateArgs of animation) {\n        const animation = element.animate(...animateArgs);\n        this.cancelAnimations.signal.addEventListener('abort', () => {\n          animation.cancel();\n        });\n\n        animations.push(animation);\n      }\n    }\n\n    await Promise.all(\n      animations.map((animation) =>\n        animation.finished.catch(() => {\n          // Ignore intentional AbortErrors when calling `animation.cancel()`.\n        }),\n      ),\n    );\n  }\n\n  private handleHeadlineChange(event: Event) {\n    const slot = event.target as HTMLSlotElement;\n    this.hasHeadline = slot.assignedElements().length > 0;\n  }\n\n  private handleActionsChange(event: Event) {\n    const slot = event.target as HTMLSlotElement;\n    this.hasActions = slot.assignedElements().length > 0;\n  }\n\n  private handleIconChange(event: Event) {\n    const slot = event.target as HTMLSlotElement;\n    this.hasIcon = slot.assignedElements().length > 0;\n  }\n\n  private handleAnchorIntersection(entry: IntersectionObserverEntry) {\n    const {target, isIntersecting} = entry;\n    if (target === this.topAnchor) {\n      this.isAtScrollTop = isIntersecting;\n    }\n\n    if (target === this.bottomAnchor) {\n      this.isAtScrollBottom = isIntersecting;\n    }\n  }\n\n  private getIsConnectedPromise() {\n    return new Promise<void>((resolve) => {\n      this.isConnectedPromiseResolve = resolve;\n    });\n  }\n\n  private handleFocusTrapFocus(event: FocusEvent) {\n    const [firstFocusableChild, lastFocusableChild] =\n      this.getFirstAndLastFocusableChildren();\n    if (!firstFocusableChild || !lastFocusableChild) {\n      // When a dialog does not have focusable children, the dialog itself\n      // receives focus.\n      this.dialog?.focus();\n      return;\n    }\n\n    // To determine which child to focus, we need to know which focus trap\n    // received focus...\n    const isFirstFocusTrap = event.target === this.firstFocusTrap;\n    const isLastFocusTrap = !isFirstFocusTrap;\n    // ...and where the focus came from (what was previously focused).\n    const focusCameFromFirstChild = event.relatedTarget === firstFocusableChild;\n    const focusCameFromLastChild = event.relatedTarget === lastFocusableChild;\n    // Although this is a focus trap, focus can come from outside the trap.\n    // This can happen when elements are programmatically `focus()`'d. It also\n    // happens when focus leaves and returns to the window, such as clicking on\n    // the browser's URL bar and pressing Tab, or switching focus between\n    // iframes.\n    const focusCameFromOutsideDialog =\n      !focusCameFromFirstChild && !focusCameFromLastChild;\n\n    // Focus the dialog's first child when we reach the end of the dialog and\n    // focus is moving forward. Or, when focus is moving forwards into the\n    // dialog from outside of the window.\n    const shouldFocusFirstChild =\n      (isLastFocusTrap && focusCameFromLastChild) ||\n      (isFirstFocusTrap && focusCameFromOutsideDialog);\n    if (shouldFocusFirstChild) {\n      firstFocusableChild.focus();\n      return;\n    }\n\n    // Focus the dialog's last child when we reach the beginning of the dialog\n    // and focus is moving backward. Or, when focus is moving backwards into the\n    // dialog from outside of the window.\n    const shouldFocusLastChild =\n      (isFirstFocusTrap && focusCameFromFirstChild) ||\n      (isLastFocusTrap && focusCameFromOutsideDialog);\n    if (shouldFocusLastChild) {\n      lastFocusableChild.focus();\n      return;\n    }\n\n    // The booleans above are verbose for readability, but code executation\n    // won't actually reach here.\n  }\n\n  private getFirstAndLastFocusableChildren():\n    | [HTMLElement, HTMLElement]\n    | [null, null] {\n    if (!this.treewalker) {\n      return [null, null];\n    }\n\n    let firstFocusableChild: HTMLElement | null = null;\n    let lastFocusableChild: HTMLElement | null = null;\n\n    // Reset the current node back to the root host element.\n    this.treewalker.currentNode = this.treewalker.root;\n    while (this.treewalker.nextNode()) {\n      // Cast as Element since the TreeWalker filter only accepts Elements.\n      const nextChild = this.treewalker.currentNode as Element;\n      if (!isFocusable(nextChild)) {\n        continue;\n      }\n\n      if (!firstFocusableChild) {\n        firstFocusableChild = nextChild;\n      }\n\n      lastFocusableChild = nextChild;\n    }\n\n    // We set lastFocusableChild immediately after finding a\n    // firstFocusableChild, which means the pair is either both null or both\n    // non-null. Cast since TypeScript does not recognize this.\n    return [firstFocusableChild, lastFocusableChild] as\n      | [HTMLElement, HTMLElement]\n      | [null, null];\n  }\n}\n\nfunction isFocusable(element: Element): element is HTMLElement {\n  // Check if the element is a known built-in focusable element:\n  // - <a> and <area> with `href` attributes.\n  // - Form controls that are not disabled.\n  // - `contenteditable` elements.\n  // - Anything with a non-negative `tabindex`.\n  const knownFocusableElements =\n    ':is(button,input,select,textarea,object,:is(a,area)[href],[tabindex],[contenteditable=true])';\n  const notDisabled = ':not(:disabled,[disabled])';\n  const notNegativeTabIndex = ':not([tabindex^=\"-\"])';\n  if (\n    element.matches(knownFocusableElements + notDisabled + notNegativeTabIndex)\n  ) {\n    return true;\n  }\n\n  const isCustomElement = element.localName.includes('-');\n  if (!isCustomElement) {\n    return false;\n  }\n\n  // If a custom element does not have a tabindex, it may still be focusable\n  // if it delegates focus with a shadow root. We also need to check again if\n  // the custom element is a disabled form control.\n  if (!element.matches(notDisabled)) {\n    return false;\n  }\n\n  return element.shadowRoot?.delegatesFocus ?? false;\n}\n","import { MdDialog } from \"@material/web/dialog/dialog\";\nimport {\n  type DialogAnimation,\n  DIALOG_DEFAULT_CLOSE_ANIMATION,\n  DIALOG_DEFAULT_OPEN_ANIMATION,\n} from \"@material/web/dialog/internal/animations\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n// workaround to be able to overlay an dialog with another dialog\nMdDialog.addInitializer(async (instance) => {\n  await instance.updateComplete;\n\n  const dialogInstance = instance as MdDialog;\n\n  // @ts-expect-error dialog is private\n  dialogInstance.dialog.prepend(dialogInstance.scrim);\n  // @ts-expect-error scrim is private\n  dialogInstance.scrim.style.inset = 0;\n  // @ts-expect-error scrim is private\n  dialogInstance.scrim.style.zIndex = 0;\n\n  const { getOpenAnimation, getCloseAnimation } = dialogInstance;\n  dialogInstance.getOpenAnimation = () => {\n    const animations = getOpenAnimation.call(this);\n    animations.container = [\n      ...(animations.container ?? []),\n      ...(animations.dialog ?? []),\n    ];\n    animations.dialog = [];\n    return animations;\n  };\n  dialogInstance.getCloseAnimation = () => {\n    const animations = getCloseAnimation.call(this);\n    animations.container = [\n      ...(animations.container ?? []),\n      ...(animations.dialog ?? []),\n    ];\n    animations.dialog = [];\n    return animations;\n  };\n});\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nlet DIALOG_POLYFILL: Promise<typeof import(\"dialog-polyfill\")>;\n\n/**\n * Based on the home assistant design: https://design.home-assistant.io/#components/ha-dialogs\n *\n */\n@customElement(\"ha-md-dialog\")\nexport class HaMdDialog extends MdDialog {\n  /**\n   * When true the dialog will not close when the user presses the esc key or press out of the dialog.\n   */\n  @property({ attribute: \"disable-cancel-action\", type: Boolean })\n  public disableCancelAction = false;\n\n  private _polyfillDialogRegistered = false;\n\n  constructor() {\n    super();\n    this.addEventListener(\"cancel\", this._handleCancel);\n\n    if (typeof HTMLDialogElement !== \"function\") {\n      this.addEventListener(\"open\", this._handleOpen);\n\n      if (!DIALOG_POLYFILL) {\n        DIALOG_POLYFILL = import(\"dialog-polyfill\");\n      }\n    }\n\n    // if browser doesn't support animate API disable open/close animations\n    if (this.animate === undefined) {\n      this.quick = true;\n    }\n\n    // if browser doesn't support animate API disable open/close animations\n    if (this.animate === undefined) {\n      this.quick = true;\n    }\n  }\n\n  // prevent open in older browsers and wait for polyfill to load\n  private async _handleOpen(openEvent: Event) {\n    openEvent.preventDefault();\n\n    if (this._polyfillDialogRegistered) {\n      return;\n    }\n\n    this._polyfillDialogRegistered = true;\n    this._loadPolyfillStylesheet(\"/static/polyfills/dialog-polyfill.css\");\n    const dialog = this.shadowRoot?.querySelector(\n      \"dialog\"\n    ) as HTMLDialogElement;\n\n    const dialogPolyfill = await DIALOG_POLYFILL;\n    dialogPolyfill.default.registerDialog(dialog);\n    this.removeEventListener(\"open\", this._handleOpen);\n\n    this.show();\n  }\n\n  private async _loadPolyfillStylesheet(href) {\n    const link = document.createElement(\"link\");\n    link.rel = \"stylesheet\";\n    link.href = href;\n\n    return new Promise<void>((resolve, reject) => {\n      link.onload = () => resolve();\n      link.onerror = () =>\n        reject(new Error(`Stylesheet failed to load: ${href}`));\n\n      this.shadowRoot?.appendChild(link);\n    });\n  }\n\n  _handleCancel(closeEvent: Event) {\n    if (this.disableCancelAction) {\n      closeEvent.preventDefault();\n      const dialogElement = this.shadowRoot?.querySelector(\"dialog .container\");\n      if (this.animate !== undefined) {\n        dialogElement?.animate(\n          [\n            {\n              transform: \"rotate(-1deg)\",\n              \"animation-timing-function\": \"ease-in\",\n            },\n            {\n              transform: \"rotate(1.5deg)\",\n              \"animation-timing-function\": \"ease-out\",\n            },\n            {\n              transform: \"rotate(0deg)\",\n              \"animation-timing-function\": \"ease-in\",\n            },\n          ],\n          {\n            duration: 200,\n            iterations: 2,\n          }\n        );\n      }\n    }\n  }\n\n  static override styles = [\n    ...super.styles,\n    css`\n      :host {\n        --md-dialog-container-color: var(--card-background-color);\n        --md-dialog-headline-color: var(--primary-text-color);\n        --md-dialog-supporting-text-color: var(--primary-text-color);\n        --md-sys-color-scrim: #000000;\n\n        --md-dialog-headline-weight: 400;\n        --md-dialog-headline-size: 1.574rem;\n        --md-dialog-supporting-text-size: 1rem;\n        --md-dialog-supporting-text-line-height: 1.5rem;\n      }\n\n      :host([type=\"alert\"]) {\n        min-width: 320px;\n      }\n\n      :host(:not([type=\"alert\"])) {\n        @media all and (max-width: 450px), all and (max-height: 500px) {\n          min-width: calc(\n            100vw - env(safe-area-inset-right) - env(safe-area-inset-left)\n          );\n          max-width: calc(\n            100vw - env(safe-area-inset-right) - env(safe-area-inset-left)\n          );\n          min-height: 100%;\n          max-height: 100%;\n          --md-dialog-container-shape: 0;\n        }\n      }\n\n      :host ::slotted(ha-dialog-header) {\n        display: contents;\n      }\n\n      .scroller {\n        overflow: var(--dialog-content-overflow, auto);\n      }\n\n      slot[name=\"content\"]::slotted(*) {\n        padding: var(--dialog-content-padding, 24px);\n      }\n      .scrim {\n        z-index: 10; // overlay navigation\n      }\n    `,\n  ];\n}\n\n// by default the dialog open/close animation will be from/to the top\n// but if we have a special mobile dialog which is at the bottom of the screen, an from bottom animation can be used:\nconst OPEN_FROM_BOTTOM_ANIMATION: DialogAnimation = {\n  ...DIALOG_DEFAULT_OPEN_ANIMATION,\n  dialog: [\n    [\n      // Dialog slide up\n      [{ transform: \"translateY(50px)\" }, { transform: \"translateY(0)\" }],\n      { duration: 500, easing: \"cubic-bezier(.3,0,0,1)\" },\n    ],\n  ],\n  container: [\n    [\n      // Container fade in\n      [{ opacity: 0 }, { opacity: 1 }],\n      { duration: 50, easing: \"linear\", pseudoElement: \"::before\" },\n    ],\n  ],\n};\n\nconst CLOSE_TO_BOTTOM_ANIMATION: DialogAnimation = {\n  ...DIALOG_DEFAULT_CLOSE_ANIMATION,\n  dialog: [\n    [\n      // Dialog slide down\n      [{ transform: \"translateY(0)\" }, { transform: \"translateY(50px)\" }],\n      { duration: 150, easing: \"cubic-bezier(.3,0,0,1)\" },\n    ],\n  ],\n  container: [\n    [\n      // Container fade out\n      [{ opacity: \"1\" }, { opacity: \"0\" }],\n      { delay: 100, duration: 50, easing: \"linear\", pseudoElement: \"::before\" },\n    ],\n  ],\n};\n\nexport const getMobileOpenFromBottomAnimation = () => {\n  const matches = window.matchMedia(\n    \"all and (max-width: 450px), all and (max-height: 500px)\"\n  ).matches;\n  return matches ? OPEN_FROM_BOTTOM_ANIMATION : DIALOG_DEFAULT_OPEN_ANIMATION;\n};\n\nexport const getMobileCloseToBottomAnimation = () => {\n  const matches = window.matchMedia(\n    \"all and (max-width: 450px), all and (max-height: 500px)\"\n  ).matches;\n  return matches ? CLOSE_TO_BOTTOM_ANIMATION : DIALOG_DEFAULT_CLOSE_ANIMATION;\n};\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-md-dialog\": HaMdDialog;\n  }\n}\n","import { mdiAlertOutline } from \"@mdi/js\";\nimport type { CSSResultGroup } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../../components/ha-md-dialog\";\nimport type { HaMdDialog } from \"../../components/ha-md-dialog\";\nimport \"../../components/ha-dialog-header\";\nimport \"../../components/ha-svg-icon\";\nimport \"../../components/ha-button\";\nimport \"../../components/ha-textfield\";\nimport type { HaTextField } from \"../../components/ha-textfield\";\nimport type { HomeAssistant } from \"../../types\";\nimport type { DialogBoxParams } from \"./show-dialog-box\";\n\n@customElement(\"dialog-box\")\nclass DialogBox extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _params?: DialogBoxParams;\n\n  @state() private _closeState?: \"canceled\" | \"confirmed\";\n\n  @query(\"ha-textfield\") private _textField?: HaTextField;\n\n  @query(\"ha-md-dialog\") private _dialog?: HaMdDialog;\n\n  public async showDialog(params: DialogBoxParams): Promise<void> {\n    this._params = params;\n  }\n\n  public closeDialog(): boolean {\n    if (this._params?.confirmation || this._params?.prompt) {\n      return false;\n    }\n    if (this._params) {\n      this._dismiss();\n      return true;\n    }\n    return true;\n  }\n\n  protected render() {\n    if (!this._params) {\n      return nothing;\n    }\n\n    const confirmPrompt = this._params.confirmation || this._params.prompt;\n\n    const dialogTitle =\n      this._params.title ||\n      (this._params.confirmation &&\n        this.hass.localize(\"ui.dialogs.generic.default_confirmation_title\"));\n\n    return html`\n      <ha-md-dialog\n        open\n        .disableCancelAction=${confirmPrompt || false}\n        @closed=${this._dialogClosed}\n        type=\"alert\"\n        aria-labelledby=\"dialog-box-title\"\n        aria-describedby=\"dialog-box-description\"\n      >\n        <div slot=\"headline\">\n          <span .title=${dialogTitle} id=\"dialog-box-title\">\n            ${this._params.warning\n              ? html`<ha-svg-icon\n                  .path=${mdiAlertOutline}\n                  style=\"color: var(--warning-color)\"\n                ></ha-svg-icon> `\n              : nothing}\n            ${dialogTitle}\n          </span>\n        </div>\n        <div slot=\"content\" id=\"dialog-box-description\">\n          ${this._params.text ? html` <p>${this._params.text}</p> ` : \"\"}\n          ${this._params.prompt\n            ? html`\n                <ha-textfield\n                  dialogInitialFocus\n                  value=${ifDefined(this._params.defaultValue)}\n                  .placeholder=${this._params.placeholder}\n                  .label=${this._params.inputLabel\n                    ? this._params.inputLabel\n                    : \"\"}\n                  .type=${this._params.inputType\n                    ? this._params.inputType\n                    : \"text\"}\n                  .min=${this._params.inputMin}\n                  .max=${this._params.inputMax}\n                ></ha-textfield>\n              `\n            : \"\"}\n        </div>\n        <div slot=\"actions\">\n          ${confirmPrompt &&\n          html`\n            <ha-button\n              @click=${this._dismiss}\n              ?dialogInitialFocus=${!this._params.prompt &&\n              this._params.destructive}\n            >\n              ${this._params.dismissText\n                ? this._params.dismissText\n                : this.hass.localize(\"ui.dialogs.generic.cancel\")}\n            </ha-button>\n          `}\n          <ha-button\n            @click=${this._confirm}\n            ?dialogInitialFocus=${!this._params.prompt &&\n            !this._params.destructive}\n            class=${classMap({\n              destructive: this._params.destructive || false,\n            })}\n          >\n            ${this._params.confirmText\n              ? this._params.confirmText\n              : this.hass.localize(\"ui.dialogs.generic.ok\")}\n          </ha-button>\n        </div>\n      </ha-md-dialog>\n    `;\n  }\n\n  private _cancel(): void {\n    if (this._params?.cancel) {\n      this._params.cancel();\n    }\n  }\n\n  private _dismiss(): void {\n    this._closeState = \"canceled\";\n    this._closeDialog();\n    this._cancel();\n  }\n\n  private _confirm(): void {\n    this._closeState = \"confirmed\";\n    this._closeDialog();\n    if (this._params!.confirm) {\n      this._params!.confirm(this._textField?.value);\n    }\n  }\n\n  private _closeDialog() {\n    fireEvent(this, \"dialog-closed\", { dialog: this.localName });\n    this._dialog?.close();\n  }\n\n  private _dialogClosed() {\n    if (!this._closeState) {\n      fireEvent(this, \"dialog-closed\", { dialog: this.localName });\n      this._cancel();\n    }\n    this._closeState = undefined;\n    this._params = undefined;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host([inert]) {\n        pointer-events: initial !important;\n        cursor: initial !important;\n      }\n      a {\n        color: var(--primary-color);\n      }\n      p {\n        margin: 0;\n        color: var(--primary-text-color);\n      }\n      .no-bottom-padding {\n        padding-bottom: 0;\n      }\n      .secondary {\n        color: var(--secondary-text-color);\n      }\n      .destructive {\n        --mdc-theme-primary: var(--error-color);\n      }\n      ha-textfield {\n        width: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"dialog-box\": DialogBox;\n  }\n}\n"],"names":[],"sourceRoot":""}