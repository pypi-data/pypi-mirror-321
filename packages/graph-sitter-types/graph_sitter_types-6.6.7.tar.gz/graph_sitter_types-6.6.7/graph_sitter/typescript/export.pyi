"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator
from typing import Generic, Literal, Self, TYPE_CHECKING, TypeVar
from tree_sitter import Node as TSNode
from graph_sitter.codebase.codebase_graph import CodebaseGraph
from graph_sitter.core.autocommit import commiter, reader
from graph_sitter.core.autocommit.decorators import writer
from graph_sitter.core.export import Export
from graph_sitter.core.expressions.name import Name
from graph_sitter.core.interfaces.chainable import Chainable
from graph_sitter.core.interfaces.exportable import Exportable
from graph_sitter.core.interfaces.has_value import HasValue
from graph_sitter.core.interfaces.importable import Importable
from graph_sitter.core.node_id_factory import NodeId
from graph_sitter.core.symbol_groups.collection import Collection
from graph_sitter.enums import ImportType, NodeType
from graph_sitter.typescript.import_resolution import TSImport
from graph_sitter.typescript.symbol import TSSymbol
from graph_sitter.writer_decorators import noapidoc, ts_apidoc
from graph_sitter.core.statements.export_statement import ExportStatement

if TYPE_CHECKING:
    ...
@ts_apidoc
class TSExport(Export["Collection[TSExport, ExportStatement[TSExport]]"], HasValue, Chainable):
    """Represents a single exported symbol. There is a 1:M relationship between an ExportStatement and an Export"""
    _declared_symbol: TSSymbol | TSImport | None
    _exported_symbol: Name | None
    _name_node: Name | None
    node_type: Literal[NodeType.EXPORT] = ...
    def __init__(self, ts_node: TSNode, file_node_id: NodeId, parent: Collection[TSExport, ExportStatement[TSExport]], G: CodebaseGraph, name_node: TSNode | None = ..., declared_symbol: TSSymbol | TSImport | None = ..., exported_symbol: TSNode | None = ..., value_node: TSNode | None = ...) -> None:
        """Given an `export_statement` tree sitter node, parses all implicit export symbols."""
        ...
    
    @classmethod
    @noapidoc
    def from_export_statement_with_declaration(cls, export_statement: TSNode, declaration: TSNode, file_id: NodeId, G: CodebaseGraph, parent: ExportStatement[TSExport], pos: int) -> list[TSExport]:
        ...
    
    @classmethod
    @noapidoc
    def from_export_statement_with_value(cls, export_statement: TSNode, value: TSNode, file_id: NodeId, G: CodebaseGraph, parent: ExportStatement[TSExport], pos: int) -> list[TSExport]:
        ...
    
    @noapidoc
    @commiter
    def parse(self, G: CodebaseGraph) -> None:
        ...
    
    @noapidoc
    @commiter
    def compute_export_dependencies(self) -> None:
        """Create Export edges from this export to it's used symbols"""
        ...
    
    @reader
    def is_named_export(self) -> bool:
        """Determines whether this export is a named export.

        Named exports are exports that are not default exports. For example, `export const foo = 'bar'` is a named export,
        while `export default foo` is not.

        Returns:
            bool: True if this is a named export, False if it is a default export.
        """
        ...
    
    @reader
    def is_default_export(self) -> bool:
        """Determines if an export is the default export for a file.

        This function checks if the export is a default export by examining the export source code and the export's symbol. It handles various cases of default exports including:
        - Re-exports as default (`export { foo as default }`)
        - Default exports (`export default foo`)
        - Module exports (`export = foo`)

        Returns:
            bool: True if this is a default export, False otherwise.
        """
        ...
    
    @reader
    def is_default_symbol_export(self) -> bool:
        """Returns True if this is exporting a default symbol, as opposed to a default object export.

        This method checks if an export is a default symbol export (e.g. 'export default foo') rather than a default object export (e.g. 'export default { foo }').
        It handles both direct exports and re-exports.

        Args:
            self (TSExport): The export object being checked.

        Returns:
            bool: True if this is a default symbol export, False otherwise.
        """
        ...
    
    @reader
    def is_type_export(self) -> bool:
        """Determines if this export is exclusively exporting a type.

        Checks if this export starts with "export type" to identify if it's only exporting a type definition.
        This method is used to distinguish between value exports and type exports in TypeScript.

        Returns:
            bool: True if this is a type-only export, False otherwise.
        """
        ...
    
    @reader
    def is_reexport(self) -> bool:
        """Returns whether the export is re-exporting an import or export.

        Checks if this export node is re-exporting a symbol that was originally imported from another module or exported from another location. This includes wildcard re-exports of entire modules.

        Args:
            self (TSExport): The export node being checked.

        Returns:
            bool: True if this export re-exports an imported/exported symbol or entire module, False otherwise.
        """
        ...
    
    @reader
    def is_wildcard_export(self) -> bool:
        """Determines if the export is a wildcard export.

        Checks if the export statement contains a wildcard export pattern 'export *' or 'export *;'. A wildcard export exports all symbols from a module.

        Returns:
            bool: True if the export is a wildcard export (e.g. 'export * from "./module"'), False otherwise.
        """
        ...
    
    @reader
    def is_module_export(self) -> bool:
        """Determines if the export is exporting a module rather than a symbol.

        Returns True if the export is a wildcard export (e.g. 'export *') or if it is a default export but not of a symbol (e.g. 'export default { foo }').

        Returns:
            bool: True if the export represents a module export, False otherwise.
        """
        ...
    
    @property
    @reader(cache=False)
    def declared_symbol(self) -> TSSymbol | TSImport | None:
        """Returns the symbol that was defined in this export.

        Returns the symbol that was directly declared within this export statement. For class, function,
        interface, type alias, enum declarations or assignments, returns the declared symbol.
        For re-exports or exports without declarations, returns None.

        Returns:
            Union[TSSymbol, TSImport, None]: The symbol declared within this export statement,
                or None if no symbol was declared.
        """
        ...
    
    @property
    @reader
    def exported_symbol(self) -> Exportable | None:
        """Returns the symbol, file, or import being exported from this export object.

        Retrieves the symbol or module being exported by this export node by finding the node connected via an EXPORT edge.
        This method is the inverse of Import.imported_symbol.

        Args:
            None

        Returns:
            Exportable | None: The exported symbol, file, or import, or None if no symbol is exported.
        """
        ...
    
    @property
    @reader
    def resolved_symbol(self) -> Exportable | None:
        """Returns the Symbol, SourceFile or External module that this export resolves to.

        Recursively traverses through indirect imports and exports to find the final resolved symbol.
        This is useful for determining what symbol an export ultimately points to, particularly in cases of re-exports and import-export chains.

        Returns:
            Exportable | None: The final resolved Symbol, SourceFile or External module, or None if the resolution fails. The resolution follows this chain:
                - If the symbol is an Import, resolves to its imported symbol
                - If the symbol is an Export, resolves to its exported symbol
                - Otherwise returns the symbol itself

        Note:
            Handles circular references by tracking visited symbols to prevent infinite loops.
        """
        ...
    
    @writer
    def make_non_default(self) -> None:
        """Converts the export to a named export.

        Transforms default exports into named exports by modifying the export syntax and updating any corresponding export/import usages.
        For default exports, it removes the 'default' keyword and adjusts all import statements that reference this export.

        Args:
            None

        Returns:
            None
        """
        ...
    
    @property
    @noapidoc
    def names(self) -> Generator[tuple[str, Self | WildcardExport[Self]], None, None]:
        ...
    
    @property
    def descendant_symbols(self) -> list[Importable]:
        """Returns a list of all descendant symbols from this export's declared symbol.

        Returns all child symbols that are contained within the declared symbol of this export. For example,
        if the declared symbol is a class, this will return all methods, properties and nested classes.
        If the export has no declared symbol, returns an empty list.

        Returns:
            list[Importable]: List of descendant symbols. Empty list if no declared symbol exists.
        """
        ...
    
    def __hash__(self) -> int:
        ...
    
    @reader
    def __eq__(self, other: object) -> bool:
        ...
    
    @property
    @reader
    def source(self) -> str:
        """Returns the source code of the symbol.

        Gets the source code of the symbol from its extended representation, which includes the export statement.

        Returns:
            str: The complete source code of the symbol including any extended nodes.
        """
        ...
    
    @property
    @reader
    def is_external_export(self) -> bool:
        """Determines if this export is exporting a symbol from an external (non-relative) module.

        An external module is one that comes from outside the project's codebase.

        Returns:
            bool: True if the export is from an external module, False otherwise.
        """
        ...
    
    @reader
    def to_import_string(self) -> str:
        """Converts this export into its equivalent import string representation.

        This is primarily used for handling re-exports, converting them into their
        equivalent import statements.

        Returns:
            str: The import string representation of this export.

        Examples:
            - For `export { foo } from './bar'` -> `import { foo } from './bar'`
            - For `export * from './bar'` -> `import * as _namespace from './bar'`
            - For `export { default as foo } from './bar'` -> `import foo from './bar'`
        """
        ...
    
    @reader
    def get_import_string(self, alias: str | None = ..., module: str | None = ..., import_type: ImportType = ..., is_type_import: bool = ...) -> str:
        """Returns the import string for this export.

        Args:
            alias (str | None): Optional alias to use when importing the symbol.
            module (str | None): Optional module name to import from.
            import_type (ImportType): The type of import to generate.
            is_type_import (bool): Whether this is a type-only import.

        Returns:
            str: The formatted import string.
        """
        ...
    
    @reader
    def reexport_symbol(self) -> TSImport | None:
        """Returns the import object that is re-exporting this symbol.

        For re-exports like:
        - `export { foo } from './bar'`  # Direct re-export
        - `export { default as baz } from './bar'`  # Direct default re-export
        - `export * from './bar'`  # Direct wildcard re-export
        - `import { foo } from './bar'; export { foo }`  # Local re-export

        This returns the corresponding import object that's being re-exported.

        Returns:
            TSImport | None: The import object being re-exported, or None if this
            is not a re-export or no import was found.
        """
        ...
    


TExport = TypeVar("TExport", bound="Export")
class WildcardExport(Chainable, Generic[TExport]):
    """Class to represent one of many wildcard exports."""
    exp: TExport
    symbol: Exportable
    def __init__(self, exp: TExport, symbol: Exportable) -> None:
        ...
    


