# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "ad_create(address)uint64": {
            "call_config": {
                "no_op": "CREATE"
            }
        },
        "ad_config(address,address,bool,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "ad_delete(address)void": {
            "call_config": {
                "delete_application": "CALL"
            }
        },
        "ad_ready(address,bool)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void": {
            "structs": {
                "val_info": {
                    "name": "ValidatorSelfDisclosure",
                    "elements": [
                        [
                            "name",
                            "byte[30]"
                        ],
                        [
                            "https",
                            "byte[60]"
                        ],
                        [
                            "country_code",
                            "byte[2]"
                        ],
                        [
                            "hw_cat",
                            "uint64"
                        ],
                        [
                            "node_version",
                            "byte[20]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void": {
            "structs": {
                "terms_time": {
                    "name": "ValidatorTermsTiming",
                    "elements": [
                        [
                            "rounds_setup",
                            "uint64"
                        ],
                        [
                            "rounds_confirm",
                            "uint64"
                        ],
                        [
                            "rounds_duration_min",
                            "uint64"
                        ],
                        [
                            "rounds_duration_max",
                            "uint64"
                        ],
                        [
                            "round_max_end",
                            "uint64"
                        ]
                    ]
                },
                "terms_price": {
                    "name": "ValidatorTermsPricing",
                    "elements": [
                        [
                            "commission",
                            "uint64"
                        ],
                        [
                            "fee_round_min",
                            "uint64"
                        ],
                        [
                            "fee_round_var",
                            "uint64"
                        ],
                        [
                            "fee_setup",
                            "uint64"
                        ],
                        [
                            "fee_asset_id",
                            "uint64"
                        ]
                    ]
                },
                "terms_stake": {
                    "name": "ValidatorTermsStakeLimits",
                    "elements": [
                        [
                            "stake_max",
                            "uint64"
                        ],
                        [
                            "stake_gratis",
                            "uint64"
                        ]
                    ]
                },
                "terms_reqs": {
                    "name": "ValidatorTermsGating",
                    "elements": [
                        [
                            "gating_asa_list",
                            "(uint64,uint64)[2]"
                        ]
                    ]
                },
                "terms_warn": {
                    "name": "ValidatorTermsWarnings",
                    "elements": [
                        [
                            "cnt_warning_max",
                            "uint64"
                        ],
                        [
                            "rounds_warning",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "ad_income(address,uint64)uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "ad_asa_close(address,uint64)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "template_load_init(address,uint64,pay)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "template_load_data(address,uint64,byte[])void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "template_load_end(address)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_create(address,address,uint64,uint64,address,uint64,pay,txn)uint64": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_confirm(address,application)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_confirmed(application)(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_not_submitted(application)(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])": {
            "structs": {
                "key_reg_txn_info": {
                    "name": "KeyRegTxnInfo",
                    "elements": [
                        [
                            "vote_first",
                            "uint64"
                        ],
                        [
                            "vote_last",
                            "uint64"
                        ],
                        [
                            "vote_key_dilution",
                            "uint64"
                        ],
                        [
                            "vote_pk",
                            "byte[32]"
                        ],
                        [
                            "selection_pk",
                            "byte[32]"
                        ],
                        [
                            "state_proof_pk",
                            "byte[64]"
                        ],
                        [
                            "sender",
                            "address"
                        ]
                    ]
                },
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])": {
            "structs": {
                "output": {
                    "name": "BreachLimitsReturn",
                    "elements": [
                        [
                            "max_breach_reached",
                            "bool"
                        ],
                        [
                            "earnings_distribution",
                            "(uint64,uint64,uint64)"
                        ],
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "breach_pay(application)(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "breach_suspended(application)((uint64,uint64,uint64),address,byte[100])": {
            "structs": {
                "output": {
                    "name": "EarningsDistributionAndMessage",
                    "elements": [
                        [
                            "earnings_distribution",
                            "(uint64,uint64,uint64)"
                        ],
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_claim(application)(uint64,uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "EarningsDistribution",
                    "elements": [
                        [
                            "user",
                            "uint64"
                        ],
                        [
                            "platform",
                            "uint64"
                        ],
                        [
                            "asset_id",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_expired(application)(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_withdraw(address,application)void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_delete(address,application)(uint64,uint64)": {
            "structs": {
                "output": {
                    "name": "ContractDeleteReturn",
                    "elements": [
                        [
                            "remaining_balance",
                            "uint64"
                        ],
                        [
                            "asset_id",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])": {
            "structs": {
                "output": {
                    "name": "Message",
                    "elements": [
                        [
                            "del_manager",
                            "address"
                        ],
                        [
                            "msg",
                            "byte[100]"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "gas()void": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "get_validator_asa(uint64)(uint64,uint64)": {
            "read_only": true,
            "structs": {
                "output": {
                    "name": "ValidatorASA",
                    "elements": [
                        [
                            "total_earning",
                            "uint64"
                        ],
                        [
                            "total_fees_generated",
                            "uint64"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCgpzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFwcHJvdmFsX3Byb2dyYW06CiAgICBpbnRjYmxvY2sgMCAxIDYgMTAwMDAwMCA0MDk2CiAgICBieXRlY2Jsb2NrIDB4MTUxZjdjNzUgInN0YXRlIiAidmFsX293bmVyIiAweDY0ICJjbnRfZGVsIiAiZGVsX2FwcF9saXN0IiAiVCIgIlAiICJjbnRfYXNhIiAiUyIgIlciICJ2YWxfbWFuYWdlciIgMHgwMiAweDYxNzM2MTVmICJub3RpY2Vib2FyZF9hcHBfaWQiICJ0Y19zaGEyNTYiICJHIiAiY250X2RlbF9tYXgiICJ0b3RhbF9hbGdvX2Vhcm5lZCIgInRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQiIDB4MDEgMHgwMyAweDA2IDB4MDUgMHgwMDAwMDAwMDAwMDAwMDAwCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICBjYWxsc3ViIF9faW5pdF9fCgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIGNhbGxzdWIgX19wdXlhX2FyYzRfcm91dGVyX18KICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuX19pbml0X18oKSAtPiB2b2lkOgpfX2luaXRfXzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzQ0CiAgICAvLyBkZWYgX19pbml0X18oc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNDgKICAgIC8vIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkID0gVUludDY0KDApCiAgICBieXRlYyAxNCAvLyAibm90aWNlYm9hcmRfYXBwX2lkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM1MAogICAgLy8gc2VsZi50Y19zaGEyNTYgPSBTaGEyNTYuZnJvbV9ieXRlcyhvcC5iemVybygzMikpCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBiemVybwogICAgYnl0ZWMgMTUgLy8gInRjX3NoYTI1NiIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNTMKICAgIC8vIFZhbGlkYXRvclRlcm1zVGltaW5nLmZyb21fYnl0ZXMob3AuYnplcm8oNDApKSwKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGJ6ZXJvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM1NAogICAgLy8ga2V5PSJUIiwKICAgIGJ5dGVjIDYgLy8gIlQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM1Mi0zNTUKICAgIC8vIHNlbGYudGVybXNfdGltZSA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFZhbGlkYXRvclRlcm1zVGltaW5nLmZyb21fYnl0ZXMob3AuYnplcm8oNDApKSwKICAgIC8vICAgICBrZXk9IlQiLAogICAgLy8gKQogICAgZGlnIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM1OAogICAgLy8ga2V5PSJQIiwKICAgIGJ5dGVjIDcgLy8gIlAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM1Ni0zNTkKICAgIC8vIHNlbGYudGVybXNfcHJpY2UgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBWYWxpZGF0b3JUZXJtc1ByaWNpbmcuZnJvbV9ieXRlcyhvcC5iemVybyg0MCkpLAogICAgLy8gICAgIGtleT0iUCIsCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNjEKICAgIC8vIFZhbGlkYXRvclRlcm1zU3Rha2VMaW1pdHMuZnJvbV9ieXRlcyhvcC5iemVybygxNikpLAogICAgcHVzaGludCAxNiAvLyAxNgogICAgYnplcm8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzYyCiAgICAvLyBrZXk9IlMiLAogICAgYnl0ZWMgOSAvLyAiUyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzYwLTM2MwogICAgLy8gc2VsZi50ZXJtc19zdGFrZSA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFZhbGlkYXRvclRlcm1zU3Rha2VMaW1pdHMuZnJvbV9ieXRlcyhvcC5iemVybygxNikpLAogICAgLy8gICAgIGtleT0iUyIsCiAgICAvLyApCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzY2CiAgICAvLyBrZXk9IkciLAogICAgYnl0ZWMgMTYgLy8gIkciCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM2NC0zNjcKICAgIC8vIHNlbGYudGVybXNfcmVxcyA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIFZhbGlkYXRvclRlcm1zR2F0aW5nLmZyb21fYnl0ZXMob3AuYnplcm8oMzIpKSwKICAgIC8vICAgICBrZXk9IkciLAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNzAKICAgIC8vIGtleT0iVyIsCiAgICBieXRlYyAxMCAvLyAiVyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MzY4LTM3MQogICAgLy8gc2VsZi50ZXJtc193YXJuID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgVmFsaWRhdG9yVGVybXNXYXJuaW5ncy5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDE2KSksCiAgICAvLyAgICAga2V5PSJXIiwKICAgIC8vICkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM3MwogICAgLy8gc2VsZi52YWxfb3duZXIgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM3NAogICAgLy8gc2VsZi52YWxfbWFuYWdlciA9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJ5dGVjIDExIC8vICJ2YWxfbWFuYWdlciIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzc3CiAgICAvLyBWYWxpZGF0b3JTZWxmRGlzY2xvc3VyZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDEyMCkpLAogICAgcHVzaGludCAxMjAgLy8gMTIwCiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozNzgKICAgIC8vIGtleT0iViIsCiAgICBwdXNoYnl0ZXMgIlYiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM3Ni0zODAKICAgIC8vIHNlbGYudmFsX2luZm8gPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBWYWxpZGF0b3JTZWxmRGlzY2xvc3VyZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDEyMCkpLAogICAgLy8gICAgIGtleT0iViIsCiAgICAvLyAgICAgZGVzY3JpcHRpb249IlNlbGYtZGlzY2xvc2VkIGluZm9ybWF0aW9uIGFib3V0IHZhbGlkYXRvci4iCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozODIKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9OT05FKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzg0CiAgICAvLyBzZWxmLmNudF9kZWwgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDQgLy8gImNudF9kZWwiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzg1CiAgICAvLyBzZWxmLmNudF9kZWxfbWF4ID0gVUludDY0KDApCiAgICBieXRlYyAxNyAvLyAiY250X2RlbF9tYXgiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzg3CiAgICAvLyBzZWxmLmRlbF9hcHBfbGlzdCA9IERlbEFwcExpc3QuZnJvbV9ieXRlcyhvcC5iemVybyg4ICogTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKSkKICAgIHB1c2hpbnQgMTEyIC8vIDExMgogICAgYnplcm8KICAgIGJ5dGVjIDUgLy8gImRlbF9hcHBfbGlzdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM4OQogICAgLy8gc2VsZi50b3RhbF9hbGdvX2Vhcm5lZCA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTggLy8gInRvdGFsX2FsZ29fZWFybmVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjM5MAogICAgLy8gc2VsZi50b3RhbF9hbGdvX2ZlZXNfZ2VuZXJhdGVkID0gVUludDY0KDApCiAgICBieXRlYyAxOSAvLyAidG90YWxfYWxnb19mZWVzX2dlbmVyYXRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozOTIKICAgIC8vIHNlbGYuY250X2FzYSA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgOCAvLyAiY250X2FzYSIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5fX3B1eWFfYXJjNF9yb3V0ZXJfXygpIC0+IHVpbnQ2NDoKX19wdXlhX2FyYzRfcm91dGVyX186CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHByb3RvIDAgMQogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FmdGVyX2lmX2Vsc2VAMzEKICAgIHB1c2hieXRlc3MgMHg3MzRlY2Q3NyAweDkzZjA0ZmU2IDB4ODAzOWUzMjQgMHhhNjkzZGUwMiAweGVmNDIzNTUxIDB4YWQwMzZkZTUgMHg4YmIwN2I1ZiAweDMwYTM4NjU5IDB4ZTBhNGI3MjMgMHg5ZDY0YzZlOSAweGRiZTE2MDVmIDB4ODcxMWE3NDMgMHg4MDBmZDJhMSAweGUwMzQwMmVkIDB4NGRkMDliMjYgMHgzOTkwOGRlOSAweDQ5ZGZlZTFhIDB4ZjliNjhlMzIgMHhmODExZmNiNyAweGFjZTAzNjMxIDB4NDU4Y2NiMGMgMHhjNjhkMmRiNSAweDBiZjdkODU1IDB4MTY5MzYxYjkgMHgzMTcyY2E5ZCAweDIyNjgwODYzIC8vIG1ldGhvZCAiYWRfY3JlYXRlKGFkZHJlc3MpdWludDY0IiwgbWV0aG9kICJhZF9jb25maWcoYWRkcmVzcyxhZGRyZXNzLGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgImFkX2RlbGV0ZShhZGRyZXNzKXZvaWQiLCBtZXRob2QgImFkX3JlYWR5KGFkZHJlc3MsYm9vbCl2b2lkIiwgbWV0aG9kICJhZF9zZWxmX2Rpc2Nsb3NlKGFkZHJlc3MsKGJ5dGVbMzBdLGJ5dGVbNjBdLGJ5dGVbMl0sdWludDY0LGJ5dGVbMjBdKSl2b2lkIiwgbWV0aG9kICJhZF90ZXJtcyhhZGRyZXNzLGJ5dGVbMzJdLCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSwodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksKHVpbnQ2NCx1aW50NjQpLCgodWludDY0LHVpbnQ2NClbMl0pLCh1aW50NjQsdWludDY0KSxwYXkpdm9pZCIsIG1ldGhvZCAiYWRfaW5jb21lKGFkZHJlc3MsdWludDY0KXVpbnQ2NCIsIG1ldGhvZCAiYWRfYXNhX2Nsb3NlKGFkZHJlc3MsdWludDY0KXZvaWQiLCBtZXRob2QgInRlbXBsYXRlX2xvYWRfaW5pdChhZGRyZXNzLHVpbnQ2NCxwYXkpdm9pZCIsIG1ldGhvZCAidGVtcGxhdGVfbG9hZF9kYXRhKGFkZHJlc3MsdWludDY0LGJ5dGVbXSl2b2lkIiwgbWV0aG9kICJ0ZW1wbGF0ZV9sb2FkX2VuZChhZGRyZXNzKXZvaWQiLCBtZXRob2QgImNvbnRyYWN0X2NyZWF0ZShhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxwYXksdHhuKXVpbnQ2NCIsIG1ldGhvZCAia2V5c19jb25maXJtKGFkZHJlc3MsYXBwbGljYXRpb24pdm9pZCIsIG1ldGhvZCAia2V5c19ub3RfY29uZmlybWVkKGFwcGxpY2F0aW9uKShhZGRyZXNzLGJ5dGVbMTAwXSkiLCBtZXRob2QgImtleXNfbm90X3N1Ym1pdHRlZChhcHBsaWNhdGlvbikoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJrZXlzX3N1Ym1pdChhZGRyZXNzLGFwcGxpY2F0aW9uLCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSkoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJicmVhY2hfbGltaXRzKGFwcGxpY2F0aW9uKShib29sLCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJicmVhY2hfcGF5KGFwcGxpY2F0aW9uKShhZGRyZXNzLGJ5dGVbMTAwXSkiLCBtZXRob2QgImJyZWFjaF9zdXNwZW5kZWQoYXBwbGljYXRpb24pKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJjb250cmFjdF9jbGFpbShhcHBsaWNhdGlvbikodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJjb250cmFjdF9leHBpcmVkKGFwcGxpY2F0aW9uKShhZGRyZXNzLGJ5dGVbMTAwXSkiLCBtZXRob2QgImNvbnRyYWN0X3dpdGhkcmF3KGFkZHJlc3MsYXBwbGljYXRpb24pdm9pZCIsIG1ldGhvZCAiY29udHJhY3RfZGVsZXRlKGFkZHJlc3MsYXBwbGljYXRpb24pKHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24odWludDY0LHVpbnQ2NCxhcHBsaWNhdGlvbikoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJnYXMoKXZvaWQiLCBtZXRob2QgImdldF92YWxpZGF0b3JfYXNhKHVpbnQ2NCkodWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZF9jcmVhdGVfcm91dGVAMiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZF9jb25maWdfcm91dGVAMyBfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZF9kZWxldGVfcm91dGVANCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZF9yZWFkeV9yb3V0ZUA1IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX3NlbGZfZGlzY2xvc2Vfcm91dGVANiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZF90ZXJtc19yb3V0ZUA3IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX2luY29tZV9yb3V0ZUA4IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX2FzYV9jbG9zZV9yb3V0ZUA5IF9fcHV5YV9hcmM0X3JvdXRlcl9fX3RlbXBsYXRlX2xvYWRfaW5pdF9yb3V0ZUAxMCBfX3B1eWFfYXJjNF9yb3V0ZXJfX190ZW1wbGF0ZV9sb2FkX2RhdGFfcm91dGVAMTEgX19wdXlhX2FyYzRfcm91dGVyX19fdGVtcGxhdGVfbG9hZF9lbmRfcm91dGVAMTIgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfY3JlYXRlX3JvdXRlQDEzIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfY29uZmlybV9yb3V0ZUAxNCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19rZXlzX25vdF9jb25maXJtZWRfcm91dGVAMTUgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3Rfc3VibWl0dGVkX3JvdXRlQDE2IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfc3VibWl0X3JvdXRlQDE3IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2JyZWFjaF9saW1pdHNfcm91dGVAMTggX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3BheV9yb3V0ZUAxOSBfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfc3VzcGVuZGVkX3JvdXRlQDIwIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NsYWltX3JvdXRlQDIxIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMjIgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3Rfd2l0aGRyYXdfcm91dGVAMjMgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfZGVsZXRlX3JvdXRlQDI0IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbl9yb3V0ZUAyNSBfX3B1eWFfYXJjNF9yb3V0ZXJfX19nYXNfcm91dGVAMjYgX19wdXlhX2FyYzRfcm91dGVyX19fZ2V0X3ZhbGlkYXRvcl9hc2Ffcm91dGVAMjcKICAgIGludGNfMCAvLyAwCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX2NyZWF0ZV9yb3V0ZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozOTgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTozOTgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChjcmVhdGU9InJlcXVpcmUiKQogICAgY2FsbHN1YiBhZF9jcmVhdGUKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX2NvbmZpZ19yb3V0ZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0MjkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0MjkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGFkX2NvbmZpZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYWRfZGVsZXRlX3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3NAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJEZWxldGVBcHBsaWNhdGlvbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3NAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJEZWxldGVBcHBsaWNhdGlvbiJdKQogICAgY2FsbHN1YiBhZF9kZWxldGUKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX3JlYWR5X3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUxMQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYWRfcmVhZHkKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX3NlbGZfZGlzY2xvc2Vfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTQzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBhZF9zZWxmX2Rpc2Nsb3NlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZF90ZXJtc19yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU2NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYWRfdGVybXMKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2FkX2luY29tZV9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGFkX2luY29tZQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYWRfYXNhX2Nsb3NlX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY5NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY5NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYWRfYXNhX2Nsb3NlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX190ZW1wbGF0ZV9sb2FkX2luaXRfcm91dGVAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjczNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzM2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiB0ZW1wbGF0ZV9sb2FkX2luaXQKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX3RlbXBsYXRlX2xvYWRfZGF0YV9yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Nzc2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc3NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgdGVtcGxhdGVfbG9hZF9kYXRhCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX190ZW1wbGF0ZV9sb2FkX2VuZF9yb3V0ZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODA1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiB0ZW1wbGF0ZV9sb2FkX2VuZAogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfY3JlYXRlX3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MzIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgYnRvaQogICAgdHhuIEdyb3VwSW5kZXgKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODMyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9jcmVhdGUKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfY29uZmlybV9yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAyMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAyMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIga2V5c19jb25maXJtCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19rZXlzX25vdF9jb25maXJtZWRfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNTEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfbm90X2NvbmZpcm1lZAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3Rfc3VibWl0dGVkX3JvdXRlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBrZXlzX25vdF9zdWJtaXR0ZWQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfc3VibWl0X3JvdXRlQDE3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTI5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTI5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBrZXlzX3N1Ym1pdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX2xpbWl0c19yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTE3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTE3OAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYnJlYWNoX2xpbWl0cwogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3BheV9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIyNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIyNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYnJlYWNoX3BheQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3N1c3BlbmRlZF9yb3V0ZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTI2MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTI2MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgYnJlYWNoX3N1c3BlbmRlZAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfY2xhaW1fcm91dGVAMjE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMDQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMDQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NsYWltCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF9leHBpcmVkX3JvdXRlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzQxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMS0xMDIKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBWYWxpZGF0b3JBZChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFwcGxpY2F0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzQxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9leHBpcmVkCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF93aXRoZHJhd19yb3V0ZUAyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29udHJhY3Rfd2l0aGRyYXcKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2RlbGV0ZV9yb3V0ZUAyNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQyMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hcyBBcHBsaWNhdGlvbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQyMAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29udHJhY3RfZGVsZXRlCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb25fcm91dGVAMjU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0NTkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxLTEwMgogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIFZhbGlkYXRvckFkKEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgdHhuYXMgQXBwbGljYXRpb25zCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0NTkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbgogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fZ2FzX3JvdXRlQDI2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDk4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19nZXRfdmFsaWRhdG9yX2FzYV9yb3V0ZUAyNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUwNy0xNTEwCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSBSZWFkLW9ubHkgZnVuY3Rpb25zIC0tLS0tIC0tLS0tIC0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MDctMTUxMAogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gUmVhZC1vbmx5IGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBjYWxsc3ViIGdldF92YWxpZGF0b3JfYXNhCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZnRlcl9pZl9lbHNlQDMxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDEtMTAyCiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgVmFsaWRhdG9yQWQoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5hZF9jcmVhdGUodmFsX293bmVyOiBieXRlcykgLT4gYnl0ZXM6CmFkX2NyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Mzk4LTQwMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICAvLyBkZWYgYWRfY3JlYXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX293bmVyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQxOS00MjAKICAgIC8vICMgU2V0IGdsb2JhbCB2YXJpYWJsZXMKICAgIC8vIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkID0gR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZAogICAgYnl0ZWMgMTQgLy8gIm5vdGljZWJvYXJkX2FwcF9pZCIKICAgIGdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbklECiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0MjIKICAgIC8vIHNlbGYudmFsX293bmVyID0gdmFsX293bmVyLm5hdGl2ZQogICAgYnl0ZWNfMiAvLyAidmFsX293bmVyIgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0MjQtNDI1CiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBDUkVBVEVECiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYnl0ZWMgMjAgLy8gMHgwMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDI3CiAgICAvLyByZXR1cm4gYXJjNC5VSW50NjQoR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25faWQuaWQpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYWRfY29uZmlnKHZhbF9vd25lcjogYnl0ZXMsIHZhbF9tYW5hZ2VyOiBieXRlcywgbGl2ZTogYnl0ZXMsIGNudF9kZWxfbWF4OiB1aW50NjQpIC0+IHZvaWQ6CmFkX2NvbmZpZzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDI5LTQzNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBhZF9jb25maWcoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICB2YWxfbWFuYWdlcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIGxpdmUgOiBhcmM0LkJvb2wsCiAgICAvLyAgICAgY250X2RlbF9tYXggOiBVSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA0IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDU0CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDU2CiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX0NSRUFURUQpIGFuZAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMjAgLy8gMHgwMQogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDU2LTQ1OAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9DUkVBVEVEKSBhbmQKICAgIC8vIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BRCkgYW5kCiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQURFRCkKICAgIGJ6IGFkX2NvbmZpZ19ib29sX2ZhbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDU3CiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpIGFuZAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTIgLy8gMHgwMgogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDU2LTQ1OAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9DUkVBVEVEKSBhbmQKICAgIC8vIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BRCkgYW5kCiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQURFRCkKICAgIGJ6IGFkX2NvbmZpZ19ib29sX2ZhbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDU4CiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQURFRCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDIxIC8vIDB4MDMKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ1Ni00NTgKICAgIC8vIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCkgYW5kCiAgICAvLyBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpIGFuZAogICAgLy8gc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FERUQpCiAgICBieiBhZF9jb25maWdfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQogICAgYiBhZF9jb25maWdfYm9vbF9tZXJnZUA1CgphZF9jb25maWdfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKCmFkX2NvbmZpZ19ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ1NS00NTkKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgc2VsZi5zdGF0ZSAhPSBCeXRlcyhTVEFURV9DUkVBVEVEKSBhbmQKICAgIC8vICAgICBzZWxmLnN0YXRlICE9IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpIGFuZAogICAgLy8gICAgIHNlbGYuc3RhdGUgIT0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BREVEKQogICAgLy8gKSwgRVJST1JfQ0FMTEVEX0ZST01fU1RBVEVfQ1JFQVRFRF9URU1QTEFURV9MT0FEX09SX1RFTVBMQVRFX0xPQURFRAogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBzdGF0ZSBDUkVBVEVELCBURU1QTEFURV9MT0FEIG9yIFRFTVBMQVRFX0xPQURFRC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDYwCiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC00CiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ2MgogICAgLy8gc2VsZi52YWxfbWFuYWdlciA9IHZhbF9tYW5hZ2VyLm5hdGl2ZQogICAgYnl0ZWMgMTEgLy8gInZhbF9tYW5hZ2VyIgogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0NjQKICAgIC8vIGFzc2VydCBjbnRfZGVsX21heCA8PSBVSW50NjQoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKSwgRVJST1JfTk9fTUVNT1JZX0ZPUl9NT1JFX0RFTEVHQVRPUlMgICMgbm9xYTogRTUwMQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDE0IC8vIDE0CiAgICA8PQogICAgYXNzZXJ0IC8vIFZhbGlkYXRvciBhZCBkb2VzIG5vdCBoYXZlIGVub3VnaCBtZW1vcnkgdG8gc3RvcmUgdGhhdCBtYW55IGFjdGl2ZSBkZWxlZ2F0b3JzLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0NjUKICAgIC8vIHNlbGYuY250X2RlbF9tYXggPSBjbnRfZGVsX21heAogICAgYnl0ZWMgMTcgLy8gImNudF9kZWxfbWF4IgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0NjcKICAgIC8vIGlmIGxpdmUubmF0aXZlOgogICAgZnJhbWVfZGlnIC0yCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieiBhZF9jb25maWdfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDY4CiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAyMiAvLyAweDA2CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgYiBhZF9jb25maWdfYWZ0ZXJfaWZfZWxzZUA4CgphZF9jb25maWdfZWxzZV9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3MAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX05PVF9MSVZFKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwNwogICAgYXBwX2dsb2JhbF9wdXQKCmFkX2NvbmZpZ19hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3MgogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFkX2RlbGV0ZSh2YWxfb3duZXI6IGJ5dGVzKSAtPiB2b2lkOgphZF9kZWxldGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ3NC00NzgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiBhZF9kZWxldGUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0OTAKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0OTEKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDkzCiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfZGVsID09IFVJbnQ2NCgwKSwgRVJST1JfREVMRVRFX0FDVElWRV9ERUxFR0FUT1JTCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiY250X2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIENhbm5vdCBkZWxldGUgdmFsaWRhdG9yIGFkIGlmIHRoZXJlIGFyZSBhY3RpdmUgZGVsZWdhdG9ycy4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDk0CiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfYXNhID09IFVJbnQ2NCgwKSwgRVJST1JfREVMRVRFX0FTQV9SRU1BSU4KICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJjbnRfYXNhIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNudF9hc2EgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gQ2Fubm90IGRlbGV0ZSB2YWxpZGF0b3IgaWYgdGhlcmUgYXJlIEFTQXMgdGhhdCByZW1haW4uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjQ5NgogICAgLy8gYXNzZXJ0IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZS1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlID09IFVJbnQ2NCgwKSwgXAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgICEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NDk2LTQ5NwogICAgLy8gYXNzZXJ0IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZS1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlID09IFVJbnQ2NCgwKSwgXAogICAgLy8gICAgIEVSUk9SX0FMR09fQVZBSUxBQkxFX0JBTEFOQ0VfTk9UX1pFUk8KICAgIGFzc2VydCAvLyBBbGdvcmFuZCBiYWxhbmNlIGlzIG5vdCB6ZXJvLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo0OTkKICAgIC8vIGFzc2VydCBzZWxmLnRlbXBsYXRlLmRlbGV0ZSgpLCBFUlJPUl9ERUxFVEVfVEVNUExBVEVfQk9YICMgU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byByYWlzZSB0aGUgZXJyb3IgaWYgY29kZSBvawogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBib3hfZGVsCiAgICBhc3NlcnQgLy8gQ2Fubm90IGRlbGV0ZSBib3ggd2l0aCBzbWFydCBjb250cmFjdCB0ZW1wbGF0ZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTAxLTUwMgogICAgLy8gIyBDbG9zZSBhY2NvdW50IHRvIG93bmVyIHRvIHJldHVybiB0aGUgTUJSCiAgICAvLyByY3YgPSBzZWxmLnZhbF9vd25lcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUwMy01MDcKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1yY3YsCiAgICAvLyAgICAgYW1vdW50PTAsCiAgICAvLyAgICAgY2xvc2VfcmVtYWluZGVyX3RvPXJjdiwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGR1cAogICAgaXR4bl9maWVsZCBDbG9zZVJlbWFpbmRlclRvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUwNQogICAgLy8gYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTAzCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTAzLTUwNwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXJjdiwKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89cmN2LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTA5CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYWRfcmVhZHkodmFsX21hbmFnZXI6IGJ5dGVzLCByZWFkeTogYnl0ZXMpIC0+IHZvaWQ6CmFkX3JlYWR5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MTEtNTE2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGFkX3JlYWR5KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICByZWFkeTogYXJjNC5Cb29sLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUyOAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUzMAogICAgLy8gc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSkgb3IKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDIzIC8vIDB4MDUKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUzMC01MzEKICAgIC8vIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfUkVBRFkpIG9yCiAgICAvLyBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX05PVF9SRUFEWSkKICAgIGJueiBhZF9yZWFkeV9ib29sX3RydWVAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MzEKICAgIC8vIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMjIgLy8gMHgwNgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTMwLTUzMQogICAgLy8gc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSkgb3IKICAgIC8vIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgYnogYWRfcmVhZHlfYm9vbF9mYWxzZUAzCgphZF9yZWFkeV9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCiAgICBiIGFkX3JlYWR5X2Jvb2xfbWVyZ2VANAoKYWRfcmVhZHlfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKCmFkX3JlYWR5X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTI5LTUzMgogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1JFQURZKSBvcgogICAgLy8gICAgIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTk9UX1JFQURZKQogICAgLy8gKSwgRVJST1JfTk9UX1NUQVRFX1JFQURZX09SX05PVF9SRUFEWQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIFJFQURZIG9yIE5PVF9SRUFEWS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTM0CiAgICAvLyBhc3NlcnQgdmFsX21hbmFnZXIubmF0aXZlID09IHNlbGYudmFsX21hbmFnZXIsIEVSUk9SX0NBTExFRF9CWV9OT1RfVkFMX01BTkFHRVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAidmFsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBtYW5hZ2VyLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1MzYKICAgIC8vIGlmIHJlYWR5Lm5hdGl2ZToKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnogYWRfcmVhZHlfZWxzZV9ib2R5QDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTM3CiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfUkVBRFkpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGJ5dGVjIDIzIC8vIDB4MDUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBiIGFkX3JlYWR5X2FmdGVyX2lmX2Vsc2VANwoKYWRfcmVhZHlfZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjUzOQogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX05PVF9SRUFEWSkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYnl0ZWMgMjIgLy8gMHgwNgogICAgYXBwX2dsb2JhbF9wdXQKCmFkX3JlYWR5X2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTQxCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYWRfc2VsZl9kaXNjbG9zZSh2YWxfb3duZXI6IGJ5dGVzLCB2YWxfaW5mbzogYnl0ZXMpIC0+IHZvaWQ6CmFkX3NlbGZfZGlzY2xvc2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU0My01NDgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYWRfc2VsZl9kaXNjbG9zZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9vd25lcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHZhbF9pbmZvOiBWYWxpZGF0b3JTZWxmRGlzY2xvc3VyZSwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NjAKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo1NjEKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NTYzCiAgICAvLyBzZWxmLnZhbF9pbmZvLnZhbHVlID0gdmFsX2luZm8uY29weSgpCiAgICBwdXNoYnl0ZXMgIlYiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU2NQogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFkX3Rlcm1zKHZhbF9vd25lcjogYnl0ZXMsIHRjX3NoYTI1NjogYnl0ZXMsIHRlcm1zX3RpbWU6IGJ5dGVzLCB0ZXJtc19wcmljZTogYnl0ZXMsIHRlcm1zX3N0YWtlOiBieXRlcywgdGVybXNfcmVxczogYnl0ZXMsIHRlcm1zX3dhcm46IGJ5dGVzLCB0eG46IHVpbnQ2NCkgLT4gdm9pZDoKYWRfdGVybXM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjU2Ny01NzgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYWRfdGVybXMoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICB0Y19zaGEyNTY6IFNoYTI1NiwKICAgIC8vICAgICB0ZXJtc190aW1lOiBWYWxpZGF0b3JUZXJtc1RpbWluZywKICAgIC8vICAgICB0ZXJtc19wcmljZTogVmFsaWRhdG9yVGVybXNQcmljaW5nLAogICAgLy8gICAgIHRlcm1zX3N0YWtlOiBWYWxpZGF0b3JUZXJtc1N0YWtlTGltaXRzLAogICAgLy8gICAgIHRlcm1zX3JlcXM6IFZhbGlkYXRvclRlcm1zR2F0aW5nLAogICAgLy8gICAgIHRlcm1zX3dhcm46IFZhbGlkYXRvclRlcm1zV2FybmluZ3MsCiAgICAvLyAgICAgdHhuOiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDggMAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjAzCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjA0CiAgICAvLyBhc3NlcnQgdmFsX293bmVyLm5hdGl2ZSA9PSBzZWxmLnZhbF9vd25lciwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfT1dORVIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWxfb3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsX293bmVyIGV4aXN0cwogICAgZnJhbWVfZGlnIC04CiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYwNgogICAgLy8gbWJyX2N1ciA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MDgtNjA5CiAgICAvLyAjIFNhbml0eSBjaGVja3Mgb24gaW5wdXQgdGVybXMKICAgIC8vIGFzc2VydCB0ZXJtc190aW1lLnJvdW5kc19zZXR1cC5uYXRpdmUgKyB0ZXJtc190aW1lLnJvdW5kc19jb25maXJtLm5hdGl2ZSA8IHRlcm1zX3RpbWUucm91bmRzX2R1cmF0aW9uX21pbiwgXAogICAgZnJhbWVfZGlnIC02CiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTYKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfZGlnIC02CiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgICsKICAgIGl0b2IKICAgIGRpZyAxCiAgICBiPAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MDgtNjEwCiAgICAvLyAjIFNhbml0eSBjaGVja3Mgb24gaW5wdXQgdGVybXMKICAgIC8vIGFzc2VydCB0ZXJtc190aW1lLnJvdW5kc19zZXR1cC5uYXRpdmUgKyB0ZXJtc190aW1lLnJvdW5kc19jb25maXJtLm5hdGl2ZSA8IHRlcm1zX3RpbWUucm91bmRzX2R1cmF0aW9uX21pbiwgXAogICAgLy8gICAgIEVSUk9SX1RFUk1TX01JTl9EVVJBVElPTl9TRVRVUF9DT05GSVJNCiAgICBhc3NlcnQgLy8gTWluaW11bSBkZWxlZ2F0aW9uIGR1cmF0aW9uIG11c3QgYmUgbG9uZ2VyIHRoZSBzdW0gb2Ygc2V0dXAgYW5kIGNvbmZpcm1hdGlvbiByb3VuZHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYxMQogICAgLy8gYXNzZXJ0IHRlcm1zX3RpbWUucm91bmRzX2R1cmF0aW9uX21pbiA8PSB0ZXJtc190aW1lLnJvdW5kc19kdXJhdGlvbl9tYXgsIFwKICAgIGZyYW1lX2RpZyAtNgogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYjw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYxMS02MTIKICAgIC8vIGFzc2VydCB0ZXJtc190aW1lLnJvdW5kc19kdXJhdGlvbl9taW4gPD0gdGVybXNfdGltZS5yb3VuZHNfZHVyYXRpb25fbWF4LCBcCiAgICAvLyAgICAgRVJST1JfVEVSTV9EVVJBVElPTl9NSU5fTEFSR0VSX1RIQU5fTUFYCiAgICBhc3NlcnQgLy8gTWluaW11bSBkZWxlZ2F0aW9uIGR1cmF0aW9uIGNhbm5vdCBiZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGR1cmF0aW9uLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MTMKICAgIC8vIGFzc2VydCB0ZXJtc19zdGFrZS5zdGFrZV9ncmF0aXMgPD0gVUludDY0KFNUQUtFX0dSQVRJU19NQVgpLCBFUlJPUl9URVJNX0dSQVRJU19NQVgKICAgIGZyYW1lX2RpZyAtNAogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzMgLy8gMTAwMDAwMAogICAgaXRvYgogICAgYjw9CiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGFkIGdyYXRpcyBzdGFrZSBhbW91bnQgbXVzdCBiZSBhdCBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBtYXhpbXVtIHBvc3NpYmxlLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MTQKICAgIC8vIGFzc2VydCB0ZXJtc190aW1lLnJvdW5kX21heF9lbmQgPiBHbG9iYWwucm91bmQsIEVSUk9SX0FEX0VORF9JU19JTl9QQVNUCiAgICBmcmFtZV9kaWcgLTYKICAgIGV4dHJhY3QgMzIgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGdsb2JhbCBSb3VuZAogICAgaXRvYgogICAgYj4KICAgIGFzc2VydCAvLyBWYWxpZGF0b3IgYWQgZW5kIHRpbWUgZGVmaW5lZCBpcyBpbiB0aGUgcGFzdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjE2CiAgICAvLyBzZWxmLnRjX3NoYTI1NiA9IHRjX3NoYTI1Ni5jb3B5KCkKICAgIGJ5dGVjIDE1IC8vICJ0Y19zaGEyNTYiCiAgICBmcmFtZV9kaWcgLTcKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYxNwogICAgLy8gc2VsZi50ZXJtc190aW1lLnZhbHVlID0gdGVybXNfdGltZS5jb3B5KCkKICAgIGJ5dGVjIDYgLy8gIlQiCiAgICBmcmFtZV9kaWcgLTYKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYxOAogICAgLy8gc2VsZi50ZXJtc19wcmljZS52YWx1ZSA9IHRlcm1zX3ByaWNlLmNvcHkoKQogICAgYnl0ZWMgNyAvLyAiUCIKICAgIGZyYW1lX2RpZyAtNQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjE5CiAgICAvLyBzZWxmLnRlcm1zX3N0YWtlLnZhbHVlID0gdGVybXNfc3Rha2UuY29weSgpCiAgICBieXRlYyA5IC8vICJTIgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MjAKICAgIC8vIHNlbGYudGVybXNfcmVxcy52YWx1ZSA9IHRlcm1zX3JlcXMuY29weSgpCiAgICBieXRlYyAxNiAvLyAiRyIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjIxCiAgICAvLyBzZWxmLnRlcm1zX3dhcm4udmFsdWUgPSB0ZXJtc193YXJuLmNvcHkoKQogICAgYnl0ZWMgMTAgLy8gIlciCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYyMwogICAgLy8gYXNzZXRfaWQgPSB0ZXJtc19wcmljZS5mZWVfYXNzZXRfaWQubmF0aXZlCiAgICBmcmFtZV9kaWcgLTUKICAgIGV4dHJhY3QgMzIgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MjQKICAgIC8vIGlmIGFzc2V0X2lkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBieiBhZF90ZXJtc19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjI2CiAgICAvLyBpZiBhc3NldCBub3QgaW4gc2VsZi5hc2FzOgogICAgZnJhbWVfZGlnIDIKICAgIGl0b2IKICAgIGJ5dGVjIDEzIC8vIDB4NjE3MzYxNWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGFkX3Rlcm1zX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MjctNjMyCiAgICAvLyAjIE9wdCBpbiB0byB0aGUgYXNzZXQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYzMAogICAgLy8gYXNzZXRfcmVjZWl2ZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjYzMQogICAgLy8gYXNzZXRfYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjI3LTYyOAogICAgLy8gIyBPcHQgaW4gdG8gdGhlIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MjctNjMyCiAgICAvLyAjIE9wdCBpbiB0byB0aGUgYXNzZXQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2MzQtNjM4CiAgICAvLyAjIENyZWF0ZSB0aGUgZW50cnkKICAgIC8vIHNlbGYuYXNhc1thc3NldF0gPSBWYWxpZGF0b3JBU0EoCiAgICAvLyAgICAgdG90YWxfZWFybmluZz1hcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICB0b3RhbF9mZWVzX2dlbmVyYXRlZD1hcmM0LlVJbnQ2NCgwKSwKICAgIC8vICkKICAgIGZyYW1lX2RpZyAwCiAgICBwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NDAKICAgIC8vIHNlbGYuY250X2FzYSArPSAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOCAvLyAiY250X2FzYSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfYXNhIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjIDggLy8gImNudF9hc2EiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAoKYWRfdGVybXNfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NDItNjQzCiAgICAvLyAjIENoZWNrIGlmIHBheW1lbnQgZm9yIGluY3JlYXNlIG9mIE1CUiB3YXMgbWFkZQogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBFUlJPUl9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NDQKICAgIC8vIG1icl9uZXcgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjQ1CiAgICAvLyBtYnJfcGF5X2Ftb3VudCA9IG1icl9uZXcgLSBtYnJfY3VyCiAgICBmcmFtZV9kaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NDYKICAgIC8vIGFzc2VydCB0eG4uYW1vdW50ID09IG1icl9wYXlfYW1vdW50LCBFUlJPUl9BRF9URVJNU19NQlIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBwYXltZW50IGZvciBNQlIgaW5jcmVhc2Ugb2YgdmFsaWRhdG9yIGFkIGR1ZSB0byBuZXcgdGVybXMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY0OQogICAgLy8gaWYgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FERUQpOgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMjEgLy8gMHgwMwogICAgPT0KICAgIGJ6IGFkX3Rlcm1zX2FmdGVyX2lmX2Vsc2VANwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NTAKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9TRVQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIHB1c2hieXRlcyAweDA0CiAgICBhcHBfZ2xvYmFsX3B1dAoKYWRfdGVybXNfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NTIKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5hZF9pbmNvbWUodmFsX293bmVyOiBieXRlcywgYXNzZXRfaWQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CmFkX2luY29tZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjU0LTY1OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBhZF9pbmNvbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWxfb3duZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBhc3NldF9pZDogVUludDY0LAogICAgLy8gKSAtPiBhcmM0LlVJbnQ2NDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NzcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2NzgKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjgxCiAgICAvLyBpZiBhc3NldC5pZCAhPSBVSW50NjQoQUxHT19BU0FfSUQpOgogICAgZnJhbWVfZGlnIC0xCiAgICBieiBhZF9pbmNvbWVfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjgyCiAgICAvLyBiYWwgPSBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY4My02ODcKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWJhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY4MwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgcHVzaGludCA0IC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjgzLTY4NwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9dmFsX293bmVyLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9YmFsLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgYWRfaW5jb21lX2FmdGVyX2lmX2Vsc2VANQoKYWRfaW5jb21lX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2ODkKICAgIC8vIGJhbCA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZSAtIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAtCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjkwLTY5MwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyAgICAgYW1vdW50PWJhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjkwCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NjkwLTY5MwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyAgICAgYW1vdW50PWJhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgphZF9pbmNvbWVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo2OTUKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChiYWwpCiAgICBpdG9iCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmFkX2FzYV9jbG9zZSh2YWxfb3duZXI6IGJ5dGVzLCBhc3NldF9pZDogdWludDY0KSAtPiB2b2lkOgphZF9hc2FfY2xvc2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjY5Ny03MDIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYWRfYXNhX2Nsb3NlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgdmFsX293bmVyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfaWQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MTUKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MTYKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzE4CiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfZGVsID09IFVJbnQ2NCgwKSwgRVJST1JfQ0FOTk9UX1JFTU9WRV9BU0FfV0lUSF9BQ1RJVkVfREVMRUdBVE9SUwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gImNudF9kZWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X2RlbCBleGlzdHMKICAgICEKICAgIGFzc2VydCAvLyBDYW5ub3QgcmVtb3ZlIEFTQSB3aGlsZSB0aGVyZSBhcmUgYWN0aXZlIGRlbGVnYXRvcnMgYmVjYXVzZSBvbmUgY291bGQgYmUgc3RpbGwgdXNpbmcgaXQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcyMS03MjIKICAgIC8vICMgQ2hlY2sgaWYgQVNBIGlzIGV2ZW4gc3RvcmVkIG9uIHRoZSBWYWxpZGF0b3JBZC4gVGhpcyBpbmhlcmVudGx5IGZhaWxzIGZvciBBTEdPLCB3aGljaCBpcyBzdG9yZWQgc2VwYXJhdGVseS4KICAgIC8vIGFzc2VydCBhc3NldCBpbiBzZWxmLmFzYXMsIEVSUk9SX0FTQV9OT1RfU1RPUkVEX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBieXRlYyAxMyAvLyAweDYxNzM2MTVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQVNBIGlzIG5vdCBzdG9yZWQgYXQgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MjQKICAgIC8vIGFzc2VydCBvcC5Cb3guZGVsZXRlKEJ5dGVzKEJPWF9BU0FfS0VZX1BSRUZJWCkgKyBvcC5pdG9iKGFzc2V0X2lkKSksIEVSUk9SX0FTQV9CT1hfTk9UX0RFTEVURUQKICAgIGJveF9kZWwKICAgIGFzc2VydCAvLyBGYWlsZWQgdG8gZGVsZXRlIEFTQSBib3guCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcyNQogICAgLy8gc2VsZi5jbnRfYXNhIC09IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJjbnRfYXNhIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNudF9hc2EgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgYnl0ZWMgOCAvLyAiY250X2FzYSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcyNy03MzIKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTAsCiAgICAvLyAgICAgYXNzZXRfY2xvc2VfdG89dmFsX293bmVyLm5hdGl2ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBc3NldENsb3NlVG8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzMwCiAgICAvLyBhc3NldF9hbW91bnQ9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MjcKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjcyNy03MzIKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXZhbF9vd25lci5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTAsCiAgICAvLyAgICAgYXNzZXRfY2xvc2VfdG89dmFsX293bmVyLm5hdGl2ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjczNAogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLnRlbXBsYXRlX2xvYWRfaW5pdCh2YWxfb3duZXI6IGJ5dGVzLCB0ZW1wbGF0ZV9zaXplOiB1aW50NjQsIG1icl90eG46IHVpbnQ2NCkgLT4gdm9pZDoKdGVtcGxhdGVfbG9hZF9pbml0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3MzYtNzQyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIHRlbXBsYXRlX2xvYWRfaW5pdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9vd25lcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHRlbXBsYXRlX3NpemU6IFVJbnQ2NCwKICAgIC8vICAgICBtYnJfdHhuOiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDMgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NTcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NTgKICAgIC8vIGFzc2VydCB2YWxfb3duZXIubmF0aXZlID09IHNlbGYudmFsX293bmVyLCBFUlJPUl9DQUxMRURfQllfTk9UX1ZBTF9PV05FUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfb3duZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTMKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvciBvd25lci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzYwCiAgICAvLyBtYnJfY3VyID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc2MgogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCksIEVSUk9SX05PVF9TVEFURV9DUkVBVEVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAyMCAvLyAweDAxCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIENSRUFURUQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc2NAogICAgLy8gYXNzZXJ0IHNlbGYudGVtcGxhdGUuY3JlYXRlKHNpemU9dGVtcGxhdGVfc2l6ZSkKICAgIGJ5dGVjXzMgLy8gMHg2NAogICAgZnJhbWVfZGlnIC0yCiAgICBib3hfY3JlYXRlCiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzY2CiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfVEVNUExBVEVfTE9BRCkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYnl0ZWMgMTIgLy8gMHgwMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzY4LTc2OQogICAgLy8gIyBDaGVjayBpZiB0aGUgaW5wdXQgTUJSIHBheW1lbnQgdHJhbnNhY3Rpb24gd2FzIHN1ZmZpY2llbnQgZm9yIGluY3JlYXNlIHZhbGlkYXRvciBhZCdzIE1CUgogICAgLy8gbWJyX25ldyA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NzAKICAgIC8vIGFtdCA9IChtYnJfbmV3IC0gbWJyX2N1cikKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6NzcxCiAgICAvLyBhc3NlcnQgbWJyX3R4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBFUlJPUl9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NzIKICAgIC8vIGFzc2VydCBtYnJfdHhuLmFtb3VudCA9PSBhbXQsIEVSUk9SX0FNT1VOVAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgID09CiAgICBhc3NlcnQgLy8gU2VudCBhbW91bnQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6Nzc0CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQudGVtcGxhdGVfbG9hZF9kYXRhKHZhbF9vd25lcjogYnl0ZXMsIG9mZnNldDogdWludDY0LCBkYXRhOiBieXRlcykgLT4gdm9pZDoKdGVtcGxhdGVfbG9hZF9kYXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3NzYtNzgyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIHRlbXBsYXRlX2xvYWRfZGF0YSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9vd25lcjogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIG9mZnNldDogVUludDY0LAogICAgLy8gICAgIGRhdGE6IEJ5dGVzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc5NgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojc5NwogICAgLy8gYXNzZXJ0IHZhbF9vd25lci5uYXRpdmUgPT0gc2VsZi52YWxfb3duZXIsIEVSUk9SX0NBTExFRF9CWV9OT1RfVkFMX09XTkVSCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidmFsX293bmVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbF9vd25lciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG93bmVyLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo3OTkKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpLCBFUlJPUl9OT1RfU1RBVEVfVEVNUExBVEVfTE9BRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTIgLy8gMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBURU1QTEFURV9MT0FELgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MDEKICAgIC8vIHNlbGYudGVtcGxhdGUucmVwbGFjZShvZmZzZXQsIGRhdGEpCiAgICBieXRlY18zIC8vIDB4NjQKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MDMKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC50ZW1wbGF0ZV9sb2FkX2VuZCh2YWxfb3duZXI6IGJ5dGVzKSAtPiB2b2lkOgp0ZW1wbGF0ZV9sb2FkX2VuZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODA1LTgwOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiB0ZW1wbGF0ZV9sb2FkX2VuZCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9vd25lcjogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjgxOQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjgyMAogICAgLy8gYXNzZXJ0IHZhbF9vd25lci5uYXRpdmUgPT0gc2VsZi52YWxfb3duZXIsIEVSUk9SX0NBTExFRF9CWV9OT1RfVkFMX09XTkVSCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidmFsX293bmVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbF9vd25lciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG93bmVyLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MjIKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1RFTVBMQVRFX0xPQUQpLCBFUlJPUl9OT1RfU1RBVEVfVEVNUExBVEVfTE9BRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTIgLy8gMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBURU1QTEFURV9MT0FELgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4MjQKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9URU1QTEFURV9MT0FERUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGJ5dGVjIDIxIC8vIDB4MDMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjgyNgogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X2NyZWF0ZShkZWxfbWFuYWdlcjogYnl0ZXMsIGRlbF9iZW5lZmljaWFyeTogYnl0ZXMsIHJvdW5kc19kdXJhdGlvbjogdWludDY0LCBzdGFrZV9tYXg6IHVpbnQ2NCwgcGFydG5lcl9hZGRyZXNzOiBieXRlcywgcGFydG5lcl9jb21taXNzaW9uOiB1aW50NjQsIG1icl90eG46IHVpbnQ2NCwgdHhuOiB1aW50NjQpIC0+IGJ5dGVzOgpjb250cmFjdF9jcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjgzMi04NDMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfY3JlYXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYmVuZWZpY2lhcnk6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICByb3VuZHNfZHVyYXRpb246IFVJbnQ2NCwKICAgIC8vICAgICBzdGFrZV9tYXg6IFVJbnQ2NCwKICAgIC8vICAgICBwYXJ0bmVyX2FkZHJlc3M6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBwYXJ0bmVyX2NvbW1pc3Npb246IFVJbnQ2NCwKICAgIC8vICAgICBtYnJfdHhuOiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICAgICB0eG46IGd0eG4uVHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gOCAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA0CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODc2CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODc4CiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSksIEVSUk9SX05PVF9TVEFURV9SRUFEWQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMjMgLy8gMHgwNQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBSRUFEWS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6ODgwCiAgICAvLyBtYnJfY3VyID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg4NAogICAgLy8gaWYgc2VsZi50ZW1wbGF0ZS5sZW5ndGggPiBVSW50NjQoNDA5Nik6CiAgICBieXRlY18zIC8vIDB4NjQKICAgIGJveF9sZW4KICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlbXBsYXRlIGV4aXN0cwogICAgaW50YyA0IC8vIDQwOTYKICAgID4KICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4ODYKICAgIC8vIHNlbGYudGVtcGxhdGUuZXh0cmFjdChVSW50NjQoMCksIFVJbnQ2NCg0MDk2KSksCiAgICBieXRlY18zIC8vIDB4NjQKICAgIGludGNfMCAvLyAwCiAgICBpbnRjIDQgLy8gNDA5NgogICAgYm94X2V4dHJhY3QKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4ODcKICAgIC8vIHNlbGYudGVtcGxhdGUuZXh0cmFjdChVSW50NjQoNDA5NiksIHNlbGYudGVtcGxhdGUubGVuZ3RoIC0gVUludDY0KDQwOTYpKSwKICAgIGJ5dGVjXzMgLy8gMHg2NAogICAgYm94X2xlbgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVtcGxhdGUgZXhpc3RzCiAgICBpbnRjIDQgLy8gNDA5NgogICAgLQogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBpbnRjIDQgLy8gNDA5NgogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgYiBjb250cmFjdF9jcmVhdGVfYWZ0ZXJfaWZfZWxzZUAzCgpjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg5MQogICAgLy8gc2VsZi50ZW1wbGF0ZS5leHRyYWN0KFVJbnQ2NCgwKSwgc2VsZi50ZW1wbGF0ZS5sZW5ndGgpLAogICAgYnl0ZWNfMyAvLyAweDY0CiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZW1wbGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gMHg2NAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4OTIKICAgIC8vIEJ5dGVzKCksCiAgICBwdXNoYnl0ZXMgMHgKCmNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg5NS05MDcKICAgIC8vIGRlbF9hcHBfaWQsIHR4bl9jcmVhdGUgPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2NyZWF0ZSwKICAgIC8vICAgICBkZWxfbWFuYWdlciwKICAgIC8vICAgICBkZWxfYmVuZWZpY2lhcnksCiAgICAvLyAgICAgc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQsCiAgICAvLyAgICAgYXBwcm92YWxfcHJvZ3JhbT1hcHByb3ZhbF9wcm9ncmFtLAogICAgLy8gICAgIGNsZWFyX3N0YXRlX3Byb2dyYW09Y29tcGlsZWQuY2xlYXJfc3RhdGVfcHJvZ3JhbSwKICAgIC8vICAgICBnbG9iYWxfbnVtX3VpbnQ9Y29tcGlsZWQuZ2xvYmFsX3VpbnRzLAogICAgLy8gICAgIGdsb2JhbF9udW1fYnl0ZXM9Y29tcGlsZWQuZ2xvYmFsX2J5dGVzLAogICAgLy8gICAgIGxvY2FsX251bV91aW50PWNvbXBpbGVkLmxvY2FsX3VpbnRzLAogICAgLy8gICAgIGxvY2FsX251bV9ieXRlcz1jb21waWxlZC5sb2NhbF9ieXRlcywKICAgIC8vICAgICBleHRyYV9wcm9ncmFtX3BhZ2VzPWNvbXBpbGVkLmV4dHJhX3Byb2dyYW1fcGFnZXMsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg5OQogICAgLy8gc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTQgLy8gIm5vdGljZWJvYXJkX2FwcF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojg4Mi04ODMKICAgIC8vICMgQ3JlYXRlIGEgbmV3IGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gY29tcGlsZWQgPSBjb21waWxlX2NvbnRyYWN0KERlbGVnYXRvckNvbnRyYWN0KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgRXh0cmFQcm9ncmFtUGFnZXMKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBpdHhuX2ZpZWxkIEdsb2JhbE51bUJ5dGVTbGljZQogICAgcHVzaGludCAxMiAvLyAxMgogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1VaW50CiAgICBwdXNoYnl0ZXMgYmFzZTY0KEM0RUJRdz09KQogICAgaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbVBhZ2VzCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo4OTUtOTA3CiAgICAvLyBkZWxfYXBwX2lkLCB0eG5fY3JlYXRlID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9jcmVhdGUsCiAgICAvLyAgICAgZGVsX21hbmFnZXIsCiAgICAvLyAgICAgZGVsX2JlbmVmaWNpYXJ5LAogICAgLy8gICAgIHNlbGYubm90aWNlYm9hcmRfYXBwX2lkLAogICAgLy8gICAgIGFwcHJvdmFsX3Byb2dyYW09YXBwcm92YWxfcHJvZ3JhbSwKICAgIC8vICAgICBjbGVhcl9zdGF0ZV9wcm9ncmFtPWNvbXBpbGVkLmNsZWFyX3N0YXRlX3Byb2dyYW0sCiAgICAvLyAgICAgZ2xvYmFsX251bV91aW50PWNvbXBpbGVkLmdsb2JhbF91aW50cywKICAgIC8vICAgICBnbG9iYWxfbnVtX2J5dGVzPWNvbXBpbGVkLmdsb2JhbF9ieXRlcywKICAgIC8vICAgICBsb2NhbF9udW1fdWludD1jb21waWxlZC5sb2NhbF91aW50cywKICAgIC8vICAgICBsb2NhbF9udW1fYnl0ZXM9Y29tcGlsZWQubG9jYWxfYnl0ZXMsCiAgICAvLyAgICAgZXh0cmFfcHJvZ3JhbV9wYWdlcz1jb21waWxlZC5leHRyYV9wcm9ncmFtX3BhZ2VzLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4ZDFiZWNjY2UgLy8gbWV0aG9kICJjb250cmFjdF9jcmVhdGUoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC04CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC03CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTA4CiAgICAvLyBkZWxfYXBwID0gQXBwbGljYXRpb24oZGVsX2FwcF9pZC5uYXRpdmUpCiAgICBidG9pCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MTAtOTExCiAgICAvLyAjIEZ1bmQgdGhlIGNyZWF0ZWQgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBkZWxfbWJyX2Z1bmQgPSBHbG9iYWwubWluX2JhbGFuY2UgKyBHbG9iYWwuYXNzZXRfb3B0X2luX21pbl9iYWxhbmNlCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICArCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MTItOTE1CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9ZGVsX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1kZWxfbWJyX2Z1bmQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkxMwogICAgLy8gcmVjZWl2ZXI9ZGVsX2FwcC5hZGRyZXNzLAogICAgc3dhcAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTEyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTEyLTkxNQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWRlbF9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9ZGVsX21icl9mdW5kLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTE3LTkxOAogICAgLy8gIyBTZXR1cCB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBhc3NlcnQgcm91bmRzX2R1cmF0aW9uID49IHNlbGYudGVybXNfdGltZS52YWx1ZS5yb3VuZHNfZHVyYXRpb25fbWluLCBFUlJPUl9ERUxFR0FUSU9OX1BFUklPRF9UT09fU0hPUlQKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJUIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3RpbWUgZXhpc3RzCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTYKICAgIGl0b2IKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICBzd2FwCiAgICBkaWcgMQogICAgYjw9CiAgICBhc3NlcnQgLy8gVG9vIHNob3J0IGRlbGVnYXRpb24gcGVyaW9kLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MTkKICAgIC8vIGFzc2VydCByb3VuZHNfZHVyYXRpb24gPD0gc2VsZi50ZXJtc190aW1lLnZhbHVlLnJvdW5kc19kdXJhdGlvbl9tYXgsIEVSUk9SX0RFTEVHQVRJT05fUEVSSU9EX1RPT19MT05HCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAiVCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc190aW1lIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYjw9CiAgICBhc3NlcnQgLy8gVG9vIGxvbmcgZGVsZWdhdGlvbiBwZXJpb2QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkyMAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCArIHJvdW5kc19kdXJhdGlvbiA8PSBzZWxmLnRlcm1zX3RpbWUudmFsdWUucm91bmRfbWF4X2VuZCwgRVJST1JfREVMRUdBVElPTl9FTkRTX1RPT19MQVRFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAiVCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc190aW1lIGV4aXN0cwogICAgZXh0cmFjdCAzMiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIFJvdW5kCiAgICBmcmFtZV9kaWcgLTYKICAgICsKICAgIGl0b2IKICAgIGI+PQogICAgYXNzZXJ0IC8vIERlbGVnYXRpb24gd291bGQgZW5kIGF0IGEgbGF0ZXIgdGltZSB0aGFuIGFsbG93ZWQgYnkgdmFsaWRhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MjIKICAgIC8vIHN0YWtlX21heF9zY2FsZWRfcHJpY2UgPSBzdGFrZV9tYXggLy8gVUludDY0KEZST01fQkFTRV9UT19NSUNST19NVUxUSVBMSUVSKQogICAgZnJhbWVfZGlnIC01CiAgICBpbnRjXzMgLy8gMTAwMDAwMAogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MjMKICAgIC8vIHRtcCA9IG9wLm11bHcoc2VsZi50ZXJtc19wcmljZS52YWx1ZS5mZWVfcm91bmRfdmFyLm5hdGl2ZSwgc3Rha2VfbWF4X3NjYWxlZF9wcmljZSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJQIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3ByaWNlIGV4aXN0cwogICAgZXh0cmFjdCAxNiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgbXVsdwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MjQKICAgIC8vIGZlZV9yb3VuZF92YXIgPSBvcC5kaXZ3KHRtcFswXSwgdG1wWzFdLCBVSW50NjQoRlJPTV9NSUxMSV9UT19OQU5PX01VTFRJUExJRVIpKQogICAgaW50Y18zIC8vIDEwMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTI2CiAgICAvLyBzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmZlZV9yb3VuZF9taW4ubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gIlAiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfcHJpY2UgZXhpc3RzCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTI1LTkyOAogICAgLy8gZmVlX3JvdW5kID0gbWF4aW11bSgKICAgIC8vICAgICBzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmZlZV9yb3VuZF9taW4ubmF0aXZlLAogICAgLy8gICAgIGZlZV9yb3VuZF92YXIKICAgIC8vICkKICAgIHN3YXAKICAgIGNhbGxzdWIgbWF4aW11bQogICAgZnJhbWVfYnVyeSA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkyOQogICAgLy8gZmVlX3NldHVwID0gc2VsZi50ZXJtc19wcmljZS52YWx1ZS5mZWVfc2V0dXAubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiUCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc19wcmljZSBleGlzdHMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2J1cnkgOQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MzEKICAgIC8vIGlmIHBhcnRuZXJfYWRkcmVzcyAhPSBhcmM0LkFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyk6CiAgICBmcmFtZV9kaWcgLTQKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9lbHNlX2JvZHlANwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MzIKICAgIC8vIHRtcCA9IG9wLm11bHcoZmVlX3JvdW5kLCBwYXJ0bmVyX2NvbW1pc3Npb24pCiAgICBmcmFtZV9kaWcgNwogICAgZnJhbWVfZGlnIC0zCiAgICBtdWx3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzMwogICAgLy8gZmVlX3JvdW5kX3BhcnRuZXIgPSBvcC5kaXZ3KHRtcFswXSwgdG1wWzFdLCBVSW50NjQoT05FX0lOX1BQTSkpCiAgICBpbnRjXzMgLy8gMTAwMDAwMAogICAgZGl2dwogICAgZnJhbWVfYnVyeSA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjkzNQogICAgLy8gdG1wID0gb3AubXVsdyhmZWVfc2V0dXAsIHBhcnRuZXJfY29tbWlzc2lvbikKICAgIGZyYW1lX2RpZyA5CiAgICBmcmFtZV9kaWcgLTMKICAgIG11bHcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTM2CiAgICAvLyBmZWVfc2V0dXBfcGFydG5lciA9IG9wLmRpdncodG1wWzBdLCB0bXBbMV0sIFVJbnQ2NChPTkVfSU5fUFBNKSkKICAgIGludGNfMyAvLyAxMDAwMDAwCiAgICBkaXZ3CiAgICBiIGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDgKCmNvbnRyYWN0X2NyZWF0ZV9lbHNlX2JvZHlANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTM4CiAgICAvLyBmZWVfcm91bmRfcGFydG5lciA9IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgOAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5MzkKICAgIC8vIGZlZV9zZXR1cF9wYXJ0bmVyID0gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAoKY29udHJhY3RfY3JlYXRlX2FmdGVyX2lmX2Vsc2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQyCiAgICAvLyBjb21taXNzaW9uID0gc2VsZi50ZXJtc19wcmljZS52YWx1ZS5jb21taXNzaW9uLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gIlAiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfcHJpY2UgZXhpc3RzCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQzCiAgICAvLyBmZWVfcm91bmQgPSBhcmM0LlVJbnQ2NChmZWVfcm91bmQpLAogICAgZnJhbWVfZGlnIDcKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ0CiAgICAvLyBmZWVfc2V0dXAgPSBhcmM0LlVJbnQ2NChmZWVfc2V0dXApLAogICAgZnJhbWVfZGlnIDkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ1CiAgICAvLyBmZWVfYXNzZXRfaWQgPSBzZWxmLnRlcm1zX3ByaWNlLnZhbHVlLmZlZV9hc3NldF9pZCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJQIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3ByaWNlIGV4aXN0cwogICAgZXh0cmFjdCAzMiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NDcKICAgIC8vIGZlZV9yb3VuZF9wYXJ0bmVyID0gYXJjNC5VSW50NjQoZmVlX3JvdW5kX3BhcnRuZXIpLAogICAgZnJhbWVfZGlnIDgKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTQ4CiAgICAvLyBmZWVfc2V0dXBfcGFydG5lciA9IGFyYzQuVUludDY0KGZlZV9zZXR1cF9wYXJ0bmVyKSwKICAgIHVuY292ZXIgNQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NDkKICAgIC8vIHJvdW5kc19zZXR1cCA9IHNlbGYudGVybXNfdGltZS52YWx1ZS5yb3VuZHNfc2V0dXAsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAiVCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc190aW1lIGV4aXN0cwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk1MAogICAgLy8gcm91bmRzX2NvbmZpcm0gPSBzZWxmLnRlcm1zX3RpbWUudmFsdWUucm91bmRzX2NvbmZpcm0sCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAiVCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc190aW1lIGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk0MS05NTEKICAgIC8vIGRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCA9IERlbGVnYXRpb25UZXJtc0dlbmVyYWwoCiAgICAvLyAgICAgY29tbWlzc2lvbiA9IHNlbGYudGVybXNfcHJpY2UudmFsdWUuY29tbWlzc2lvbiwKICAgIC8vICAgICBmZWVfcm91bmQgPSBhcmM0LlVJbnQ2NChmZWVfcm91bmQpLAogICAgLy8gICAgIGZlZV9zZXR1cCA9IGFyYzQuVUludDY0KGZlZV9zZXR1cCksCiAgICAvLyAgICAgZmVlX2Fzc2V0X2lkID0gc2VsZi50ZXJtc19wcmljZS52YWx1ZS5mZWVfYXNzZXRfaWQsCiAgICAvLyAgICAgcGFydG5lcl9hZGRyZXNzID0gcGFydG5lcl9hZGRyZXNzLAogICAgLy8gICAgIGZlZV9yb3VuZF9wYXJ0bmVyID0gYXJjNC5VSW50NjQoZmVlX3JvdW5kX3BhcnRuZXIpLAogICAgLy8gICAgIGZlZV9zZXR1cF9wYXJ0bmVyID0gYXJjNC5VSW50NjQoZmVlX3NldHVwX3BhcnRuZXIpLAogICAgLy8gICAgIHJvdW5kc19zZXR1cCA9IHNlbGYudGVybXNfdGltZS52YWx1ZS5yb3VuZHNfc2V0dXAsCiAgICAvLyAgICAgcm91bmRzX2NvbmZpcm0gPSBzZWxmLnRlcm1zX3RpbWUudmFsdWUucm91bmRzX2NvbmZpcm0sCiAgICAvLyApCiAgICB1bmNvdmVyIDcKICAgIHVuY292ZXIgNwogICAgY29uY2F0CiAgICB1bmNvdmVyIDYKICAgIGNvbmNhdAogICAgdW5jb3ZlciA1CiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTMKICAgIC8vIHN0YWtlX21heF9tYXggPSBzZWxmLnRlcm1zX3N0YWtlLnZhbHVlLnN0YWtlX21heC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vICJTIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3N0YWtlIGV4aXN0cwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTU0CiAgICAvLyBhc3NlcnQgc3Rha2VfbWF4IDw9IHN0YWtlX21heF9tYXgsIEVSUk9SX1JFUVVFU1RFRF9NQVhfU1RBS0VfVE9PX0hJR0gKICAgIGZyYW1lX2RpZyAtNQogICAgZGlnIDEKICAgIDw9CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIHJlcXVlc3RlZCBhIHN0YWtlIGFib3ZlIHRoZSBtYXhpbXVtIGFsbG93ZWQgYnkgdGhlIHZhbGlkYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTU2CiAgICAvLyB0bXAgPSBvcC5tdWx3KHN0YWtlX21heCwgc2VsZi50ZXJtc19zdGFrZS52YWx1ZS5zdGFrZV9ncmF0aXMubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gIlMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudGVybXNfc3Rha2UgZXhpc3RzCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtNQogICAgbXVsdwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTcKICAgIC8vIHN0YWtlX2dyYXRpc19hYnMgPSBvcC5kaXZ3KHRtcFswXSwgdG1wWzFdLCBVSW50NjQoU1RBS0VfR1JBVElTX01BWCkpCiAgICBpbnRjXzMgLy8gMTAwMDAwMAogICAgZGl2dwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NTgKICAgIC8vIHN0YWtlX21heF93X2dyYXRpcyA9IHN0YWtlX21heCArIHN0YWtlX2dyYXRpc19hYnMKICAgIGZyYW1lX2RpZyAtNQogICAgKwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk1OQogICAgLy8gaWYgc3Rha2VfbWF4X3dfZ3JhdGlzIDwgc3Rha2VfbWF4X21heDoKICAgID4KICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9lbHNlX2JvZHlAMTAKICAgIGZyYW1lX2RpZyAxMQogICAgYiBjb250cmFjdF9jcmVhdGVfYWZ0ZXJfaWZfZWxzZUAxMQoKY29udHJhY3RfY3JlYXRlX2Vsc2VfYm9keUAxMDoKICAgIGZyYW1lX2RpZyAxMAoKY29udHJhY3RfY3JlYXRlX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk2NQogICAgLy8gc3Rha2VfbWF4ID0gYXJjNC5VSW50NjQoc3Rha2VfbWF4X2dpdmVuKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTY2CiAgICAvLyBjbnRfYnJlYWNoX2RlbF9tYXggPSBzZWxmLnRlcm1zX3dhcm4udmFsdWUuY250X3dhcm5pbmdfbWF4LAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJXIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3dhcm4gZXhpc3RzCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTY3CiAgICAvLyByb3VuZHNfYnJlYWNoID0gc2VsZi50ZXJtc193YXJuLnZhbHVlLnJvdW5kc193YXJuaW5nLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJXIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRlcm1zX3dhcm4gZXhpc3RzCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTY4CiAgICAvLyBnYXRpbmdfYXNhX2xpc3QgPSBzZWxmLnRlcm1zX3JlcXMudmFsdWUuZ2F0aW5nX2FzYV9saXN0LmNvcHkoKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNiAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50ZXJtc19yZXFzIGV4aXN0cwogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NjQtOTY5CiAgICAvLyBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UgPSBEZWxlZ2F0aW9uVGVybXNCYWxhbmNlKAogICAgLy8gICAgIHN0YWtlX21heCA9IGFyYzQuVUludDY0KHN0YWtlX21heF9naXZlbiksCiAgICAvLyAgICAgY250X2JyZWFjaF9kZWxfbWF4ID0gc2VsZi50ZXJtc193YXJuLnZhbHVlLmNudF93YXJuaW5nX21heCwKICAgIC8vICAgICByb3VuZHNfYnJlYWNoID0gc2VsZi50ZXJtc193YXJuLnZhbHVlLnJvdW5kc193YXJuaW5nLAogICAgLy8gICAgIGdhdGluZ19hc2FfbGlzdCA9IHNlbGYudGVybXNfcmVxcy52YWx1ZS5nYXRpbmdfYXNhX2xpc3QuY29weSgpLAogICAgLy8gKQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5NzEtOTc4CiAgICAvLyBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9zZXR1cCwKICAgIC8vICAgICBzZWxmLnRjX3NoYTI1Ni5jb3B5KCksCiAgICAvLyAgICAgZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLmNvcHkoKSwKICAgIC8vICAgICBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UuY29weSgpLAogICAgLy8gICAgIHJvdW5kc19kdXJhdGlvbiwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTczCiAgICAvLyBzZWxmLnRjX3NoYTI1Ni5jb3B5KCksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTUgLy8gInRjX3NoYTI1NiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50Y19zaGEyNTYgZXhpc3RzCiAgICBmcmFtZV9kaWcgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk3MS05NzgKICAgIC8vIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X3NldHVwLAogICAgLy8gICAgIHNlbGYudGNfc2hhMjU2LmNvcHkoKSwKICAgIC8vICAgICBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwuY29weSgpLAogICAgLy8gICAgIGRlbGVnYXRpb25fdGVybXNfYmFsYW5jZS5jb3B5KCksCiAgICAvLyAgICAgcm91bmRzX2R1cmF0aW9uLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4N2QzZGI0NzQgLy8gbWV0aG9kICJjb250cmFjdF9zZXR1cChieXRlWzMyXSwodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSwodWludDY0LHVpbnQ2NCx1aW50NjQsKHVpbnQ2NCx1aW50NjQpWzJdKSx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5ODAtOTgxCiAgICAvLyAjIENoZWNrIHBheW1lbnQgYW5kIGZvcndhcmQgaXQgdG8gdGhlIGNyZWF0ZWQgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBpZiB0eG4udHlwZSA9PSBUcmFuc2FjdGlvblR5cGUuUGF5bWVudDoKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgVHlwZUVudW0KICAgIGR1cAogICAgZnJhbWVfYnVyeSAxMgogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGJ6IGNvbnRyYWN0X2NyZWF0ZV9lbHNlX2JvZHlAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTgyCiAgICAvLyBhc3NlcnQgdHhuLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsIEVSUk9SX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk4NAogICAgLy8gdHlwZT1UcmFuc2FjdGlvblR5cGUuUGF5bWVudCwKICAgIGludGNfMSAvLyBwYXkKICAgIGZyYW1lX2J1cnkgMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTg1CiAgICAvLyByZWNlaXZlcj1kZWxfYXBwLmFkZHJlc3MsCiAgICBmcmFtZV9kaWcgNQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTg2CiAgICAvLyBhbW91bnQ9dHhuLmFtb3VudCwKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBmcmFtZV9idXJ5IDE3CiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5ODMKICAgIC8vIHR4bl9mb3J3YXJkID0gaXR4bi5Jbm5lclRyYW5zYWN0aW9uKAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMTYKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE0CiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgZnJhbWVfYnVyeSA0CiAgICBiIGNvbnRyYWN0X2NyZWF0ZV9hZnRlcl9pZl9lbHNlQDE4Cgpjb250cmFjdF9jcmVhdGVfZWxzZV9ib2R5QDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5ODgKICAgIC8vIGVsaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXI6CiAgICBmcmFtZV9kaWcgMTIKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiB0eXBlIG11c3QgYmUgZWl0aGVyIFBheW1lbnQgb3IgQXNzZXRUcmFuc2Zlci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTg5CiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X3JlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsIEVSUk9SX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTkxCiAgICAvLyB0eXBlPVRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyLAogICAgcHVzaGludCA0IC8vIGF4ZmVyCiAgICBmcmFtZV9idXJ5IDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk5MgogICAgLy8geGZlcl9hc3NldD10eG4ueGZlcl9hc3NldCwKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgWGZlckFzc2V0CiAgICBmcmFtZV9idXJ5IDIwCiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5OTMKICAgIC8vIGFzc2V0X3JlY2VpdmVyPWRlbF9hcHAuYWRkcmVzcywKICAgIGZyYW1lX2RpZyA1CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weTo5OTQKICAgIC8vIGFzc2V0X2Ftb3VudD10eG4uYXNzZXRfYW1vdW50LAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldEFtb3VudAogICAgZnJhbWVfYnVyeSAxOAogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTkwCiAgICAvLyB0eG5fZm9yd2FyZCA9IGl0eG4uSW5uZXJUcmFuc2FjdGlvbigKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE1CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxMwogICAgZnJhbWVfYnVyeSAzCgpjb250cmFjdF9jcmVhdGVfYWZ0ZXJfaWZfZWxzZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTk5LTEwMDQKICAgIC8vICMgUGF5IHNldHVwIGZlZSB0byB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCggICMgbm9xYTogRjg0MQogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X3BheSwKICAgIC8vICAgICB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBpbnRjXzEgLy8gMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAwMgogICAgLy8gdHhuX2ZvcndhcmQuY29weSgpLAogICAgYnogY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjAKICAgIGZyYW1lX2RpZyAzCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCmNvbnRyYWN0X2NyZWF0ZV9uZXh0X2ZpZWxkQDIwOgogICAgZnJhbWVfZGlnIDE0CiAgICBpbnRjXzEgLy8gMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAwMgogICAgLy8gdHhuX2ZvcndhcmQuY29weSgpLAogICAgYnogY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjIKICAgIGZyYW1lX2RpZyAxOAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAoKY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjI6CiAgICBmcmFtZV9kaWcgMTYKICAgIGludGNfMSAvLyAxCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDAyCiAgICAvLyB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICBieiBjb250cmFjdF9jcmVhdGVfbmV4dF9maWVsZEAyNAogICAgZnJhbWVfZGlnIDIwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAoKY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjQ6CiAgICBmcmFtZV9kaWcgMTMKICAgIGludGNfMSAvLyAxCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDAyCiAgICAvLyB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICBieiBjb250cmFjdF9jcmVhdGVfbmV4dF9maWVsZEAyNgogICAgZnJhbWVfZGlnIDE3CiAgICBpdHhuX2ZpZWxkIEFtb3VudAoKY29udHJhY3RfY3JlYXRlX25leHRfZmllbGRAMjY6CiAgICBmcmFtZV9kaWcgMTUKICAgIGludGNfMSAvLyAxCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDAyCiAgICAvLyB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICBieiBjb250cmFjdF9jcmVhdGVfbmV4dF9maWVsZEAyOAogICAgZnJhbWVfZGlnIDQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKCmNvbnRyYWN0X2NyZWF0ZV9uZXh0X2ZpZWxkQDI4OgogICAgZnJhbWVfZGlnIDE5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5Ojk4MwogICAgLy8gdHhuX2ZvcndhcmQgPSBpdHhuLklubmVyVHJhbnNhY3Rpb24oCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6OTk5LTEwMDQKICAgIC8vICMgUGF5IHNldHVwIGZlZSB0byB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCggICMgbm9xYTogRjg0MQogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X3BheSwKICAgIC8vICAgICB0eG5fZm9yd2FyZC5jb3B5KCksCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX25leHQKICAgIGZyYW1lX2RpZyA1CiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4YjQ3ZWY5ZWIgLy8gbWV0aG9kICJjb250cmFjdF9wYXkodHhuKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAwNi0xMDA3CiAgICAvLyAjIEFkZCBjcmVhdGVkIGRlbGVnYXRvciBjb250cmFjdCB0byB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGlzIHZhbGlkYXRvciBhZAogICAgLy8gYXNzZXJ0IHNlbGYuX2FkZF9kZWxfdG9fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0xJU1RfRlVMTAogICAgZHVwCiAgICBjYWxsc3ViIF9hZGRfZGVsX3RvX2xpc3QKICAgIGFzc2VydCAvLyBDb3VsZCBub3QgYWRkIGRlbGVnYXRvciBjb250cmFjdCB0byBkZWxlZ2F0b3IgY29udHJhY3QgbGlzdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAwOC0xMDA5CiAgICAvLyAjIENoZWNrIGlmIHZhbGlkYXRvciBhZCBoYXMgcmVhY2hlZCBpdHMgbGltaXQgb24gbWF4aW11bSBhY2NlcHRlZCBkZWxlZ2F0b3JzCiAgICAvLyBhc3NlcnQgc2VsZi5jbnRfZGVsIDw9IHNlbGYuY250X2RlbF9tYXgsIEVSUk9SX1ZBTElEQVRPUl9GVUxMCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiY250X2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE3IC8vICJjbnRfZGVsX21heCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsX21heCBleGlzdHMKICAgIDw9CiAgICBhc3NlcnQgLy8gVmFsaWRhdG9yIGFkIGhhcyByZWFjaCB0aGUgbGltaXQgb2YgbWF4aW11bSBudW1iZXIgb2YgYWN0aXZlIGRlbGVnYXRvcnMgYWNjZXB0ZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTEtMTAxMwogICAgLy8gIyBDaGVjayBpZiB0aGUgaW5wdXQgTUJSIHBheW1lbnQgdHJhbnNhY3Rpb24gd2FzIHN1ZmZpY2llbnQgZm9yIGluY3JlYXNlIHZhbGlkYXRvciBhZCdzIE1CUiBhbmQKICAgIC8vICMgZm9yIGZ1bmRpbmcgdGhlIGRlbGVnYXRvciBjb250cmFjdCdzIE1CUgogICAgLy8gbWJyX25ldyA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDE0CiAgICAvLyBhbXQgPSBkZWxfbWJyX2Z1bmQgKyAobWJyX25ldyAtIG1icl9jdXIpCiAgICBmcmFtZV9kaWcgMjEKICAgIC0KICAgIGZyYW1lX2RpZyA2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTUKICAgIC8vIGFzc2VydCBtYnJfdHhuLnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsIEVSUk9SX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHRvIHRoaXMgY29udHJhY3QuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwMTYKICAgIC8vIGFzc2VydCBtYnJfdHhuLmFtb3VudCA9PSBhbXQsIEVSUk9SX0FNT1VOVAogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgID09CiAgICBhc3NlcnQgLy8gU2VudCBhbW91bnQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTAxOAogICAgLy8gcmV0dXJuIGFyYzQuVUludDY0KGRlbF9hcHAuaWQpCiAgICBpdG9iCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5oZWxwZXJzLmNvbW1vbi5tYXhpbXVtKGE6IHVpbnQ2NCwgYjogdWludDY0KSAtPiB1aW50NjQ6Cm1heGltdW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NzY3LTc3MQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBtYXhpbXVtKAogICAgLy8gICAgIGE6IFVJbnQ2NCwKICAgIC8vICAgICBiOiBVSW50NjQsCiAgICAvLyApIC0+IFVJbnQ2NDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc3NQogICAgLy8gaWYgYSA8IGI6CiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgPAogICAgYnogbWF4aW11bV9lbHNlX2JvZHlAMgogICAgZnJhbWVfZGlnIC0xCiAgICBiIG1heGltdW1fYWZ0ZXJfaWZfZWxzZUAzCgptYXhpbXVtX2Vsc2VfYm9keUAyOgogICAgZnJhbWVfZGlnIC0yCgptYXhpbXVtX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3NzkKICAgIC8vIHJldHVybiBjCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLl9hZGRfZGVsX3RvX2xpc3QoZGVsX2FwcF9pZDogdWludDY0KSAtPiB1aW50NjQ6Cl9hZGRfZGVsX3RvX2xpc3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MjYtMTUzMAogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gSW50ZXJuYWwgZnVuY3Rpb25zIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfYWRkX2RlbF90b19saXN0KHNlbGYsIGRlbF9hcHBfaWQ6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUzMgogICAgLy8gZGVsX2FkZGVkID0gRmFsc2UKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MzMKICAgIC8vIGZvciBkZWxfaWR4IGluIHVyYW5nZShNQVhJTVVNX05VTUJFUl9PRl9ERUxFR0FUT1JfQ09OVFJBQ1RTX1BFUl9WQUxJREFUT1JfQUQpOgogICAgZHVwCgpfYWRkX2RlbF90b19saXN0X2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUzMwogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBmcmFtZV9kaWcgNAogICAgcHVzaGludCAxNCAvLyAxNAogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9idXJ5IDEKICAgIGJ6IF9hZGRfZGVsX3RvX2xpc3RfYWZ0ZXJfZm9yQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUzNAogICAgLy8gaWYgc2VsZi5kZWxfYXBwX2xpc3RbZGVsX2lkeF0gPT0gYXJjNC5VSW50NjQoMCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiZGVsX2FwcF9saXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9hcHBfbGlzdCBleGlzdHMKICAgIGZyYW1lX2RpZyA0CiAgICBwdXNoaW50IDggLy8gOAogICAgKgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ5dGVjIDI0IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgYj09CiAgICBieiBfYWRkX2RlbF90b19saXN0X2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTM1CiAgICAvLyBzZWxmLmRlbF9hcHBfbGlzdFtkZWxfaWR4XSA9IGFyYzQuVUludDY0KGRlbF9hcHBfaWQpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJkZWxfYXBwX2xpc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2FwcF9saXN0IGV4aXN0cwogICAgZnJhbWVfZGlnIDAKICAgIGFzc2VydCAvLyBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDIKICAgIHVuY292ZXIgMgogICAgcmVwbGFjZTMKICAgIGJ5dGVjIDUgLy8gImRlbF9hcHBfbGlzdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MzYKICAgIC8vIGRlbF9hZGRlZCA9IFRydWUKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MzcKICAgIC8vIHNlbGYuY250X2RlbCArPSAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiY250X2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfZGVsIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjIDQgLy8gImNudF9kZWwiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1MzgKICAgIC8vIGJyZWFrCiAgICBiIF9hZGRfZGVsX3RvX2xpc3RfYWZ0ZXJfZm9yQDYKCl9hZGRfZGVsX3RvX2xpc3RfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTMzCiAgICAvLyBmb3IgZGVsX2lkeCBpbiB1cmFuZ2UoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKToKICAgIGZyYW1lX2RpZyA0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIF9hZGRfZGVsX3RvX2xpc3RfZm9yX2hlYWRlckAxCgpfYWRkX2RlbF90b19saXN0X2FmdGVyX2ZvckA2OgogICAgZnJhbWVfZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0MAogICAgLy8gcmV0dXJuIGRlbF9hZGRlZAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmtleXNfY29uZmlybShkZWxfbWFuYWdlcjogYnl0ZXMsIGRlbF9hcHA6IHVpbnQ2NCkgLT4gdm9pZDoKa2V5c19jb25maXJtOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDIwLTEwMjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYga2V5c19jb25maXJtKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDM4CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTA0MAogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTA0Mi0xMDQ3CiAgICAvLyAjIENhbGwga2V5c19jb25maXJtIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKCAgIyBub3FhOiBGODQxCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3Qua2V5c19jb25maXJtLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hieXRlcyAweGNhZWIxYTdiIC8vIG1ldGhvZCAia2V5c19jb25maXJtKGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDQ5CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwX2lkOiB1aW50NjQpIC0+IHVpbnQ2NDoKX2V4aXN0c19kZWxfaW5fbGlzdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU1NS0xNTU2CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIF9leGlzdHNfZGVsX2luX2xpc3Qoc2VsZiwgZGVsX2FwcF9pZDogVUludDY0KSAtPiBib29sOgogICAgcHJvdG8gMSAxCiAgICBwdXNoYnl0ZXMgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU1OAogICAgLy8gZGVsX2V4aXN0cyA9IEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTU5CiAgICAvLyBmb3IgZGVsX2lkeCBpbiB1cmFuZ2UoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKToKICAgIGR1cAoKX2V4aXN0c19kZWxfaW5fbGlzdF9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NTkKICAgIC8vIGZvciBkZWxfaWR4IGluIHVyYW5nZShNQVhJTVVNX05VTUJFUl9PRl9ERUxFR0FUT1JfQ09OVFJBQ1RTX1BFUl9WQUxJREFUT1JfQUQpOgogICAgZnJhbWVfZGlnIDIKICAgIHB1c2hpbnQgMTQgLy8gMTQKICAgIDwKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9idXJ5IDAKICAgIGJ6IF9leGlzdHNfZGVsX2luX2xpc3RfYWZ0ZXJfZm9yQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU2MAogICAgLy8gaWYgc2VsZi5kZWxfYXBwX2xpc3RbZGVsX2lkeF0gPT0gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiZGVsX2FwcF9saXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9hcHBfbGlzdCBleGlzdHMKICAgIGZyYW1lX2RpZyAyCiAgICBwdXNoaW50IDggLy8gOAogICAgKgogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBiPT0KICAgIGJ6IF9leGlzdHNfZGVsX2luX2xpc3RfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NjEKICAgIC8vIGRlbF9leGlzdHMgPSBUcnVlCiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NjIKICAgIC8vIGJyZWFrCiAgICBiIF9leGlzdHNfZGVsX2luX2xpc3RfYWZ0ZXJfZm9yQDYKCl9leGlzdHNfZGVsX2luX2xpc3RfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTU5CiAgICAvLyBmb3IgZGVsX2lkeCBpbiB1cmFuZ2UoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKToKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIF9leGlzdHNfZGVsX2luX2xpc3RfZm9yX2hlYWRlckAxCgpfZXhpc3RzX2RlbF9pbl9saXN0X2FmdGVyX2ZvckA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTY0CiAgICAvLyByZXR1cm4gZGVsX2V4aXN0cwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5rZXlzX25vdF9jb25maXJtZWQoZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKa2V5c19ub3RfY29uZmlybWVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDUxLTEwNTUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYga2V5c19ub3RfY29uZmlybWVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FwcDogQXBwbGljYXRpb24sCiAgICAvLyApIC0+IE1lc3NhZ2U6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTA3MgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNzQKICAgIC8vIGFzc2VydCBzZWxmLl9leGlzdHNfZGVsX2luX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9ET0VTX05PVF9FWElTVF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZXhpc3RzX2RlbF9pbl9saXN0CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwNzYtMTA4MAogICAgLy8gIyBDYWxsIGtleXNfbm90X2NvbmZpcm1lZCBvZiB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyByZXMsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmtleXNfbm90X2NvbmZpcm1lZCwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHgyNjFiZDE5OSAvLyBtZXRob2QgImtleXNfbm90X2NvbmZpcm1lZCgpKGFkZHJlc3MsYnl0ZVsxMDBdKSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwODItMTA4MwogICAgLy8gIyBSZW1vdmUgdGhlIGRlbGVnYXRvciBjb250cmFjdCBmcm9tIHRoZSBsaXN0CiAgICAvLyBhc3NlcnQgc2VsZi5fcmVtb3ZlX2RlbF9mcm9tX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0ZBSUxfVE9fUkVNT1ZFX0RFTEVHQVRPUl9DT05UUkFDVF9GUk9NX0xJU1QKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfcmVtb3ZlX2RlbF9mcm9tX2xpc3QKICAgIGFzc2VydCAvLyBGYWlsZWQgdG8gcmVtb3ZlIGRlbGVnYXRvciBjb250cmFjdCBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwODYKICAgIC8vIGRlbF9tYW5hZ2VyPXJlcy5kZWxfbWFuYWdlciwKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMDg3CiAgICAvLyBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICBzd2FwCiAgICBleHRyYWN0IDMyIDEwMCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTA4NS0xMDg4CiAgICAvLyByZXR1cm4gTWVzc2FnZSgKICAgIC8vICAgICBkZWxfbWFuYWdlcj1yZXMuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgbXNnPXJlcy5tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwX2lkOiB1aW50NjQpIC0+IHVpbnQ2NDoKX3JlbW92ZV9kZWxfZnJvbV9saXN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTQyLTE1NDMKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX3JlbW92ZV9kZWxfZnJvbV9saXN0KHNlbGYsIGRlbF9hcHBfaWQ6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDEgMQogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NQogICAgLy8gZGVsX3JlbW92ZWQgPSBGYWxzZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NgogICAgLy8gZm9yIGRlbF9pZHggaW4gdXJhbmdlKE1BWElNVU1fTlVNQkVSX09GX0RFTEVHQVRPUl9DT05UUkFDVFNfUEVSX1ZBTElEQVRPUl9BRCk6CiAgICBkdXAKCl9yZW1vdmVfZGVsX2Zyb21fbGlzdF9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NDYKICAgIC8vIGZvciBkZWxfaWR4IGluIHVyYW5nZShNQVhJTVVNX05VTUJFUl9PRl9ERUxFR0FUT1JfQ09OVFJBQ1RTX1BFUl9WQUxJREFUT1JfQUQpOgogICAgZnJhbWVfZGlnIDQKICAgIHB1c2hpbnQgMTQgLy8gMTQKICAgIDwKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSAxCiAgICBieiBfcmVtb3ZlX2RlbF9mcm9tX2xpc3RfYWZ0ZXJfZm9yQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU0NwogICAgLy8gaWYgc2VsZi5kZWxfYXBwX2xpc3RbZGVsX2lkeF0gPT0gYXJjNC5VSW50NjQoZGVsX2FwcF9pZCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiZGVsX2FwcF9saXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9hcHBfbGlzdCBleGlzdHMKICAgIGZyYW1lX2RpZyA0CiAgICBwdXNoaW50IDggLy8gOAogICAgKgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYj09CiAgICBieiBfcmVtb3ZlX2RlbF9mcm9tX2xpc3RfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NDgKICAgIC8vIHNlbGYuZGVsX2FwcF9saXN0W2RlbF9pZHhdID0gYXJjNC5VSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJkZWxfYXBwX2xpc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2FwcF9saXN0IGV4aXN0cwogICAgZnJhbWVfZGlnIDAKICAgIGFzc2VydCAvLyBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDIKICAgIGJ5dGVjIDI0IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgcmVwbGFjZTMKICAgIGJ5dGVjIDUgLy8gImRlbF9hcHBfbGlzdCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NDkKICAgIC8vIGRlbF9yZW1vdmVkID0gVHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU1MAogICAgLy8gc2VsZi5jbnRfZGVsIC09IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJjbnRfZGVsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNudF9kZWwgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgYnl0ZWMgNCAvLyAiY250X2RlbCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU1MQogICAgLy8gYnJlYWsKICAgIGIgX3JlbW92ZV9kZWxfZnJvbV9saXN0X2FmdGVyX2ZvckA2CgpfcmVtb3ZlX2RlbF9mcm9tX2xpc3RfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTQ2CiAgICAvLyBmb3IgZGVsX2lkeCBpbiB1cmFuZ2UoTUFYSU1VTV9OVU1CRVJfT0ZfREVMRUdBVE9SX0NPTlRSQUNUU19QRVJfVkFMSURBVE9SX0FEKToKICAgIGZyYW1lX2RpZyA0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIF9yZW1vdmVfZGVsX2Zyb21fbGlzdF9mb3JfaGVhZGVyQDEKCl9yZW1vdmVfZGVsX2Zyb21fbGlzdF9hZnRlcl9mb3JANjoKICAgIGZyYW1lX2RpZyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NTMKICAgIC8vIHJldHVybiBkZWxfcmVtb3ZlZAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmtleXNfbm90X3N1Ym1pdHRlZChkZWxfYXBwOiB1aW50NjQpIC0+IGJ5dGVzOgprZXlzX25vdF9zdWJtaXR0ZWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEwOTAtMTA5NAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX25vdF9zdWJtaXR0ZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTExCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTExMwogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTExNS0xMTE5CiAgICAvLyAjIENhbGwga2V5c19ub3Rfc3VibWl0dGVkIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3Qua2V5c19ub3Rfc3VibWl0dGVkLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hieXRlcyAweGZlODExYWU3IC8vIG1ldGhvZCAia2V5c19ub3Rfc3VibWl0dGVkKCkoYWRkcmVzcyxieXRlWzEwMF0pIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTEyMS0xMTIyCiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTEyNQogICAgLy8gZGVsX21hbmFnZXI9cmVzLmRlbF9tYW5hZ2VyLAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExMjYKICAgIC8vIG1zZz1yZXMubXNnLmNvcHkoKSwKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgMTAwIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTI0LTExMjcKICAgIC8vIHJldHVybiBNZXNzYWdlKAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPXJlcy5kZWxfbWFuYWdlciwKICAgIC8vICAgICBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQua2V5c19zdWJtaXQodmFsX21hbmFnZXI6IGJ5dGVzLCBkZWxfYXBwOiB1aW50NjQsIGtleV9yZWdfdHhuX2luZm86IGJ5dGVzKSAtPiBieXRlczoKa2V5c19zdWJtaXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExMjktMTEzNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX3N1Ym1pdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHZhbF9tYW5hZ2VyOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgZGVsX2FwcDogQXBwbGljYXRpb24sCiAgICAvLyAgICAga2V5X3JlZ190eG5faW5mbyA6IEtleVJlZ1R4bkluZm8sCiAgICAvLyApIC0+IE1lc3NhZ2U6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTE1NgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNTgKICAgIC8vIGFzc2VydCBzZWxmLl9leGlzdHNfZGVsX2luX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9ET0VTX05PVF9FWElTVF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBfZXhpc3RzX2RlbF9pbl9saXN0CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNjAKICAgIC8vIGFzc2VydCBzZWxmLnZhbF9tYW5hZ2VyID09IHZhbF9tYW5hZ2VyLm5hdGl2ZSwgRVJST1JfQ0FMTEVEX0JZX05PVF9WQUxfTUFOQUdFUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDExIC8vICJ2YWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG1hbmFnZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNjItMTE2NwogICAgLy8gIyBDYWxsIGtleXNfc3VibWl0IG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3Qua2V5c19zdWJtaXQsCiAgICAvLyAgICAga2V5X3JlZ190eG5faW5mbywKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHgxZjMzOTlhOCAvLyBtZXRob2QgImtleXNfc3VibWl0KCh1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzMyXSxieXRlWzMyXSxieXRlWzY0XSxhZGRyZXNzKSkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTY4CiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSByZXMuZWFybmluZ3NfZGlzdHJpYnV0aW9uLmNvcHkoKQogICAgZHVwCiAgICBleHRyYWN0IDAgMjQgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNzAtMTE3MQogICAgLy8gIyBNYXJrIGluY3JlYXNlIGluIHZhbGlkYXRvcidzIGVhcm5pbmdzCiAgICAvLyBzZWxmLl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgY2FsbHN1YiBfbWFya192YWxpZGF0b3JfZWFybmluZ3MKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTc0CiAgICAvLyBkZWxfbWFuYWdlcj1yZXMuZGVsX21hbmFnZXIsCiAgICBkdXAKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjExNzUKICAgIC8vIG1zZz1yZXMubXNnLmNvcHkoKSwKICAgIHN3YXAKICAgIGV4dHJhY3QgNTYgMTAwIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTczLTExNzYKICAgIC8vIHJldHVybiBNZXNzYWdlKAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPXJlcy5kZWxfbWFuYWdlciwKICAgIC8vICAgICBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzKGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbjogYnl0ZXMpIC0+IGJ5dGVzOgpfbWFya192YWxpZGF0b3JfZWFybmluZ3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NjYtMTU2NwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfbWFya192YWxpZGF0b3JfZWFybmluZ3Moc2VsZiwgZWFybmluZ3NfZGlzdHJpYnV0aW9uOiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbikgLT4gTm9uZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTY5CiAgICAvLyBhc3NldF9pZCA9IGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5hc3NldF9pZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAxNiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NzAKICAgIC8vIGlmIGFzc2V0X2lkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBieiBfbWFya192YWxpZGF0b3JfZWFybmluZ3NfZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3MwogICAgLy8gc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9lYXJuaW5nLm5hdGl2ZSArIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi51c2VyLm5hdGl2ZQogICAgZnJhbWVfZGlnIDAKICAgIGl0b2IKICAgIGJ5dGVjIDEzIC8vIDB4NjE3MzYxNWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc2FzIGVudHJ5IGV4aXN0cwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTcyLTE1NzQKICAgIC8vIHNlbGYuYXNhc1thc3NldF0udG90YWxfZWFybmluZyA9IGFyYzQuVUludDY0KAogICAgLy8gICAgIHNlbGYuYXNhc1thc3NldF0udG90YWxfZWFybmluZy5uYXRpdmUgKyBlYXJuaW5nc19kaXN0cmlidXRpb24udXNlci5uYXRpdmUKICAgIC8vICkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3MgogICAgLy8gc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9lYXJuaW5nID0gYXJjNC5VSW50NjQoCiAgICBkaWcgMQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNhcyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3Mi0xNTc0CiAgICAvLyBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2Vhcm5pbmcgPSBhcmM0LlVJbnQ2NCgKICAgIC8vICAgICBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2Vhcm5pbmcubmF0aXZlICsgZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlCiAgICAvLyApCiAgICBzd2FwCiAgICByZXBsYWNlMiAwCiAgICBkaWcgMQogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTc2CiAgICAvLyBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2ZlZXNfZ2VuZXJhdGVkLm5hdGl2ZSArIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNhcyBlbnRyeSBleGlzdHMKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU3NS0xNTc3CiAgICAvLyBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2ZlZXNfZ2VuZXJhdGVkID0gYXJjNC5VSW50NjQoCiAgICAvLyAgICAgc2VsZi5hc2FzW2Fzc2V0XS50b3RhbF9mZWVzX2dlbmVyYXRlZC5uYXRpdmUgKyBlYXJuaW5nc19kaXN0cmlidXRpb24ucGxhdGZvcm0ubmF0aXZlCiAgICAvLyApCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE1NzUKICAgIC8vIHNlbGYuYXNhc1thc3NldF0udG90YWxfZmVlc19nZW5lcmF0ZWQgPSBhcmM0LlVJbnQ2NCgKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc2FzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTc1LTE1NzcKICAgIC8vIHNlbGYuYXNhc1thc3NldF0udG90YWxfZmVlc19nZW5lcmF0ZWQgPSBhcmM0LlVJbnQ2NCgKICAgIC8vICAgICBzZWxmLmFzYXNbYXNzZXRdLnRvdGFsX2ZlZXNfZ2VuZXJhdGVkLm5hdGl2ZSArIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUKICAgIC8vICkKICAgIHN3YXAKICAgIHJlcGxhY2UyIDgKICAgIGJveF9wdXQKICAgIGIgX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMwoKX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzX2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTc5CiAgICAvLyBzZWxmLnRvdGFsX2FsZ29fZWFybmVkICs9IGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi51c2VyLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE4IC8vICJ0b3RhbF9hbGdvX2Vhcm5lZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50b3RhbF9hbGdvX2Vhcm5lZCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICArCiAgICBieXRlYyAxOCAvLyAidG90YWxfYWxnb19lYXJuZWQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNTgwCiAgICAvLyBzZWxmLnRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQgKz0gZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE5IC8vICJ0b3RhbF9hbGdvX2ZlZXNfZ2VuZXJhdGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgKwogICAgYnl0ZWMgMTkgLy8gInRvdGFsX2FsZ29fZmVlc19nZW5lcmF0ZWQiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAoKX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTU4MgogICAgLy8gcmV0dXJuCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYnJlYWNoX2xpbWl0cyhkZWxfYXBwOiB1aW50NjQpIC0+IGJ5dGVzOgpicmVhY2hfbGltaXRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMTc4LTExODIKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYnJlYWNoX2xpbWl0cygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBCcmVhY2hMaW1pdHNSZXR1cm46CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIwNQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyMDcKICAgIC8vIGFzc2VydCBzZWxmLl9leGlzdHNfZGVsX2luX2xpc3QoZGVsX2FwcC5pZCksIEVSUk9SX0RFTEVHQVRPUl9ET0VTX05PVF9FWElTVF9BVF9WQUxJREFUT1JfQUQKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfZXhpc3RzX2RlbF9pbl9saXN0CiAgICBhc3NlcnQgLy8gRGVsZWdhdG9yIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBkZWxlZ2F0b3JzIG9mIHRoZSB2YWxpZGF0b3IgYWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyMDktMTIxMwogICAgLy8gIyBDYWxsIGJyZWFjaF9saW1pdHMgb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gcmVzLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5icmVhY2hfbGltaXRzLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hieXRlcyAweGMxNzczZWUwIC8vIG1ldGhvZCAiYnJlYWNoX2xpbWl0cygpKGJvb2wsKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIxNS0xMjE2CiAgICAvLyAjIE1hcmsgaW5jcmVhc2UgaW4gdmFsaWRhdG9yJ3MgZWFybmluZ3MKICAgIC8vIHNlbGYuX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzKHJlcy5lYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgZHVwCiAgICBleHRyYWN0IDEgMjQgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBjYWxsc3ViIF9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyMTgKICAgIC8vIGlmIHJlcy5tYXhfYnJlYWNoX3JlYWNoZWQubmF0aXZlOgogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgcHVzaGJ5dGVzIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnogYnJlYWNoX2xpbWl0c19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTIxOS0xMjIwCiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KCmJyZWFjaF9saW1pdHNfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjIyCiAgICAvLyByZXR1cm4gcmVzLmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuYnJlYWNoX3BheShkZWxfYXBwOiB1aW50NjQpIC0+IGJ5dGVzOgpicmVhY2hfcGF5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjI0LTEyMjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYnJlYWNoX3BheSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBNZXNzYWdlOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyNDYKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjQ4CiAgICAvLyBhc3NlcnQgc2VsZi5fZXhpc3RzX2RlbF9pbl9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9ERUxFR0FUT1JfRE9FU19OT1RfRVhJU1RfQVRfVkFMSURBVE9SX0FECiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX2V4aXN0c19kZWxfaW5fbGlzdAogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBjb250cmFjdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjUwLTEyNTQKICAgIC8vICMgQ2FsbCBicmVhY2hfcGF5IG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuYnJlYWNoX3BheSwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHg5NTE2MjQ1ZSAvLyBtZXRob2QgImJyZWFjaF9wYXkoKShhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjU2LTEyNTcKICAgIC8vICMgUmVtb3ZlIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdAogICAgLy8gYXNzZXJ0IHNlbGYuX3JlbW92ZV9kZWxfZnJvbV9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9GQUlMX1RPX1JFTU9WRV9ERUxFR0FUT1JfQ09OVFJBQ1RfRlJPTV9MSVNUCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX3JlbW92ZV9kZWxfZnJvbV9saXN0CiAgICBhc3NlcnQgLy8gRmFpbGVkIHRvIHJlbW92ZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjU5CiAgICAvLyByZXR1cm4gcmVzLmNvcHkoKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnZhbGlkYXRvcl9hZC5jb250cmFjdC5WYWxpZGF0b3JBZC5icmVhY2hfc3VzcGVuZGVkKGRlbF9hcHA6IHVpbnQ2NCkgLT4gYnl0ZXM6CmJyZWFjaF9zdXNwZW5kZWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEyNjEtMTI2NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBicmVhY2hfc3VzcGVuZGVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX2FwcDogQXBwbGljYXRpb24sCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjg2CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTI4OAogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTI5MC0xMjk0CiAgICAvLyAjIENhbGwgYnJlYWNoX3N1c3BlbmRlZCBvZiB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyByZXMsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmJyZWFjaF9zdXNwZW5kZWQsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4OTA0NGUyMWYgLy8gbWV0aG9kICJicmVhY2hfc3VzcGVuZGVkKCkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMjk2LTEyOTcKICAgIC8vICMgTWFyayBpbmNyZWFzZSBpbiB2YWxpZGF0b3IncyBlYXJuaW5ncwogICAgLy8gc2VsZi5fbWFya192YWxpZGF0b3JfZWFybmluZ3MocmVzLmVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkpCiAgICBkdXAKICAgIGV4dHJhY3QgMCAyNCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGNhbGxzdWIgX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTI5OS0xMzAwCiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMwMgogICAgLy8gcmV0dXJuIHJlcy5jb3B5KCkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuY29udHJhY3RfY2xhaW0oZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfY2xhaW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMDQtMTMwOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb250cmFjdF9jbGFpbSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRlbF9hcHA6IEFwcGxpY2F0aW9uLAogICAgLy8gKSAtPiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbjoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzI2CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMyOAogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTMzMC0xMzM0CiAgICAvLyAjIENhbGwga2V5c19ub3Rfc3VibWl0dGVkIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbiwgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfY2xhaW0sCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4MjZmNTlhNDYgLy8gbWV0aG9kICJjb250cmFjdF9jbGFpbSgpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMzYtMTMzNwogICAgLy8gIyBNYXJrIGluY3JlYXNlIGluIHZhbGlkYXRvcidzIGVhcm5pbmdzCiAgICAvLyBzZWxmLl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgZHVwCiAgICBjYWxsc3ViIF9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjEzMzkKICAgIC8vIHJldHVybiBlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X2V4cGlyZWQoZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfZXhwaXJlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM0MS0xMzQ1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X2V4cGlyZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzYyCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM2NAogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM2Ni0xMzcwCiAgICAvLyAjIENhbGwgY29udHJhY3RfZXhwaXJlZCBvZiB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0CiAgICAvLyByZXMsIGFwcF90eG4gPSBhcmM0LmFiaV9jYWxsKAogICAgLy8gICAgIERlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2V4cGlyZWQsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4Yjg4MzIyYmIgLy8gbWV0aG9kICJjb250cmFjdF9leHBpcmVkKCkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLGJ5dGVbMTAwXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzcyLTEzNzMKICAgIC8vICMgTWFyayBpbmNyZWFzZSBpbiB2YWxpZGF0b3IncyBlYXJuaW5ncwogICAgLy8gc2VsZi5fbWFya192YWxpZGF0b3JfZWFybmluZ3MocmVzLmVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkpCiAgICBkdXAKICAgIGV4dHJhY3QgMCAyNCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGNhbGxzdWIgX21hcmtfdmFsaWRhdG9yX2Vhcm5pbmdzCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM3NS0xMzc2CiAgICAvLyAjIFJlbW92ZSB0aGUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3QKICAgIC8vIGFzc2VydCBzZWxmLl9yZW1vdmVfZGVsX2Zyb21fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfRkFJTF9UT19SRU1PVkVfREVMRUdBVE9SX0NPTlRSQUNUX0ZST01fTElTVAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9yZW1vdmVfZGVsX2Zyb21fbGlzdAogICAgYXNzZXJ0IC8vIEZhaWxlZCB0byByZW1vdmUgZGVsZWdhdG9yIGNvbnRyYWN0IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM3OQogICAgLy8gZGVsX21hbmFnZXI9cmVzLmRlbF9tYW5hZ2VyLAogICAgZHVwCiAgICBleHRyYWN0IDI0IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxMzgwCiAgICAvLyBtc2c9cmVzLm1zZy5jb3B5KCksCiAgICBzd2FwCiAgICBleHRyYWN0IDU2IDEwMCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM3OC0xMzgxCiAgICAvLyByZXR1cm4gTWVzc2FnZSgKICAgIC8vICAgICBkZWxfbWFuYWdlcj1yZXMuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgbXNnPXJlcy5tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X3dpdGhkcmF3KGRlbF9tYW5hZ2VyOiBieXRlcywgZGVsX2FwcDogdWludDY0KSAtPiB2b2lkOgpjb250cmFjdF93aXRoZHJhdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTM4My0xMzg4CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X3dpdGhkcmF3KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDAxCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQwMwogICAgLy8gYXNzZXJ0IHNlbGYuX2V4aXN0c19kZWxfaW5fbGlzdChkZWxfYXBwLmlkKSwgRVJST1JfREVMRUdBVE9SX0RPRVNfTk9UX0VYSVNUX0FUX1ZBTElEQVRPUl9BRAogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9leGlzdHNfZGVsX2luX2xpc3QKICAgIGFzc2VydCAvLyBEZWxlZ2F0b3IgY29udHJhY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGRlbGVnYXRvcnMgb2YgdGhlIHZhbGlkYXRvciBhZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQwNS0xNDEwCiAgICAvLyAjIENhbGwgY29udHJhY3Rfd2l0aGRyYXcgb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gZWFybmluZ3NfZGlzdHJpYnV0aW9uLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF93aXRoZHJhdywKICAgIC8vICAgICBkZWxfbWFuYWdlciwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoYnl0ZXMgMHhmNTNiOTVjZCAvLyBtZXRob2QgImNvbnRyYWN0X3dpdGhkcmF3KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEFSQzQgcHJlZml4IGlzIHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0MTItMTQxMwogICAgLy8gIyBNYXJrIGluY3JlYXNlIGluIHZhbGlkYXRvcidzIGVhcm5pbmdzCiAgICAvLyBzZWxmLl9tYXJrX3ZhbGlkYXRvcl9lYXJuaW5ncyhlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpKQogICAgY2FsbHN1YiBfbWFya192YWxpZGF0b3JfZWFybmluZ3MKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDE1LTE0MTYKICAgIC8vICMgUmVtb3ZlIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdAogICAgLy8gYXNzZXJ0IHNlbGYuX3JlbW92ZV9kZWxfZnJvbV9saXN0KGRlbF9hcHAuaWQpLCBFUlJPUl9GQUlMX1RPX1JFTU9WRV9ERUxFR0FUT1JfQ09OVFJBQ1RfRlJPTV9MSVNUCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX3JlbW92ZV9kZWxfZnJvbV9saXN0CiAgICBhc3NlcnQgLy8gRmFpbGVkIHRvIHJlbW92ZSBkZWxlZ2F0b3IgY29udHJhY3QgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgZGVsZWdhdG9ycyBvZiB0aGUgdmFsaWRhdG9yIGFkLgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDE4CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy52YWxpZGF0b3JfYWQuY29udHJhY3QuVmFsaWRhdG9yQWQuY29udHJhY3RfZGVsZXRlKGRlbF9tYW5hZ2VyOiBieXRlcywgZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDIwLTE0MjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfZGVsZXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gQ29udHJhY3REZWxldGVSZXR1cm46CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQzNwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0MzkKICAgIC8vIG1icl9jdXIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ0MS0xNDQ2CiAgICAvLyAjIENhbGwgY29udHJhY3RfZGVsZXRlIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlbWFpbmluZ19iYWxhbmNlLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9kZWxldGUsCiAgICAvLyAgICAgZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXBwX2lkPWRlbF9hcHAuaWQsCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgIGl0eG5fZmllbGQgT25Db21wbGV0aW9uCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGJ5dGVzIDB4ZjJlNjc5MzQgLy8gbWV0aG9kICJjb250cmFjdF9kZWxldGUoYWRkcmVzcykodWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDQ4CiAgICAvLyBtYnJfbmV3ID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdmFsaWRhdG9yX2FkL2NvbnRyYWN0LnB5OjE0NDkKICAgIC8vIGFtdCA9IG1icl9jdXIgLSBtYnJfbmV3CiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ1MS0xNDU1CiAgICAvLyAjIFNlbmQgdGhlIGZyZWVkIE1CUiB0byBkZWxlZ2F0b3IgbWFuYWdlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWRlbF9tYW5hZ2VyLm5hdGl2ZSwKICAgIC8vICAgICBhbW91bnQ9YW10LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDUxLTE0NTIKICAgIC8vICMgU2VuZCB0aGUgZnJlZWQgTUJSIHRvIGRlbGVnYXRvciBtYW5hZ2VyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ1MS0xNDU1CiAgICAvLyAjIFNlbmQgdGhlIGZyZWVkIE1CUiB0byBkZWxlZ2F0b3IgbWFuYWdlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWRlbF9tYW5hZ2VyLm5hdGl2ZSwKICAgIC8vICAgICBhbW91bnQ9YW10LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ1NwogICAgLy8gcmV0dXJuIHJlbWFpbmluZ19iYWxhbmNlCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbihiZWZvcmVfZXhwaXJ5OiB1aW50NjQsIHJlcG9ydF9wZXJpb2Q6IHVpbnQ2NCwgZGVsX2FwcDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uOgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDU5LTE0NjUKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgYmVmb3JlX2V4cGlyeTogVUludDY0LAogICAgLy8gICAgIHJlcG9ydF9wZXJpb2Q6IFVJbnQ2NCwKICAgIC8vICAgICBkZWxfYXBwOiBBcHBsaWNhdGlvbiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDg2CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ4OC0xNDk0CiAgICAvLyAjIENhbGwgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uIG9mIHRoZSBkZWxlZ2F0b3IgY29udHJhY3QKICAgIC8vIHJlcywgYXBwX3R4biA9IGFyYzQuYWJpX2NhbGwoCiAgICAvLyAgICAgRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uLAogICAgLy8gICAgIGJlZm9yZV9leHBpcnksCiAgICAvLyAgICAgcmVwb3J0X3BlcmlvZCwKICAgIC8vICAgICBhcHBfaWQ9ZGVsX2FwcC5pZCwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTQ5MQogICAgLy8gYmVmb3JlX2V4cGlyeSwKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDkyCiAgICAvLyByZXBvcnRfcGVyaW9kLAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDg4LTE0OTQKICAgIC8vICMgQ2FsbCBjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24gb2YgdGhlIGRlbGVnYXRvciBjb250cmFjdAogICAgLy8gcmVzLCBhcHBfdHhuID0gYXJjNC5hYmlfY2FsbCgKICAgIC8vICAgICBEZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24sCiAgICAvLyAgICAgYmVmb3JlX2V4cGlyeSwKICAgIC8vICAgICByZXBvcnRfcGVyaW9kLAogICAgLy8gICAgIGFwcF9pZD1kZWxfYXBwLmlkLAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4ZWFmYTFlMTUgLy8gbWV0aG9kICJjb250cmFjdF9yZXBvcnRfZXhwaXJ5X3Nvb24odWludDY0LHVpbnQ2NCkoYWRkcmVzcyxieXRlWzEwMF0pIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBBUkM0IHByZWZpeCBpcyB2YWxpZAogICAgLy8gc21hcnRfY29udHJhY3RzL3ZhbGlkYXRvcl9hZC9jb250cmFjdC5weToxNDk2CiAgICAvLyByZXR1cm4gcmVzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmdldF92YWxpZGF0b3JfYXNhKGFzc2V0X2lkOiB1aW50NjQpIC0+IGJ5dGVzOgpnZXRfdmFsaWRhdG9yX2FzYToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUwNy0xNTE0CiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tLS0tLS0tLS0tLS0tLSAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSBSZWFkLW9ubHkgZnVuY3Rpb25zIC0tLS0tIC0tLS0tIC0tLS0KICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyBAYXJjNC5hYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfdmFsaWRhdG9yX2FzYSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFzc2V0X2lkIDogVUludDY0LAogICAgLy8gKSAtPiBWYWxpZGF0b3JBU0E6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy92YWxpZGF0b3JfYWQvY29udHJhY3QucHk6MTUyNAogICAgLy8gcmV0dXJuIHNlbGYuYXNhc1tBc3NldChhc3NldF9pZCldCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGJ5dGVjIDEzIC8vIDB4NjE3MzYxNWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNhcyBlbnRyeSBleGlzdHMKICAgIHJldHN1Ygo=",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCgpzbWFydF9jb250cmFjdHMudmFsaWRhdG9yX2FkLmNvbnRyYWN0LlZhbGlkYXRvckFkLmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="
    },
    "state": {
        "global": {
            "num_byte_slices": 11,
            "num_uints": 6
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {
                "cnt_asa": {
                    "type": "uint64",
                    "key": "cnt_asa"
                },
                "cnt_del": {
                    "type": "uint64",
                    "key": "cnt_del"
                },
                "cnt_del_max": {
                    "type": "uint64",
                    "key": "cnt_del_max"
                },
                "del_app_list": {
                    "type": "bytes",
                    "key": "del_app_list"
                },
                "noticeboard_app_id": {
                    "type": "uint64",
                    "key": "noticeboard_app_id"
                },
                "state": {
                    "type": "bytes",
                    "key": "state"
                },
                "tc_sha256": {
                    "type": "bytes",
                    "key": "tc_sha256"
                },
                "terms_price": {
                    "type": "bytes",
                    "key": "P"
                },
                "terms_reqs": {
                    "type": "bytes",
                    "key": "G"
                },
                "terms_stake": {
                    "type": "bytes",
                    "key": "S"
                },
                "terms_time": {
                    "type": "bytes",
                    "key": "T"
                },
                "terms_warn": {
                    "type": "bytes",
                    "key": "W"
                },
                "total_algo_earned": {
                    "type": "uint64",
                    "key": "total_algo_earned"
                },
                "total_algo_fees_generated": {
                    "type": "uint64",
                    "key": "total_algo_fees_generated"
                },
                "val_info": {
                    "type": "bytes",
                    "key": "V",
                    "descr": "Self-disclosed information about validator."
                },
                "val_manager": {
                    "type": "bytes",
                    "key": "val_manager"
                },
                "val_owner": {
                    "type": "bytes",
                    "key": "val_owner"
                }
            },
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "ValidatorAd",
        "methods": [
            {
                "name": "ad_create",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address for the validator ad."
                    }
                ],
                "returns": {
                    "type": "uint64",
                    "desc": "App ID of the created validator ad application."
                },
                "desc": "Creates a new ValidatorAd.\nDefines validator ad owner account. Defines Noticeboard app ID to which this contract belongs to."
            },
            {
                "name": "ad_config",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "address",
                        "name": "val_manager",
                        "desc": "Manager address for the validator ad."
                    },
                    {
                        "type": "bool",
                        "name": "live",
                        "desc": "Set to True if validator ad should be accepting new delegators, otherwise set to False."
                    },
                    {
                        "type": "uint64",
                        "name": "cnt_del_max",
                        "desc": "Maximum number of delegators the validator is willing to manage simultaneously."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Sets all operation configuration parameters for the validator ad, i.e.\nthe validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept."
            },
            {
                "name": "ad_delete",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Validator owner deletes a validator ad.\nPossible only if there are no active delegators and all balances have been claimed."
            },
            {
                "name": "ad_ready",
                "args": [
                    {
                        "type": "address",
                        "name": "val_manager",
                        "desc": "Manager address for the validator ad."
                    },
                    {
                        "type": "bool",
                        "name": "ready",
                        "desc": "Set to True if validator manager is ready for accepting new delegators, otherwise set to False."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Ad manager sets its readiness for operation."
            },
            {
                "name": "ad_self_disclose",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "(byte[30],byte[60],byte[2],uint64,byte[20])",
                        "name": "val_info",
                        "desc": "Self-disclosed information about the validator."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Ad owner sets its self-disclosure information."
            },
            {
                "name": "ad_terms",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "byte[32]",
                        "name": "tc_sha256",
                        "desc": "Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator."
                    },
                    {
                        "type": "(uint64,uint64,uint64,uint64,uint64)",
                        "name": "terms_time",
                        "desc": "Validator's terms about timing."
                    },
                    {
                        "type": "(uint64,uint64,uint64,uint64,uint64)",
                        "name": "terms_price",
                        "desc": "Validator's terms about pricing."
                    },
                    {
                        "type": "(uint64,uint64)",
                        "name": "terms_stake",
                        "desc": "Validator's terms about stake limits."
                    },
                    {
                        "type": "((uint64,uint64)[2])",
                        "name": "terms_reqs",
                        "desc": "Validator's terms about gating requirements."
                    },
                    {
                        "type": "(uint64,uint64)",
                        "name": "terms_warn",
                        "desc": "Validator's terms about warnings."
                    },
                    {
                        "type": "pay",
                        "name": "txn",
                        "desc": "Transaction for the payment of MBR increase."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Sets all the terms of the validator.\nWith this action, the validator agrees with the (new) terms."
            },
            {
                "name": "ad_income",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "uint64",
                        "name": "asset_id",
                        "desc": "ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like to withdraw all earnings from the validator ad."
                    }
                ],
                "returns": {
                    "type": "uint64",
                    "desc": "Withdrawn income from the validator ad for the input asset."
                },
                "desc": "Validator owner withdraws all available balance from the validator ad for the given asset."
            },
            {
                "name": "ad_asa_close",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "uint64",
                        "name": "asset_id",
                        "desc": "ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like remove its storage."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Removes the asset's storage on the validator ad.\nTo be used before deleting the contract."
            },
            {
                "name": "template_load_init",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "uint64",
                        "name": "template_size",
                        "desc": "Size of the delegator contract template in bytes."
                    },
                    {
                        "type": "pay",
                        "name": "mbr_txn",
                        "desc": "Payment transaction for the payment of the increase of validator ad MBR due to creation of box for storing the delegator contract template."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Starts the process of uploading delegator contract template."
            },
            {
                "name": "template_load_data",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    },
                    {
                        "type": "uint64",
                        "name": "offset",
                        "desc": "Offset in the box at which to replace the data."
                    },
                    {
                        "type": "byte[]",
                        "name": "data",
                        "desc": "Data to replace in the box at the defined position."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Uploads a data chunk to the delegator contract template."
            },
            {
                "name": "template_load_end",
                "args": [
                    {
                        "type": "address",
                        "name": "val_owner",
                        "desc": "Owner address of the validator ad."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Ends uploading of the delegator contract template."
            },
            {
                "name": "contract_create",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Manager address for the delegation contract."
                    },
                    {
                        "type": "address",
                        "name": "del_beneficiary",
                        "desc": "Beneficiary address for the delegation contract."
                    },
                    {
                        "type": "uint64",
                        "name": "rounds_duration",
                        "desc": "Contract duration in number of rounds."
                    },
                    {
                        "type": "uint64",
                        "name": "stake_max",
                        "desc": "The maximum amount of ALGO that the delegator beneficiary address intends to have at any point in time during the contract duration."
                    },
                    {
                        "type": "address",
                        "name": "partner_address",
                        "desc": "Address of the partner that collects the partner convenience fees. If there is no partner, set it to Global.zero_address."
                    },
                    {
                        "type": "uint64",
                        "name": "partner_commission",
                        "desc": "Commission charged on top of validator price for partner's convenience offer. The value is represented in ppm."
                    },
                    {
                        "type": "pay",
                        "name": "mbr_txn",
                        "desc": "Payment transaction for the payment of the increase of validator ad MBR due to creation of a new contract."
                    },
                    {
                        "type": "txn",
                        "name": "txn",
                        "desc": "Transaction for the payment of the setup and operational fee."
                    }
                ],
                "returns": {
                    "type": "uint64",
                    "desc": "App ID of the created delegator contract application."
                },
                "desc": "Creates a new delegator contract with the current delegation terms for the input\ndelegator contract manager and delegator contract beneficiary with the specified duration."
            },
            {
                "name": "keys_confirm",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Purported delegator manager account."
                    },
                    {
                        "type": "application",
                        "name": "del_app"
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys\nand pays for the operational fee."
            },
            {
                "name": "keys_not_confirmed",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that keys of a delegator contract have not been confirmed in time."
            },
            {
                "name": "keys_not_submitted",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that keys of a delegator contract have not been submitted in time."
            },
            {
                "name": "keys_submit",
                "args": [
                    {
                        "type": "address",
                        "name": "val_manager",
                        "desc": "Purported validator manager account."
                    },
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    },
                    {
                        "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
                        "name": "key_reg_txn_info",
                        "desc": "Information about the generated participation keys."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Validator manager submits the keys generated for the delegator beneficiary according to the contract terms."
            },
            {
                "name": "breach_limits",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(bool,(uint64,uint64,uint64),address,byte[100])",
                    "desc": "Boolean denoting if maximum number of breaches has already been reached (True) or not (False)."
                },
                "desc": "Reports that a limit breach event occurred on the delegator beneficiary."
            },
            {
                "name": "breach_pay",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that a payment for the fee cannot be made from the delegator contract.\nThis can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager."
            },
            {
                "name": "breach_suspended",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "((uint64,uint64,uint64),address,byte[100])",
                    "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "Reports that the delegator beneficiary was suspended by consensus."
            },
            {
                "name": "contract_claim",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(uint64,uint64,uint64)",
                    "desc": "Amount of earnings of validator which equal any not yet claimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
                },
                "desc": "Claims the operational fee up to this round from a delegator contract and\ntransfers it to the validator ad as well as the commission to the platform."
            },
            {
                "name": "contract_expired",
                "args": [
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that a delegator contract has expired."
            },
            {
                "name": "contract_withdraw",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Purported delegator manager account."
                    },
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "void"
                },
                "desc": "Reports that a delegator has gracefully withdrawn from the contract prematurely.\nThe delegator beneficiary should issue a key deregistration transaction 320 round before this call."
            },
            {
                "name": "contract_delete",
                "args": [
                    {
                        "type": "address",
                        "name": "del_manager",
                        "desc": "Purported delegator manager account."
                    },
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(uint64,uint64)"
                },
                "desc": "Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd."
            },
            {
                "name": "contract_report_expiry_soon",
                "args": [
                    {
                        "type": "uint64",
                        "name": "before_expiry",
                        "desc": "How many rounds before contract end can the report be made."
                    },
                    {
                        "type": "uint64",
                        "name": "report_period",
                        "desc": "How frequently can the report be made."
                    },
                    {
                        "type": "application",
                        "name": "del_app",
                        "desc": "App ID of the delegator contract."
                    }
                ],
                "returns": {
                    "type": "(address,byte[100])",
                    "desc": "Address of delegator manager."
                },
                "desc": "Reports that the contract will expire soon."
            },
            {
                "name": "gas",
                "args": [],
                "returns": {
                    "type": "void"
                },
                "desc": "To fit more resources in app reference arrays."
            },
            {
                "name": "get_validator_asa",
                "args": [
                    {
                        "type": "uint64",
                        "name": "asset_id"
                    }
                ],
                "returns": {
                    "type": "(uint64,uint64)",
                    "desc": "Information about the payment asset that is or was accepted on the platform."
                },
                "desc": "Returns information about the ASA that is or was supported by the validator ad at any point of time before\ndeletion."
            }
        ],
        "networks": {},
        "desc": "\n    Ad of a validator owner to offer node running services to users.\n    Users, i.e. delegators, can open requests for the service and conclude an individual delegator contract with the\n    validator.\n    The contract terms are defined by this ad contents at time of the creation of the delegator contract.\n    The validator owner can change the ad to offer different terms for future delegator contracts.\n    The validator ad smart contract also acts as an escrow account for the payment received by the validator from\n    delegators for its service.\n\n    Global state\n    ------------\n    noticeboard_app_id : UInt64\n        App ID of noticeboard platform to which this contract belongs to.\n\n    delegation_terms_general : DelegationTermsGeneral\n        General delegation terms that validator defines and agrees to respect if a delegator concludes a delegator\n        contract based on them.\n    delegation_terms_balance : DelegationTermsBalance\n        Requirements for delegator beneficiary balance that validator defines and agrees to respect if a delegator\n        concludes a delegator contract based on them.\n\n    val_owner : Account\n        Validator owner account.\n    val_manager : Account\n        Validator manager account.\n\n    val_info : ValidatorSelfDisclosure\n        Self-disclosed information about the validator.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            CREATED - validator ad has been created.\n            TEMPLATE_LOAD - validator ad is getting loaded the delegator contract template.\n            TEMPLATE_LOADED - validator ad ended loading of the delegator contract template.\n            SET - initial terms of validator ad have been set.\n            READY - validator ad manager is ready to accept new delegators.\n            NOT_READY - validator ad manager is not ready to accept new delegators.\n            NOT_LIVE - validator ad owner does not want to accept new delegators.\n\n    cnt_del : UInt64\n        Counter of current delegators.\n    cnt_del_max : UInt64\n        Maximum number of delegators the validator is willing to manage simultaneously.\n    del_app_list : DelAppList\n        List of app ID of the currently active delegator contracts.\n\n    tc_sha256 : Sha256\n        Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator.\n\n    total_algo_earned : UInt64\n        Total amount of ALGO the validator ad has earned.\n    total_algo_fees_generated : UInt64\n        Total amount of ALGO the validator has generated as fees for the platform.\n\n    cnt_asa : UInt64\n        Counter of number of different ASAs supported by the contract.\n\n    Box storage\n    -----------\n    asas : asa_[ASA_ID] = ValidatorASA\n        Box map for storing ASA IDs that are or were supported by the validator ad at any point of time before deletion.\n        Each entry is a ValidatorASA, with fields for total_earnings and total_fees_generated for that ASA.\n        Keys correspond to \"asa_\" followed by byte representation of ASA ID.\n\n    template : BOX_DELEGATOR_CONTRACT_TEMPLATE_KEY = Bytes\n        Box for storing the delegator contract template.\n\n    Methods\n    -------\n    ad_create(\n        val_owner: arc4.Address,\n    ) -> arc4.UInt64:\n        Creates a new validator ad and returns its app ID.\n\n    ad_config(\n        val_owner: arc4.Address,\n        val_manager: arc4.Address,\n        live : arc4.Bool,\n        cnt_del_max : UInt64,\n    ) -> None:\n        Set the operational configuration of the validator ad.\n\n    ad_delete(\n        val_owner: arc4.Address,\n    ) -> None:\n        Validator owner deletes a validator ad.\n\n    ad_ready(\n        val_manager: arc4.Address,\n        ready: arc4.Bool,\n    ) -> None:\n        Ad manager sets its readiness for operation.\n\n    ad_self_disclose(\n        val_owner: arc4.Address,\n        val_info: ValidatorSelfDisclosure,\n    ) -> None:\n        Ad owner sets its self-disclosure information.\n\n    ad_terms(\n        val_owner: arc4.Address,\n        tc_sha256: Sha256,\n        terms_time: ValidatorTermsTiming,\n        terms_price: ValidatorTermsPricing,\n        terms_stake: ValidatorTermsStakeLimits,\n        terms_reqs: ValidatorTermsGating,\n        terms_warn: ValidatorTermsWarnings,\n        txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Sets all the terms of the validator.\n\n    ad_income(\n        val_owner: arc4.Address,\n        asset_id: UInt64,\n    ) -> arc4.UInt64:\n        Validator owner withdraws all available balance from the validator ad for the given asset.\n\n    ad_asa_close(\n        val_owner: arc4.Address,\n        asset_id: UInt64,\n    ) -> None:\n        Removes the asset's storage on the validator ad.\n\n    template_load_init(\n        val_owner: arc4.Address,\n        template_size: UInt64,\n        mbr_txn: gtxn.PaymentTransaction,\n    ) -> None:\n        Starts the process of uploading delegator contract template.\n\n    template_load_data(\n        val_owner: arc4.Address,\n        offset: UInt64,\n        data: Bytes,\n    ) -> None:\n        Uploads a data chunk to the delegator contract template.\n\n    template_load_end(\n        val_owner: arc4.Address,\n    ) -> None:\n        Ends uploading of the delegator contract template.\n\n    contract_create(\n        del_manager: arc4.Address,\n        del_beneficiary: arc4.Address,\n        rounds_duration: UInt64,\n        stake_max: UInt64,\n        partner_address: arc4.Address,\n        partner_commission: UInt64,\n        mbr_txn: gtxn.PaymentTransaction,\n        txn: gtxn.Transaction,\n    ) -> arc4.UInt64:\n        Creates a new delegator contract with the current delegation terms for the input\n        delegator contract manager and delegator contract beneficiary with the specified duration.\n\n    keys_confirm(\n        del_manager: arc4.Address,\n        del_app: Application,\n    ) -> None:\n        Delegator manager confirms that the keys have been confirmed by the delegator beneficiary.\n\n    keys_not_confirmed(\n        del_app: Application,\n    ) -> Message:\n        Reports that keys of a delegator contract have not been confirmed in time.\n\n    keys_not_submitted(\n        del_app: Application,\n    ) -> Message:\n        Reports that keys of a delegator contract have not been submitted in time.\n\n    keys_submit(\n        val_manager: arc4.Address,\n        del_app: Application,\n        key_reg_txn_info : KeyRegTxnInfo,\n    ) -> Message:\n        Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.\n\n    breach_limits(\n        del_app: Application,\n    ) -> BreachLimitsReturn:\n        Reports that a limit breach event occurred on the delegator beneficiary.\n\n    breach_pay(\n        del_app: Application,\n    ) -> Message:\n        Reports that a payment for the fee cannot be made from the delegator beneficiary.\n\n    breach_suspended(\n        del_app: Application,\n    ) -> EarningsDistributionAndMessage:\n        Reports that the delegator beneficiary was suspended by consensus.\n\n    contract_claim(\n        del_app: Application,\n    ) -> EarningsDistribution:\n        Claims and distributes the operational fee of validator up to this round to the validator and noticeboard.\n\n    contract_expired(\n        del_app: Application,\n    ) -> Message:\n        Reports that a delegator contract has expired.\n\n    contract_withdraw(\n        del_manager: arc4.Address,\n        del_app: Application,\n    ) -> None:\n        Reports that a delegator has gracefully withdrawn from the delegator contract prematurely.\n\n    contract_delete(\n        del_manager: arc4.Address,\n        del_app: Application,\n    ) -> ContractDeleteReturn:\n        Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.\n\n    contract_report_expiry_soon(\n        before_expiry: UInt64,\n        report_period: UInt64,\n    ) -> Message:\n        Reports that the contract will expire soon.\n\n    gas(\n    ) -> None:\n        To fit more resources in app reference arrays.\n\n    Private methods\n    ---------------\n    _add_del_to_list(self, del_app_id: UInt64) -> bool:\n        Assign created delegator contract to first free space in the list of delegator contracts.\n\n    _remove_del_from_list(self, del_app_id: UInt64) -> bool:\n        Remove the delegator contract from list of delegator contracts.\n\n    _exists_del_in_list(self, del_app_id: UInt64) -> bool:\n        Checks if a delegator contract exists in validator ad's list of delegator contracts.\n\n    _mark_validator_earnings(self, earnings_distribution: EarningsDistribution) -> None:\n        Mark increase in validator's earnings.\n\n    "
    },
    "bare_call_config": {}
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


@dataclasses.dataclass(kw_only=True)
class DeployCreate(algokit_utils.DeployCreateCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


@dataclasses.dataclass(kw_only=True)
class Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data) # type: ignore[call-overload]
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class AdConfigArgs(_ArgsBase[None]):
    """Sets all operation configuration parameters for the validator ad, i.e.
    the validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept."""

    val_owner: str
    """Owner address of the validator ad."""
    val_manager: str
    """Manager address for the validator ad."""
    live: bool
    """Set to True if validator ad should be accepting new delegators, otherwise set to False."""
    cnt_del_max: int
    """Maximum number of delegators the validator is willing to manage simultaneously."""

    @staticmethod
    def method() -> str:
        return "ad_config(address,address,bool,uint64)void"


@dataclasses.dataclass(kw_only=True)
class AdReadyArgs(_ArgsBase[None]):
    """Ad manager sets its readiness for operation."""

    val_manager: str
    """Manager address for the validator ad."""
    ready: bool
    """Set to True if validator manager is ready for accepting new delegators, otherwise set to False."""

    @staticmethod
    def method() -> str:
        return "ad_ready(address,bool)void"


@dataclasses.dataclass(kw_only=True)
class ValidatorSelfDisclosure:
    name: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    https: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    country_code: bytes | bytearray | tuple[int, int]
    hw_cat: int
    node_version: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class AdSelfDiscloseArgs(_ArgsBase[None]):
    """Ad owner sets its self-disclosure information."""

    val_owner: str
    """Owner address of the validator ad."""
    val_info: ValidatorSelfDisclosure
    """Self-disclosed information about the validator."""

    @staticmethod
    def method() -> str:
        return "ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void"


@dataclasses.dataclass(kw_only=True)
class ValidatorTermsTiming:
    rounds_setup: int
    rounds_confirm: int
    rounds_duration_min: int
    rounds_duration_max: int
    round_max_end: int


@dataclasses.dataclass(kw_only=True)
class ValidatorTermsPricing:
    commission: int
    fee_round_min: int
    fee_round_var: int
    fee_setup: int
    fee_asset_id: int


@dataclasses.dataclass(kw_only=True)
class ValidatorTermsStakeLimits:
    stake_max: int
    stake_gratis: int


@dataclasses.dataclass(kw_only=True)
class ValidatorTermsGating:
    gating_asa_list: list[tuple[int, int]] | tuple[tuple[int, int], tuple[int, int]]


@dataclasses.dataclass(kw_only=True)
class ValidatorTermsWarnings:
    cnt_warning_max: int
    rounds_warning: int


@dataclasses.dataclass(kw_only=True)
class AdTermsArgs(_ArgsBase[None]):
    """Sets all the terms of the validator.
    With this action, the validator agrees with the (new) terms."""

    val_owner: str
    """Owner address of the validator ad."""
    tc_sha256: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    """Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator."""
    terms_time: ValidatorTermsTiming
    """Validator's terms about timing."""
    terms_price: ValidatorTermsPricing
    """Validator's terms about pricing."""
    terms_stake: ValidatorTermsStakeLimits
    """Validator's terms about stake limits."""
    terms_reqs: ValidatorTermsGating
    """Validator's terms about gating requirements."""
    terms_warn: ValidatorTermsWarnings
    """Validator's terms about warnings."""
    txn: TransactionWithSigner
    """Transaction for the payment of MBR increase."""

    @staticmethod
    def method() -> str:
        return "ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void"


@dataclasses.dataclass(kw_only=True)
class AdIncomeArgs(_ArgsBase[int]):
    """Validator owner withdraws all available balance from the validator ad for the given asset."""

    val_owner: str
    """Owner address of the validator ad."""
    asset_id: int
    """ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like to withdraw all earnings from the validator ad."""

    @staticmethod
    def method() -> str:
        return "ad_income(address,uint64)uint64"


@dataclasses.dataclass(kw_only=True)
class AdAsaCloseArgs(_ArgsBase[None]):
    """Removes the asset's storage on the validator ad.
    To be used before deleting the contract."""

    val_owner: str
    """Owner address of the validator ad."""
    asset_id: int
    """ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like remove its storage."""

    @staticmethod
    def method() -> str:
        return "ad_asa_close(address,uint64)void"


@dataclasses.dataclass(kw_only=True)
class TemplateLoadInitArgs(_ArgsBase[None]):
    """Starts the process of uploading delegator contract template."""

    val_owner: str
    """Owner address of the validator ad."""
    template_size: int
    """Size of the delegator contract template in bytes."""
    mbr_txn: TransactionWithSigner
    """Payment transaction for the payment of the increase of validator ad MBR due to creation of box for storing the delegator contract template."""

    @staticmethod
    def method() -> str:
        return "template_load_init(address,uint64,pay)void"


@dataclasses.dataclass(kw_only=True)
class TemplateLoadDataArgs(_ArgsBase[None]):
    """Uploads a data chunk to the delegator contract template."""

    val_owner: str
    """Owner address of the validator ad."""
    offset: int
    """Offset in the box at which to replace the data."""
    data: bytes | bytearray
    """Data to replace in the box at the defined position."""

    @staticmethod
    def method() -> str:
        return "template_load_data(address,uint64,byte[])void"


@dataclasses.dataclass(kw_only=True)
class TemplateLoadEndArgs(_ArgsBase[None]):
    """Ends uploading of the delegator contract template."""

    val_owner: str
    """Owner address of the validator ad."""

    @staticmethod
    def method() -> str:
        return "template_load_end(address)void"


@dataclasses.dataclass(kw_only=True)
class ContractCreateArgs(_ArgsBase[int]):
    """Creates a new delegator contract with the current delegation terms for the input
    delegator contract manager and delegator contract beneficiary with the specified duration."""

    del_manager: str
    """Manager address for the delegation contract."""
    del_beneficiary: str
    """Beneficiary address for the delegation contract."""
    rounds_duration: int
    """Contract duration in number of rounds."""
    stake_max: int
    """The maximum amount of ALGO that the delegator beneficiary address intends to have at any point in time during the contract duration."""
    partner_address: str
    """Address of the partner that collects the partner convenience fees. If there is no partner, set it to Global.zero_address."""
    partner_commission: int
    """Commission charged on top of validator price for partner's convenience offer. The value is represented in ppm."""
    mbr_txn: TransactionWithSigner
    """Payment transaction for the payment of the increase of validator ad MBR due to creation of a new contract."""
    txn: TransactionWithSigner
    """Transaction for the payment of the setup and operational fee."""

    @staticmethod
    def method() -> str:
        return "contract_create(address,address,uint64,uint64,address,uint64,pay,txn)uint64"


@dataclasses.dataclass(kw_only=True)
class KeysConfirmArgs(_ArgsBase[None]):
    """Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys
    and pays for the operational fee."""

    del_manager: str
    """Purported delegator manager account."""
    del_app: int

    @staticmethod
    def method() -> str:
        return "keys_confirm(address,application)void"


@dataclasses.dataclass(kw_only=True)
class Message:
    del_manager: str
    msg: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class KeysNotConfirmedArgs(_ArgsBase[Message]):
    """Reports that keys of a delegator contract have not been confirmed in time."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "keys_not_confirmed(application)(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class KeysNotSubmittedArgs(_ArgsBase[Message]):
    """Reports that keys of a delegator contract have not been submitted in time."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "keys_not_submitted(application)(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class KeyRegTxnInfo:
    vote_first: int
    vote_last: int
    vote_key_dilution: int
    vote_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    selection_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    state_proof_pk: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]
    sender: str


@dataclasses.dataclass(kw_only=True)
class KeysSubmitArgs(_ArgsBase[Message]):
    """Validator manager submits the keys generated for the delegator beneficiary according to the contract terms."""

    val_manager: str
    """Purported validator manager account."""
    del_app: int
    """App ID of the delegator contract."""
    key_reg_txn_info: KeyRegTxnInfo
    """Information about the generated participation keys."""

    @staticmethod
    def method() -> str:
        return "keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class BreachLimitsReturn:
    max_breach_reached: bool
    earnings_distribution: tuple[int, int, int]
    del_manager: str
    msg: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class BreachLimitsArgs(_ArgsBase[BreachLimitsReturn]):
    """Reports that a limit breach event occurred on the delegator beneficiary."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class BreachPayArgs(_ArgsBase[Message]):
    """Reports that a payment for the fee cannot be made from the delegator contract.
    This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "breach_pay(application)(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class EarningsDistributionAndMessage:
    earnings_distribution: tuple[int, int, int]
    del_manager: str
    msg: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int]


@dataclasses.dataclass(kw_only=True)
class BreachSuspendedArgs(_ArgsBase[EarningsDistributionAndMessage]):
    """Reports that the delegator beneficiary was suspended by consensus."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "breach_suspended(application)((uint64,uint64,uint64),address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class EarningsDistribution:
    user: int
    platform: int
    asset_id: int


@dataclasses.dataclass(kw_only=True)
class ContractClaimArgs(_ArgsBase[EarningsDistribution]):
    """Claims the operational fee up to this round from a delegator contract and
    transfers it to the validator ad as well as the commission to the platform."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "contract_claim(application)(uint64,uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class ContractExpiredArgs(_ArgsBase[Message]):
    """Reports that a delegator contract has expired."""

    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "contract_expired(application)(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class ContractWithdrawArgs(_ArgsBase[None]):
    """Reports that a delegator has gracefully withdrawn from the contract prematurely.
    The delegator beneficiary should issue a key deregistration transaction 320 round before this call."""

    del_manager: str
    """Purported delegator manager account."""
    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "contract_withdraw(address,application)void"


@dataclasses.dataclass(kw_only=True)
class ContractDeleteReturn:
    remaining_balance: int
    asset_id: int


@dataclasses.dataclass(kw_only=True)
class ContractDeleteArgs(_ArgsBase[ContractDeleteReturn]):
    """Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd."""

    del_manager: str
    """Purported delegator manager account."""
    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "contract_delete(address,application)(uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class ContractReportExpirySoonArgs(_ArgsBase[Message]):
    """Reports that the contract will expire soon."""

    before_expiry: int
    """How many rounds before contract end can the report be made."""
    report_period: int
    """How frequently can the report be made."""
    del_app: int
    """App ID of the delegator contract."""

    @staticmethod
    def method() -> str:
        return "contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])"


@dataclasses.dataclass(kw_only=True)
class GasArgs(_ArgsBase[None]):
    """To fit more resources in app reference arrays."""

    @staticmethod
    def method() -> str:
        return "gas()void"


@dataclasses.dataclass(kw_only=True)
class ValidatorAsa:
    total_earning: int
    total_fees_generated: int


@dataclasses.dataclass(kw_only=True)
class GetValidatorAsaArgs(_ArgsBase[ValidatorAsa]):
    """Returns information about the ASA that is or was supported by the validator ad at any point of time before
    deletion."""

    asset_id: int

    @staticmethod
    def method() -> str:
        return "get_validator_asa(uint64)(uint64,uint64)"


@dataclasses.dataclass(kw_only=True)
class AdCreateArgs(_ArgsBase[int]):
    """Creates a new ValidatorAd.
    Defines validator ad owner account. Defines Noticeboard app ID to which this contract belongs to."""

    val_owner: str
    """Owner address for the validator ad."""

    @staticmethod
    def method() -> str:
        return "ad_create(address)uint64"


@dataclasses.dataclass(kw_only=True)
class AdDeleteArgs(_ArgsBase[None]):
    """Validator owner deletes a validator ad.
    Possible only if there are no active delegators and all balances have been claimed."""

    val_owner: str
    """Owner address of the validator ad."""

    @staticmethod
    def method() -> str:
        return "ad_delete(address)void"


class ByteReader:
    def __init__(self, data: bytes):
        self._data = data

    @property
    def as_bytes(self) -> bytes:
        return self._data

    @property
    def as_str(self) -> str:
        return self._data.decode("utf8")

    @property
    def as_base64(self) -> str:
        return base64.b64encode(self._data).decode("utf8")

    @property
    def as_hex(self) -> str:
        return self._data.hex()


class GlobalState:
    def __init__(self, data: dict[bytes, bytes | int]):
        self.cnt_asa = typing.cast(int, data.get(b"cnt_asa"))
        self.cnt_del = typing.cast(int, data.get(b"cnt_del"))
        self.cnt_del_max = typing.cast(int, data.get(b"cnt_del_max"))
        self.del_app_list = ByteReader(typing.cast(bytes, data.get(b"del_app_list")))
        self.noticeboard_app_id = typing.cast(int, data.get(b"noticeboard_app_id"))
        self.state = ByteReader(typing.cast(bytes, data.get(b"state")))
        self.tc_sha256 = ByteReader(typing.cast(bytes, data.get(b"tc_sha256")))
        self.terms_price = ByteReader(typing.cast(bytes, data.get(b"P")))
        self.terms_reqs = ByteReader(typing.cast(bytes, data.get(b"G")))
        self.terms_stake = ByteReader(typing.cast(bytes, data.get(b"S")))
        self.terms_time = ByteReader(typing.cast(bytes, data.get(b"T")))
        self.terms_warn = ByteReader(typing.cast(bytes, data.get(b"W")))
        self.total_algo_earned = typing.cast(int, data.get(b"total_algo_earned"))
        self.total_algo_fees_generated = typing.cast(int, data.get(b"total_algo_fees_generated"))
        self.val_info = ByteReader(typing.cast(bytes, data.get(b"V")))
        """Self-disclosed information about validator."""
        self.val_manager = ByteReader(typing.cast(bytes, data.get(b"val_manager")))
        self.val_owner = ByteReader(typing.cast(bytes, data.get(b"val_owner")))


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def ad_config(
        self,
        *,
        val_owner: str,
        val_manager: str,
        live: bool,
        cnt_del_max: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Sets all operation configuration parameters for the validator ad, i.e.
        the validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept.
        
        Adds a call to `ad_config(address,address,bool,uint64)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param str val_manager: Manager address for the validator ad.
        :param bool live: Set to True if validator ad should be accepting new delegators, otherwise set to False.
        :param int cnt_del_max: Maximum number of delegators the validator is willing to manage simultaneously.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdConfigArgs(
            val_owner=val_owner,
            val_manager=val_manager,
            live=live,
            cnt_del_max=cnt_del_max,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def ad_ready(
        self,
        *,
        val_manager: str,
        ready: bool,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Ad manager sets its readiness for operation.
        
        Adds a call to `ad_ready(address,bool)void` ABI method
        
        :param str val_manager: Manager address for the validator ad.
        :param bool ready: Set to True if validator manager is ready for accepting new delegators, otherwise set to False.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdReadyArgs(
            val_manager=val_manager,
            ready=ready,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def ad_self_disclose(
        self,
        *,
        val_owner: str,
        val_info: ValidatorSelfDisclosure,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Ad owner sets its self-disclosure information.
        
        Adds a call to `ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param ValidatorSelfDisclosure val_info: Self-disclosed information about the validator.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdSelfDiscloseArgs(
            val_owner=val_owner,
            val_info=val_info,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def ad_terms(
        self,
        *,
        val_owner: str,
        tc_sha256: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        terms_time: ValidatorTermsTiming,
        terms_price: ValidatorTermsPricing,
        terms_stake: ValidatorTermsStakeLimits,
        terms_reqs: ValidatorTermsGating,
        terms_warn: ValidatorTermsWarnings,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Sets all the terms of the validator.
        With this action, the validator agrees with the (new) terms.
        
        Adds a call to `ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] tc_sha256: Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator.
        :param ValidatorTermsTiming terms_time: Validator's terms about timing.
        :param ValidatorTermsPricing terms_price: Validator's terms about pricing.
        :param ValidatorTermsStakeLimits terms_stake: Validator's terms about stake limits.
        :param ValidatorTermsGating terms_reqs: Validator's terms about gating requirements.
        :param ValidatorTermsWarnings terms_warn: Validator's terms about warnings.
        :param TransactionWithSigner txn: Transaction for the payment of MBR increase.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdTermsArgs(
            val_owner=val_owner,
            tc_sha256=tc_sha256,
            terms_time=terms_time,
            terms_price=terms_price,
            terms_stake=terms_stake,
            terms_reqs=terms_reqs,
            terms_warn=terms_warn,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def ad_income(
        self,
        *,
        val_owner: str,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Validator owner withdraws all available balance from the validator ad for the given asset.
        
        Adds a call to `ad_income(address,uint64)uint64` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int asset_id: ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like to withdraw all earnings from the validator ad.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdIncomeArgs(
            val_owner=val_owner,
            asset_id=asset_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def ad_asa_close(
        self,
        *,
        val_owner: str,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Removes the asset's storage on the validator ad.
        To be used before deleting the contract.
        
        Adds a call to `ad_asa_close(address,uint64)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int asset_id: ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like remove its storage.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdAsaCloseArgs(
            val_owner=val_owner,
            asset_id=asset_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def template_load_init(
        self,
        *,
        val_owner: str,
        template_size: int,
        mbr_txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Starts the process of uploading delegator contract template.
        
        Adds a call to `template_load_init(address,uint64,pay)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int template_size: Size of the delegator contract template in bytes.
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of validator ad MBR due to creation of box for storing the delegator contract template.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = TemplateLoadInitArgs(
            val_owner=val_owner,
            template_size=template_size,
            mbr_txn=mbr_txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def template_load_data(
        self,
        *,
        val_owner: str,
        offset: int,
        data: bytes | bytearray,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Uploads a data chunk to the delegator contract template.
        
        Adds a call to `template_load_data(address,uint64,byte[])void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int offset: Offset in the box at which to replace the data.
        :param bytes | bytearray data: Data to replace in the box at the defined position.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = TemplateLoadDataArgs(
            val_owner=val_owner,
            offset=offset,
            data=data,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def template_load_end(
        self,
        *,
        val_owner: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Ends uploading of the delegator contract template.
        
        Adds a call to `template_load_end(address)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = TemplateLoadEndArgs(
            val_owner=val_owner,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_create(
        self,
        *,
        del_manager: str,
        del_beneficiary: str,
        rounds_duration: int,
        stake_max: int,
        partner_address: str,
        partner_commission: int,
        mbr_txn: TransactionWithSigner,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Creates a new delegator contract with the current delegation terms for the input
        delegator contract manager and delegator contract beneficiary with the specified duration.
        
        Adds a call to `contract_create(address,address,uint64,uint64,address,uint64,pay,txn)uint64` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param str del_beneficiary: Beneficiary address for the delegation contract.
        :param int rounds_duration: Contract duration in number of rounds.
        :param int stake_max: The maximum amount of ALGO that the delegator beneficiary address intends to have at any point in time during the contract duration.
        :param str partner_address: Address of the partner that collects the partner convenience fees. If there is no partner, set it to Global.zero_address.
        :param int partner_commission: Commission charged on top of validator price for partner's convenience offer. The value is represented in ppm.
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of validator ad MBR due to creation of a new contract.
        :param TransactionWithSigner txn: Transaction for the payment of the setup and operational fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractCreateArgs(
            del_manager=del_manager,
            del_beneficiary=del_beneficiary,
            rounds_duration=rounds_duration,
            stake_max=stake_max,
            partner_address=partner_address,
            partner_commission=partner_commission,
            mbr_txn=mbr_txn,
            txn=txn,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_confirm(
        self,
        *,
        del_manager: str,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys
        and pays for the operational fee.
        
        Adds a call to `keys_confirm(address,application)void` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param int del_app: The `del_app` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysConfirmArgs(
            del_manager=del_manager,
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_confirmed(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that keys of a delegator contract have not been confirmed in time.
        
        Adds a call to `keys_not_confirmed(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotConfirmedArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_not_submitted(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that keys of a delegator contract have not been submitted in time.
        
        Adds a call to `keys_not_submitted(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysNotSubmittedArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def keys_submit(
        self,
        *,
        val_manager: str,
        del_app: int,
        key_reg_txn_info: KeyRegTxnInfo,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.
        
        Adds a call to `keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])` ABI method
        
        :param str val_manager: Purported validator manager account.
        :param int del_app: App ID of the delegator contract.
        :param KeyRegTxnInfo key_reg_txn_info: Information about the generated participation keys.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = KeysSubmitArgs(
            val_manager=val_manager,
            del_app=del_app,
            key_reg_txn_info=key_reg_txn_info,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def breach_limits(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a limit breach event occurred on the delegator beneficiary.
        
        Adds a call to `breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = BreachLimitsArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def breach_pay(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a payment for the fee cannot be made from the delegator contract.
        This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
        
        Adds a call to `breach_pay(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = BreachPayArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def breach_suspended(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that the delegator beneficiary was suspended by consensus.
        
        Adds a call to `breach_suspended(application)((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = BreachSuspendedArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_claim(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Claims the operational fee up to this round from a delegator contract and
        transfers it to the validator ad as well as the commission to the platform.
        
        Adds a call to `contract_claim(application)(uint64,uint64,uint64)` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractClaimArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_expired(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a delegator contract has expired.
        
        Adds a call to `contract_expired(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractExpiredArgs(
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_withdraw(
        self,
        *,
        del_manager: str,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that a delegator has gracefully withdrawn from the contract prematurely.
        The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
        
        Adds a call to `contract_withdraw(address,application)void` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractWithdrawArgs(
            del_manager=del_manager,
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_delete(
        self,
        *,
        del_manager: str,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.
        
        Adds a call to `contract_delete(address,application)(uint64,uint64)` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractDeleteArgs(
            del_manager=del_manager,
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def contract_report_expiry_soon(
        self,
        *,
        before_expiry: int,
        report_period: int,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Reports that the contract will expire soon.
        
        Adds a call to `contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])` ABI method
        
        :param int before_expiry: How many rounds before contract end can the report be made.
        :param int report_period: How frequently can the report be made.
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = ContractReportExpirySoonArgs(
            before_expiry=before_expiry,
            report_period=report_period,
            del_app=del_app,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def gas(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """To fit more resources in app reference arrays.
        
        Adds a call to `gas()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = GasArgs()
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def get_validator_asa(
        self,
        *,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Returns information about the ASA that is or was supported by the validator ad at any point of time before
        deletion.
        
        Adds a call to `get_validator_asa(uint64)(uint64,uint64)` ABI method
        
        :param int asset_id: The `asset_id` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = GetValidatorAsaArgs(
            asset_id=asset_id,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_ad_create(
        self,
        *,
        val_owner: str,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Creates a new ValidatorAd.
        Defines validator ad owner account. Defines Noticeboard app ID to which this contract belongs to.
        
        Adds a call to `ad_create(address)uint64` ABI method
        
        :param str val_owner: Owner address for the validator ad.
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdCreateArgs(
            val_owner=val_owner,
        )
        self.app_client.compose_create(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_ad_delete(
        self,
        *,
        val_owner: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Validator owner deletes a validator ad.
        Possible only if there are no active delegators and all balances have been claimed.
        
        Adds a call to `ad_delete(address)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = AdDeleteArgs(
            val_owner=val_owner,
        )
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class ValidatorAdClient:
    """
        Ad of a validator owner to offer node running services to users.
        Users, i.e. delegators, can open requests for the service and conclude an individual delegator contract with the
        validator.
        The contract terms are defined by this ad contents at time of the creation of the delegator contract.
        The validator owner can change the ad to offer different terms for future delegator contracts.
        The validator ad smart contract also acts as an escrow account for the payment received by the validator from
        delegators for its service.
    
        Global state
        ------------
        noticeboard_app_id : UInt64
            App ID of noticeboard platform to which this contract belongs to.
    
        delegation_terms_general : DelegationTermsGeneral
            General delegation terms that validator defines and agrees to respect if a delegator concludes a delegator
            contract based on them.
        delegation_terms_balance : DelegationTermsBalance
            Requirements for delegator beneficiary balance that validator defines and agrees to respect if a delegator
            concludes a delegator contract based on them.
    
        val_owner : Account
            Validator owner account.
        val_manager : Account
            Validator manager account.
    
        val_info : ValidatorSelfDisclosure
            Self-disclosed information about the validator.
    
        state : Bytes
            State of the contract. Can be one of the following:
                CREATED - validator ad has been created.
                TEMPLATE_LOAD - validator ad is getting loaded the delegator contract template.
                TEMPLATE_LOADED - validator ad ended loading of the delegator contract template.
                SET - initial terms of validator ad have been set.
                READY - validator ad manager is ready to accept new delegators.
                NOT_READY - validator ad manager is not ready to accept new delegators.
                NOT_LIVE - validator ad owner does not want to accept new delegators.
    
        cnt_del : UInt64
            Counter of current delegators.
        cnt_del_max : UInt64
            Maximum number of delegators the validator is willing to manage simultaneously.
        del_app_list : DelAppList
            List of app ID of the currently active delegator contracts.
    
        tc_sha256 : Sha256
            Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator.
    
        total_algo_earned : UInt64
            Total amount of ALGO the validator ad has earned.
        total_algo_fees_generated : UInt64
            Total amount of ALGO the validator has generated as fees for the platform.
    
        cnt_asa : UInt64
            Counter of number of different ASAs supported by the contract.
    
        Box storage
        -----------
        asas : asa_[ASA_ID] = ValidatorASA
            Box map for storing ASA IDs that are or were supported by the validator ad at any point of time before deletion.
            Each entry is a ValidatorASA, with fields for total_earnings and total_fees_generated for that ASA.
            Keys correspond to "asa_" followed by byte representation of ASA ID.
    
        template : BOX_DELEGATOR_CONTRACT_TEMPLATE_KEY = Bytes
            Box for storing the delegator contract template.
    
        Methods
        -------
        ad_create(
            val_owner: arc4.Address,
        ) -> arc4.UInt64:
            Creates a new validator ad and returns its app ID.
    
        ad_config(
            val_owner: arc4.Address,
            val_manager: arc4.Address,
            live : arc4.Bool,
            cnt_del_max : UInt64,
        ) -> None:
            Set the operational configuration of the validator ad.
    
        ad_delete(
            val_owner: arc4.Address,
        ) -> None:
            Validator owner deletes a validator ad.
    
        ad_ready(
            val_manager: arc4.Address,
            ready: arc4.Bool,
        ) -> None:
            Ad manager sets its readiness for operation.
    
        ad_self_disclose(
            val_owner: arc4.Address,
            val_info: ValidatorSelfDisclosure,
        ) -> None:
            Ad owner sets its self-disclosure information.
    
        ad_terms(
            val_owner: arc4.Address,
            tc_sha256: Sha256,
            terms_time: ValidatorTermsTiming,
            terms_price: ValidatorTermsPricing,
            terms_stake: ValidatorTermsStakeLimits,
            terms_reqs: ValidatorTermsGating,
            terms_warn: ValidatorTermsWarnings,
            txn: gtxn.PaymentTransaction,
        ) -> None:
            Sets all the terms of the validator.
    
        ad_income(
            val_owner: arc4.Address,
            asset_id: UInt64,
        ) -> arc4.UInt64:
            Validator owner withdraws all available balance from the validator ad for the given asset.
    
        ad_asa_close(
            val_owner: arc4.Address,
            asset_id: UInt64,
        ) -> None:
            Removes the asset's storage on the validator ad.
    
        template_load_init(
            val_owner: arc4.Address,
            template_size: UInt64,
            mbr_txn: gtxn.PaymentTransaction,
        ) -> None:
            Starts the process of uploading delegator contract template.
    
        template_load_data(
            val_owner: arc4.Address,
            offset: UInt64,
            data: Bytes,
        ) -> None:
            Uploads a data chunk to the delegator contract template.
    
        template_load_end(
            val_owner: arc4.Address,
        ) -> None:
            Ends uploading of the delegator contract template.
    
        contract_create(
            del_manager: arc4.Address,
            del_beneficiary: arc4.Address,
            rounds_duration: UInt64,
            stake_max: UInt64,
            partner_address: arc4.Address,
            partner_commission: UInt64,
            mbr_txn: gtxn.PaymentTransaction,
            txn: gtxn.Transaction,
        ) -> arc4.UInt64:
            Creates a new delegator contract with the current delegation terms for the input
            delegator contract manager and delegator contract beneficiary with the specified duration.
    
        keys_confirm(
            del_manager: arc4.Address,
            del_app: Application,
        ) -> None:
            Delegator manager confirms that the keys have been confirmed by the delegator beneficiary.
    
        keys_not_confirmed(
            del_app: Application,
        ) -> Message:
            Reports that keys of a delegator contract have not been confirmed in time.
    
        keys_not_submitted(
            del_app: Application,
        ) -> Message:
            Reports that keys of a delegator contract have not been submitted in time.
    
        keys_submit(
            val_manager: arc4.Address,
            del_app: Application,
            key_reg_txn_info : KeyRegTxnInfo,
        ) -> Message:
            Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.
    
        breach_limits(
            del_app: Application,
        ) -> BreachLimitsReturn:
            Reports that a limit breach event occurred on the delegator beneficiary.
    
        breach_pay(
            del_app: Application,
        ) -> Message:
            Reports that a payment for the fee cannot be made from the delegator beneficiary.
    
        breach_suspended(
            del_app: Application,
        ) -> EarningsDistributionAndMessage:
            Reports that the delegator beneficiary was suspended by consensus.
    
        contract_claim(
            del_app: Application,
        ) -> EarningsDistribution:
            Claims and distributes the operational fee of validator up to this round to the validator and noticeboard.
    
        contract_expired(
            del_app: Application,
        ) -> Message:
            Reports that a delegator contract has expired.
    
        contract_withdraw(
            del_manager: arc4.Address,
            del_app: Application,
        ) -> None:
            Reports that a delegator has gracefully withdrawn from the delegator contract prematurely.
    
        contract_delete(
            del_manager: arc4.Address,
            del_app: Application,
        ) -> ContractDeleteReturn:
            Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.
    
        contract_report_expiry_soon(
            before_expiry: UInt64,
            report_period: UInt64,
        ) -> Message:
            Reports that the contract will expire soon.
    
        gas(
        ) -> None:
            To fit more resources in app reference arrays.
    
        Private methods
        ---------------
        _add_del_to_list(self, del_app_id: UInt64) -> bool:
            Assign created delegator contract to first free space in the list of delegator contracts.
    
        _remove_del_from_list(self, del_app_id: UInt64) -> bool:
            Remove the delegator contract from list of delegator contracts.
    
        _exists_del_in_list(self, del_app_id: UInt64) -> bool:
            Checks if a delegator contract exists in validator ad's list of delegator contracts.
    
        _mark_validator_earnings(self, earnings_distribution: EarningsDistribution) -> None:
            Mark increase in validator's earnings.
    
        
    
    A class for interacting with the ValidatorAd app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        ValidatorAdClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def get_global_state(self) -> GlobalState:
        """Returns the application's global state wrapped in a strongly typed class with options to format the stored value"""

        state = typing.cast(dict[bytes, bytes | int], self.app_client.get_global_state(raw=True))
        return GlobalState(state)

    def ad_config(
        self,
        *,
        val_owner: str,
        val_manager: str,
        live: bool,
        cnt_del_max: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Sets all operation configuration parameters for the validator ad, i.e.
        the validator manager account, the status whether the ad is live to accept new delegators (`live=True`) or not (`live=False`), and the maximum number of delegators the validators can accept.
        
        Calls `ad_config(address,address,bool,uint64)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param str val_manager: Manager address for the validator ad.
        :param bool live: Set to True if validator ad should be accepting new delegators, otherwise set to False.
        :param int cnt_del_max: Maximum number of delegators the validator is willing to manage simultaneously.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = AdConfigArgs(
            val_owner=val_owner,
            val_manager=val_manager,
            live=live,
            cnt_del_max=cnt_del_max,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def ad_ready(
        self,
        *,
        val_manager: str,
        ready: bool,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Ad manager sets its readiness for operation.
        
        Calls `ad_ready(address,bool)void` ABI method
        
        :param str val_manager: Manager address for the validator ad.
        :param bool ready: Set to True if validator manager is ready for accepting new delegators, otherwise set to False.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = AdReadyArgs(
            val_manager=val_manager,
            ready=ready,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def ad_self_disclose(
        self,
        *,
        val_owner: str,
        val_info: ValidatorSelfDisclosure,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Ad owner sets its self-disclosure information.
        
        Calls `ad_self_disclose(address,(byte[30],byte[60],byte[2],uint64,byte[20]))void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param ValidatorSelfDisclosure val_info: Self-disclosed information about the validator.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = AdSelfDiscloseArgs(
            val_owner=val_owner,
            val_info=val_info,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def ad_terms(
        self,
        *,
        val_owner: str,
        tc_sha256: bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int],
        terms_time: ValidatorTermsTiming,
        terms_price: ValidatorTermsPricing,
        terms_stake: ValidatorTermsStakeLimits,
        terms_reqs: ValidatorTermsGating,
        terms_warn: ValidatorTermsWarnings,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Sets all the terms of the validator.
        With this action, the validator agrees with the (new) terms.
        
        Calls `ad_terms(address,byte[32],(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64),((uint64,uint64)[2]),(uint64,uint64),pay)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param bytes | bytearray | tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int] tc_sha256: Hash (i.e. SHA 256) of the Terms and Conditions agreed by the validator.
        :param ValidatorTermsTiming terms_time: Validator's terms about timing.
        :param ValidatorTermsPricing terms_price: Validator's terms about pricing.
        :param ValidatorTermsStakeLimits terms_stake: Validator's terms about stake limits.
        :param ValidatorTermsGating terms_reqs: Validator's terms about gating requirements.
        :param ValidatorTermsWarnings terms_warn: Validator's terms about warnings.
        :param TransactionWithSigner txn: Transaction for the payment of MBR increase.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = AdTermsArgs(
            val_owner=val_owner,
            tc_sha256=tc_sha256,
            terms_time=terms_time,
            terms_price=terms_price,
            terms_stake=terms_stake,
            terms_reqs=terms_reqs,
            terms_warn=terms_warn,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def ad_income(
        self,
        *,
        val_owner: str,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Validator owner withdraws all available balance from the validator ad for the given asset.
        
        Calls `ad_income(address,uint64)uint64` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int asset_id: ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like to withdraw all earnings from the validator ad.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: Withdrawn income from the validator ad for the input asset."""

        args = AdIncomeArgs(
            val_owner=val_owner,
            asset_id=asset_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def ad_asa_close(
        self,
        *,
        val_owner: str,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Removes the asset's storage on the validator ad.
        To be used before deleting the contract.
        
        Calls `ad_asa_close(address,uint64)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int asset_id: ID of the asset (i.e. ASA ID or 0 for ALGO) for which the owner would like remove its storage.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = AdAsaCloseArgs(
            val_owner=val_owner,
            asset_id=asset_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def template_load_init(
        self,
        *,
        val_owner: str,
        template_size: int,
        mbr_txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Starts the process of uploading delegator contract template.
        
        Calls `template_load_init(address,uint64,pay)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int template_size: Size of the delegator contract template in bytes.
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of validator ad MBR due to creation of box for storing the delegator contract template.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = TemplateLoadInitArgs(
            val_owner=val_owner,
            template_size=template_size,
            mbr_txn=mbr_txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def template_load_data(
        self,
        *,
        val_owner: str,
        offset: int,
        data: bytes | bytearray,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Uploads a data chunk to the delegator contract template.
        
        Calls `template_load_data(address,uint64,byte[])void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param int offset: Offset in the box at which to replace the data.
        :param bytes | bytearray data: Data to replace in the box at the defined position.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = TemplateLoadDataArgs(
            val_owner=val_owner,
            offset=offset,
            data=data,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def template_load_end(
        self,
        *,
        val_owner: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Ends uploading of the delegator contract template.
        
        Calls `template_load_end(address)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = TemplateLoadEndArgs(
            val_owner=val_owner,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def contract_create(
        self,
        *,
        del_manager: str,
        del_beneficiary: str,
        rounds_duration: int,
        stake_max: int,
        partner_address: str,
        partner_commission: int,
        mbr_txn: TransactionWithSigner,
        txn: TransactionWithSigner,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Creates a new delegator contract with the current delegation terms for the input
        delegator contract manager and delegator contract beneficiary with the specified duration.
        
        Calls `contract_create(address,address,uint64,uint64,address,uint64,pay,txn)uint64` ABI method
        
        :param str del_manager: Manager address for the delegation contract.
        :param str del_beneficiary: Beneficiary address for the delegation contract.
        :param int rounds_duration: Contract duration in number of rounds.
        :param int stake_max: The maximum amount of ALGO that the delegator beneficiary address intends to have at any point in time during the contract duration.
        :param str partner_address: Address of the partner that collects the partner convenience fees. If there is no partner, set it to Global.zero_address.
        :param int partner_commission: Commission charged on top of validator price for partner's convenience offer. The value is represented in ppm.
        :param TransactionWithSigner mbr_txn: Payment transaction for the payment of the increase of validator ad MBR due to creation of a new contract.
        :param TransactionWithSigner txn: Transaction for the payment of the setup and operational fee.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: App ID of the created delegator contract application."""

        args = ContractCreateArgs(
            del_manager=del_manager,
            del_beneficiary=del_beneficiary,
            rounds_duration=rounds_duration,
            stake_max=stake_max,
            partner_address=partner_address,
            partner_commission=partner_commission,
            mbr_txn=mbr_txn,
            txn=txn,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_confirm(
        self,
        *,
        del_manager: str,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys
        and pays for the operational fee.
        
        Calls `keys_confirm(address,application)void` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param int del_app: The `del_app` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = KeysConfirmArgs(
            del_manager=del_manager,
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def keys_not_confirmed(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that keys of a delegator contract have not been confirmed in time.
        
        Calls `keys_not_confirmed(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = KeysNotConfirmedArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def keys_not_submitted(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that keys of a delegator contract have not been submitted in time.
        
        Calls `keys_not_submitted(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = KeysNotSubmittedArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def keys_submit(
        self,
        *,
        val_manager: str,
        del_app: int,
        key_reg_txn_info: KeyRegTxnInfo,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Validator manager submits the keys generated for the delegator beneficiary according to the contract terms.
        
        Calls `keys_submit(address,application,(uint64,uint64,uint64,byte[32],byte[32],byte[64],address))(address,byte[100])` ABI method
        
        :param str val_manager: Purported validator manager account.
        :param int del_app: App ID of the delegator contract.
        :param KeyRegTxnInfo key_reg_txn_info: Information about the generated participation keys.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = KeysSubmitArgs(
            val_manager=val_manager,
            del_app=del_app,
            key_reg_txn_info=key_reg_txn_info,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def breach_limits(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[BreachLimitsReturn]:
        """Reports that a limit breach event occurred on the delegator beneficiary.
        
        Calls `breach_limits(application)(bool,(uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[BreachLimitsReturn]: Boolean denoting if maximum number of breaches has already been reached (True) or not (False)."""

        args = BreachLimitsArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = BreachLimitsReturn(**result_dict)
        return result

    def breach_pay(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that a payment for the fee cannot be made from the delegator contract.
        This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
        
        Calls `breach_pay(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = BreachPayArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def breach_suspended(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]:
        """Reports that the delegator beneficiary was suspended by consensus.
        
        Calls `breach_suspended(application)((uint64,uint64,uint64),address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistributionAndMessage]: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = BreachSuspendedArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistributionAndMessage(**result_dict)
        return result

    def contract_claim(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[EarningsDistribution]:
        """Claims the operational fee up to this round from a delegator contract and
        transfers it to the validator ad as well as the commission to the platform.
        
        Calls `contract_claim(application)(uint64,uint64,uint64)` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[EarningsDistribution]: Amount of earnings of validator which equal any not yet claimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."""

        args = ContractClaimArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = EarningsDistribution(**result_dict)
        return result

    def contract_expired(
        self,
        *,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that a delegator contract has expired.
        
        Calls `contract_expired(application)(address,byte[100])` ABI method
        
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = ContractExpiredArgs(
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def contract_withdraw(
        self,
        *,
        del_manager: str,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Reports that a delegator has gracefully withdrawn from the contract prematurely.
        The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
        
        Calls `contract_withdraw(address,application)void` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = ContractWithdrawArgs(
            del_manager=del_manager,
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def contract_delete(
        self,
        *,
        del_manager: str,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[ContractDeleteReturn]:
        """Delegator deletes an ended contract, withdraws any remaining balance, and returns the MBR from ValidatorAd.
        
        Calls `contract_delete(address,application)(uint64,uint64)` ABI method
        
        :param str del_manager: Purported delegator manager account.
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[ContractDeleteReturn]: The result of the transaction"""

        args = ContractDeleteArgs(
            del_manager=del_manager,
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = ContractDeleteReturn(**result_dict)
        return result

    def contract_report_expiry_soon(
        self,
        *,
        before_expiry: int,
        report_period: int,
        del_app: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[Message]:
        """Reports that the contract will expire soon.
        
        Calls `contract_report_expiry_soon(uint64,uint64,application)(address,byte[100])` ABI method
        
        :param int before_expiry: How many rounds before contract end can the report be made.
        :param int report_period: How frequently can the report be made.
        :param int del_app: App ID of the delegator contract.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[Message]: Address of delegator manager."""

        args = ContractReportExpirySoonArgs(
            before_expiry=before_expiry,
            report_period=report_period,
            del_app=del_app,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = Message(**result_dict)
        return result

    def gas(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """To fit more resources in app reference arrays.
        
        Calls `gas()void` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = GasArgs()
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def get_validator_asa(
        self,
        *,
        asset_id: int,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[ValidatorAsa]:
        """Returns information about the ASA that is or was supported by the validator ad at any point of time before
        deletion.
        
        Calls `get_validator_asa(uint64)(uint64,uint64)` ABI method
        
        :param int asset_id: The `asset_id` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[ValidatorAsa]: Information about the payment asset that is or was accepted on the platform."""

        args = GetValidatorAsaArgs(
            asset_id=asset_id,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        elements = self.app_spec.hints[args.method()].structs["output"]["elements"]
        result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}
        result.return_value = ValidatorAsa(**result_dict)
        return result

    def create_ad_create(
        self,
        *,
        val_owner: str,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Creates a new ValidatorAd.
        Defines validator ad owner account. Defines Noticeboard app ID to which this contract belongs to.
        
        Calls `ad_create(address)uint64` ABI method
        
        :param str val_owner: Owner address for the validator ad.
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: App ID of the created validator ad application."""

        args = AdCreateArgs(
            val_owner=val_owner,
        )
        result = self.app_client.create(
            call_abi_method=args.method(),
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
            **_as_dict(args, convert_all=True),
        )
        return result

    def delete_ad_delete(
        self,
        *,
        val_owner: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[None]:
        """Validator owner deletes a validator ad.
        Possible only if there are no active delegators and all balances have been claimed.
        
        Calls `ad_delete(address)void` ABI method
        
        :param str val_owner: Owner address of the validator ad.
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[None]: The result of the transaction"""

        args = AdDeleteArgs(
            val_owner=val_owner,
        )
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: DeployCreate[AdCreateArgs],
        update_args: algokit_utils.DeployCallArgs | None = None,
        delete_args: Deploy[AdDeleteArgs],
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param DeployCreate[AdCreateArgs] create_args: Arguments used when creating an application
        :param algokit_utils.DeployCallArgs | None update_args: Arguments used when updating an application
        :param Deploy[AdDeleteArgs] delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())
