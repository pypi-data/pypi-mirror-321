"""TikZ exporter. Draws shapes using the TikZ package for LaTeX.
Sketch objects are converted to TikZ code."""

# This is a proof of concept.
# To do: This whole module needs to be restructured.

from __future__ import annotations

from math import degrees, cos, sin
from typing import List, Union
from dataclasses import dataclass, field

import numpy as np

import simetri.graphics as sg
from ..graphics.common import common_properties
from ..graphics.all_enums import (
    BackStyle,
    FontSize,
    MarkerType,
    ShadeType,
    Types,
    TexLoc,
    FrameShape,
    get_enum_value,
)
from ..canvas.style_map import shape_style_map, line_style_map, marker_style_map
from ..settings.settings import defaults, tikz_defaults
from ..helpers.geometry import homogenize
from ..graphics.sketch import TagSketch, ShapeSketch
from ..graphics.shape import Shape

from ..colors import Color


np.set_printoptions(legacy="1.21")
array = np.array


def scope_code_required(item: Union["Canvas", "Batch"]) -> bool:
    """Check if a TikZ namespace is required for the item."""
    return (
        item.blend_mode is not None
        or item.transparency_group
        or (item.clip and item.mask)
    )


@dataclass
class Tex:
    """Tex class for generating tex code."""

    begin_document: str = defaults["begin_doc"]
    end_document: str = defaults["end_doc"]
    begin_tikz: str = defaults["begin_tikz"]
    end_tikz: str = defaults["end_tikz"]
    packages: List[str] = None
    tikz_libraries: List[str] = None
    tikz_code: str = ""  # Generated by the canvas by using sketches
    sketches: List["Sketch"] = field(default_factory=list)  # List of TexSketch objects

    def __post_init__(self):
        self.type = Types.TEX
        if self.packages is None:
            self.packages = defaults["packages"].copy()
        if self.tikz_libraries is None:
            self.tikz_libraries = defaults["tikz_libraries"].copy()
            # tikz_libraries should be determined at the end!!!
        common_properties(self)

    def tex_code(self, canvas: "Canvas", aux_code: str) -> str:
        """Generate the final TeX code."""
        doc_code = []
        for sketch in self.sketches:
            if sketch.location == TexLoc.DOCUMENT:
                doc_code.append(sketch.code)
        doc_code = "\n".join(doc_code)
        back_color = f"\\pagecolor{color2tikz(canvas.back_color)}"
        self.begin_document = self.begin_document + back_color + "\n"
        if canvas.limits is not None:
            begin_tikz = self.begin_tikz + get_limits_code(canvas) + "\n"
        else:
            begin_tikz = self.begin_tikz + "\n"
        if scope_code_required(canvas):
            scope = get_canvas_scope(canvas)
            code = (
                self.get_preamble(canvas)
                + self.begin_document
                + doc_code
                + begin_tikz
                + scope
                + self.get_tikz_code()
                + aux_code
                + "\\end{scope}\n"
                + self.end_tikz
                + self.end_document
            )
        else:
            code = (
                self.get_preamble(canvas)
                + self.begin_document
                + doc_code
                + begin_tikz
                + self.get_tikz_code()
                + aux_code
                + self.end_tikz
                + self.end_document
            )

        return code

    def get_doc_class(self, border: float, font_size: int) -> str:
        """Returns the document class."""
        return f"\\documentclass[{font_size}pt,tikz,border={border}pt]{{standalone}}\n"

    def get_tikz_code(self) -> str:
        """Returns the TikZ code."""
        code = ""
        for sketch in self.sketches:
            if sketch.location == TexLoc.PICTURE:
                code += sketch.text + "\n"

        return code

    def get_tikz_libraries(self) -> str:
        """Returns the TikZ libraries."""
        return f"\\usetikzlibrary{{{','.join(self.tikz_libraries)}}}\n"

    def get_preamble(self, canvas) -> str:
        """Returns the TeX preamble."""
        packages = f'\\usepackage{{{",".join(self.packages)}}}\n'
        libraries = f'\\usetikzlibrary{{{",".join(self.tikz_libraries)}}}\n'
        fonts_section = f"""\\usepackage{{fontspec}}
\\setmainfont{{{defaults['main_font']}}}
\\setsansfont{{{defaults['sans_font']}}}
\\setmonofont{{{defaults['mono_font']}}}\n"""
        if canvas.border is None:
            border = defaults["border"]
        elif isinstance(canvas.border, (int, float)):
            border = canvas.border
        else:
            raise ValueError("Canvas.border must be a positive numeric value.")
        if border < 0:
            raise ValueError("Canvas.border must be a positive numeric value.")
        doc_class = self.get_doc_class(border, defaults["font_size"])
        # Check if different fonts are used
        fonts = canvas.get_fonts_list()
        for font in fonts:
            if font is None:
                continue
            font_name = font.replace(" ", "")
            fonts_section += f"\\newfontfamily\\{font_name}[Scale=1.0]{{{font}}}\n"
        preamble = f"{doc_class}{packages}{libraries}{fonts_section}"

        indices = False
        for sketch in canvas.active_page.sketches:
            if hasattr(sketch, "marker_type") and sketch.marker_type == "indices":
                indices = True
                break
        if indices:
            font_family = defaults["indices_font_family"]
            font_size = defaults["indices_font_size"]
            count = 0
            for sketch in canvas.active_page.sketches:
                if hasattr(sketch, "marker_type") and sketch.marker_type == "indices":
                    preamble += "\\tikzset{\n"
                    node_style = (
                        f"nodestyle{count}/.style={{draw, circle, gray, "
                        f"text=black, fill=white, line width = .5, inner sep=.5, "
                        f"font=\\{font_family}\\{font_size}}}\n}}\n"
                    )
                    preamble += node_style
                    count += 1

        return preamble


def get_back_grid_code(grid: Grid, canvas: "Canvas") -> str:
    """Page background grid code."""
    # \usetikzlibrary{backgrounds}
    # \begin{scope}[on background layer]
    # \fill[gray] (current bounding box.south west) rectangle
    # (current bounding box.north east);
    # \draw[white,step=.5cm] (current bounding box.south west) grid
    # (current bounding box.north east);
    # \end{scope}
    grid = canvas.active_page.grid
    back_color = color2tikz(grid.back_color)
    line_color = color2tikz(grid.line_color)
    step = grid.spacing
    lines = ["\\begin{scope}[on background layer]\n"]
    lines.append(f"\\fill[color={back_color}] (current bounding box.south west) ")
    lines.append("rectangle (current bounding box.north east);\n")
    options = []
    if grid.line_dash_array is not None:
        options.append(f"dashed, dash pattern={get_dash_pattern(grid.line_dash_array)}")
    if grid.line_width is not None:
        options.append(f"line width={grid.line_width}")
    if options:
        options = ",".join(options)
        lines.append(f"\\draw[color={line_color}, step={step}, {options}]")
    else:
        lines.append(f"\\draw[color={line_color},step={step}]")
    lines.append("(current bounding box.south west)")
    lines.append(" grid (current bounding box.north east);\n")
    lines.append("\\end{scope}\n")

    return "".join(lines)


def get_limits_code(canvas: "Canvas") -> str:
    """Get the limits of the canvas for clipping."""
    xmin, ymin, xmax, ymax = canvas.limits
    points = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
    vertices = homogenize(points) @ canvas.xform_matrix
    coords = " ".join([f"({v[0]}, {v[1]})" for v in vertices])

    return f"\\clip plot[] coordinates {{{coords}}};\n"


def get_back_code(canvas: "Canvas") -> str:
    """Get the background code for the canvas."""
    back_color = color2tikz(canvas.back_color)
    return f"\\pagecolor{back_color}\n"


def get_tex_code(canvas: "Canvas") -> str:
    """Convert the sketches in the Canvas to TikZ code."""

    def get_sketch_code(sketch, canvas, ind):
        """Get the TikZ code for a sketch."""
        if sketch.subtype == Types.TAGSKETCH:
            code = draw_tag_sketch(sketch, canvas)
        else:
            if sketch.draw_markers and sketch.marker_type == MarkerType.INDICES:
                code = draw_shape_sketch(sketch, ind)
                ind += 1
            else:
                code = draw_shape_sketch(sketch)

        return code, ind

    pages = canvas.pages

    if pages:
        for i, page in enumerate(pages):
            sketches = page.sketches
            back_color = f"\\pagecolor{color2tikz(page.back_color)}"
            if i == 0:
                code = [back_color]
            else:
                code.append(defaults["end_tikz"])
                code.append("\\newpage")
                code.append(defaults["begin_tikz"])
            ind = 0
            for sketch in sketches:
                sketch_code, ind = get_sketch_code(sketch, canvas, ind)
                code.append(sketch_code)

        code = "\n".join(code)
    else:
        raise ValueError("No pages found in the canvas.")
    return canvas.tex.tex_code(canvas, code)


class Grid(sg.Shape):
    """Grid shape."""

    def __init__(self, p1, p2, dx, dy, **kwargs):
        """
        p1: (x_min, y_min)
        p2: (x_max, y_max)
        dx: x step
        dy y step
        """
        self.p1 = p1
        self.p2 = p2
        self.dx = dx
        self.dy = dy
        self.primary_points = sg.Points([p1, p2])
        self.closed = False
        self.fill = False
        self.stroke = True
        self._b_box = None
        super().__init__([p1, p2], xform_matrix=None, subtype=sg.Types.GRID, **kwargs)


# fonts can be


def get_font(tag: TagSketch) -> str:
    """Get the font."""
    if tag.font not in [
        None,
        "",
        defaults["main_font"],
        defaults["sans_font"],
        defaults["mono_font"],
    ]:
        font = tag.font
    else:
        font = ""
    return font


def get_font_size(tag: TagSketch) -> Union[str, float]:
    """Get the font size."""
    font_size = defaults["font_size"]
    if isinstance(tag.font_size, (float, int)):
        font_size = tag.font_size
    elif isinstance(tag.font_size, FontSize):
        font_size = tag.font_size.value
    return font_size


def get_font_color(tag: TagSketch) -> str:
    """Get the font color."""
    if tag.font_color not in [None, "", defaults["font_color"]]:
        font_color = color2tikz(tag.font_color)
    else:
        font_color = ""
    return font_color


def get_min_size(sketch: ShapeSketch) -> str:
    """Returns the minimum size of the tag node."""
    options = []
    if sketch.frame_shape == "rectangle":
        if sketch.frame_min_width is None:
            width = defaults["min_width"]
        else:
            width = sketch.frame_min_width
        if sketch.frame_min_height is None:
            height = defaults["min_height"]
        else:
            height = sketch.frame_min_height
        options.append(f"minimum width = {width}")
        options.append(f"minimum height = {height}")
    else:
        if sketch.frame_min_size is None:
            min_size = defaults["min_size"]
        else:
            min_size = sketch.frame_min_size
        options.append(f"minimum size = {min_size}")

    return options


def font_details(sketch: TagSketch) -> str:
    """Returns the font details for the tag node."""
    font_size = get_font_size(sketch)
    brace_count = 0
    default_fonts = [
        defaults["main_font"],
        defaults["sans_font"],
        defaults["mono_font"],
    ]
    alias = None
    command = ""

    d_families = {
        defaults["main_font"]: "",
        defaults["sans_font"]: "\\textsf{",
        defaults["mono_font"]: "\\texttt{",
    }
    if sketch.font_name not in default_fonts and sketch.font_name:
        alias = sketch.font_name.replace(" ", "")
    else:
        if sketch.font_name in default_fonts:
            command = d_families[sketch.font_name]
            brace_count += 1

    if font_size in FontSize:
        command += f"\\{font_size}{{"
        brace_count += 1

    attrib_map = {
        "bold": "\\textbf{",
        "italic": "\\textit{",
        "small_caps": "\\textsc{",
        "underline": "\\underline{",
        "overline": "\\textoverline{",
        "strike_through": "\\st{",
    }
    styles = ["bold", "italic", "small_caps", "underline", "overline", "strike_through"]

    for style in styles:
        if getattr(sketch, style):
            command += attrib_map[style]
            brace_count += 1

    font_color = get_font_color(sketch)

    return command, alias, brace_count, font_size, font_color


def frame_options(sketch: TagSketch) -> List[str]:
    """Returns the options for the frame of the tag node."""
    options = []
    if sketch.draw_frame:
        options.append(sketch.frame_shape)
        line_options = get_line_style_options(sketch, frame=True)
        if line_options:
            options.extend(line_options)
        fill_options = get_fill_style_options(sketch, frame=True)
        if fill_options:
            options.extend(fill_options)
        if sketch.text in [None, ""]:
            min_size = get_min_size(sketch)
            if min_size:
                options.extend(min_size)

    return options


def color2tikz(color):
    """Converts a Color object to a TikZ color string."""
    # \usepackage{xcolor}
    # \tikz\node[rounded corners, fill={rgb,255:red,21; green,66; blue,128},
    #                                    text=white, draw=black] {hello world};
    # \definecolor{mycolor}{rgb}{1,0.2,0.3}
    # \definecolor{mycolor}{R_g_b}{255,51,76}
    # \definecolor{mypink1}{rgb}{0.858, 0.188, 0.478}
    # \definecolor{mypink2}{R_g_b}{219, 48, 122}
    # \definecolor{mypink3}{cmyk}{0, 0.7808, 0.4429, 0.1412}
    # \definecolor{mygray}{gray}{0.6}
    if color is None:
        r, g, b, _ = 255, 255, 255, 255
        return f"{{rgb,255:red,{r}; green,{g}; blue,{b}}}"
    r, g, b = color.rgb255

    return f"{{rgb,255:red,{r}; green,{g}; blue,{b}}}"


def get_scope_options(item: Union["Canvas", "Sketch"]) -> str:
    """Used for creating namespaces in TikZ."""
    options = []

    if item.blend_group:
        options.append(f"blend group={item.blend_mode}")
    elif item.blend_mode:
        options.append(f"blend mode={item.blend_mode}")
    if item.fill_alpha not in [None, 1]:
        options.append(f"fill opacity={item.fill_alpha}")
    if item.line_alpha not in [None, 1]:
        options.append(f"draw opacity={item.line_alpha}")
    if item.text_alpha not in [None, 1]:
        options.append(f"text opacity={item.alpha}")
    if item.alpha not in [None, 1]:
        options.append(f"opacity={item.alpha}")
    if item.even_odd_rule:
        options.append("even odd rule")
    if item.transparency_group:
        options.append("transparency group")

    return ",".join(options)


def get_clip_code(item: Union["Sketch", "Canvas"]) -> str:
    """Returns the clip code for a sketch or Canvas."""
    if item.mask.subtype == Types.CIRCLE:
        x, y = item.mask.center
        res = f"\\clip({x}, {y}) circle ({item.mask.radius});\n"
    elif item.mask.subtype == Types.RECTANGLE:
        x, y = item.mask.center
        width, height = item.mask.width, item.mask.height
        res = f"\\clip({x}, {y}) rectangle ({width}, {height});\n"
    elif item.mask.subtype == Types.SHAPE:
        vertices = item.mask.primary_points.homogen_coords
        coords = " ".join([f"({v[0]}, {v[1]})" for v in vertices])
        res = f"\\clip plot[] coordinates {{{coords}}};\n"
    else:
        res = ""

    return res


def get_canvas_scope(canvas):
    """Returns the TikZ code for the canvas scope."""
    options = get_scope_options(canvas)
    res = f"\\begin{{scope}}[{options}]\n"
    if canvas.clip and canvas.mask:
        res += get_clip_code(canvas)

    return res


def draw_batch_sketch(sketch, canvas):
    """Converts a BatchSketch to TikZ code."""
    options = get_scope_options(sketch)
    res = f"\\begin{{scope}}[{options}]\n"
    if sketch.clip and sketch.mask:
        res += get_clip_code(sketch)
    for item in sketch.items:
        if item.subtype in d_sketch_draw:
            res += d_sketch_draw[item.subtype](item, canvas)
        else:
            raise ValueError(f"Sketch type {item.subtype} not supported.")

    if sketch.clip and sketch.mask:
        res += get_clip_code(sketch)
    res += "\\end{scope}\n"

    return res


def draw_lace_sketch(item):
    """Converts a LaceSketch to TikZ code."""
    if item.draw_fragments:
        for fragment in item.fragments:
            draw_shape_sketch(fragment)
    if item.draw_plaits:
        for plait in item.plaits:
            plait.fill = True
            draw_shape_sketch(plait)


def get_draw(sketch):
    """Returns the draw command for sketches."""
    # sketch.closed, sketch.fill, sketch.stroke, shading
    decision_table = {
        (True, True, True, True): "\\shadedraw",
        (True, True, True, False): "\\filldraw",
        (True, True, False, True): "\\shade",
        (True, True, False, False): "\\fill",
        (True, False, True, True): "\\draw",
        (True, False, True, False): "\\draw",
        (True, False, False, True): False,
        (True, False, False, False): False,
        (False, True, True, True): "\\draw",
        (False, True, True, False): "\\draw",
        (False, True, False, True): False,
        (False, True, False, False): False,
        (False, False, True, True): "\\draw",
        (False, False, True, False): "\\draw",
        (False, False, False, True): False,
        (False, False, False, False): False,
    }
    if sketch.markers_only:
        res = "\\draw"
    else:
        shading = sketch.back_style == BackStyle.SHADING
        res = decision_table[(sketch.closed, sketch.fill, sketch.stroke, shading)]

    return res


def get_frame_options(sketch):
    """Returns the options for the frame of a TagSketch."""
    options = get_line_style_options(sketch)
    options += get_fill_style_options(sketch)
    if sketch.text in [None, ""]:
        if sketch.frame.frame_shape == "rectangle":
            width = sketch.frame.min_width
            height = sketch.frame.min_height
            if not width:
                width = defaults["min_width"]
            if not height:
                height = defaults["min_height"]
            options += "minimum width = {width}, minimum height = {height}"
        else:
            size = sketch.frame.min_size
            if not size:
                size = defaults["min_size"]
            options += f"minimum size = {size}"
    return options


def draw_tag_sketch_(sketch, canvas):
    """Converts a TagSketch to TikZ code."""
    # \node at (0,0) {some text};
    # x, y = sketch.pos[:2]
    pos = homogenize(sketch.pos) @ canvas.xform_matrix
    x, y = pos[0][:2]
    # \fontsize{32}{38}\selectfont
    # f"\\node at ({x}, {y}) {{{text}}};\n" +
    res = ""
    color = ""
    if sketch.font_color is not None:
        color = f"[text={color2tikz(sketch.font_color)}] "
    if sketch.back_color is not None:
        back_color = color2tikz(sketch.back_color)
        back_color = f"[fill={back_color}]"
    else:
        back_color = ""

    if sketch.font_size is None or sketch.font_size == defaults["font_size"]:
        # res += f"\\node at ({x}, {y}) {{{text}}};\n"
        res += f"\\node{back_color} {color} at ({x}, {y}) {{{sketch.text}}};\n"
    elif sketch.font or sketch.font_size or sketch.font_color:
        alias = sketch.font.replace(" ", "")
        text = sketch.text
        font_size = sketch.font_size
        skip = int(font_size * 1.2)  # baseline skip
        if sketch.font_color:
            color = color2tikz(sketch.font_color)
            res = (
                f"\\node [text={color}] at ({x}, {y}) "
                f"{{\\fontsize{{{font_size}}}{{{skip}}}\\selectfont\\{alias} {text}}};"
            )
        else:
            res = (
                f"\\node at ({x}, {y}) {{\\fontsize{{{font_size}}}{{{skip}}}"
                f"\\selectfont\\{alias} {text}}};"
            )
    else:
        res += (
            f"\\node{back_color} {color} at ({x}, {y}) {{\\fontsize{{{sketch.font_size}}}"
            f"{{{sketch.font_size * 1.2}}}\\selectfont {sketch.text}}};\n"
        )

    return res


def draw_tag_sketch(sketch, canvas):
    """Converts a TagSketch to TikZ code."""
    # \node at (0,0) {some text};
    pos = homogenize(sketch.pos) @ canvas.xform_matrix
    x, y = pos[0][:2]

    options = ""
    if sketch.draw_frame:
        options += "draw"
        if sketch.stroke:
            if sketch.frame_shape != FrameShape.RECTANGLE:
                options += f", {sketch.frame_shape}"
            if sketch.line_width:  # defaults['line_width']
                options += f", line width={sketch.line_width}"
            if sketch.line_color:
                options += f", color={color2tikz(sketch.line_color)}"
            if sketch.line_dash_array:
                options += f", dash pattern={get_dash_pattern(sketch.line_dash_array)}"
    if sketch.fill and sketch.back_color:
        options += f", fill={color2tikz(sketch.frame_back_color)}"
    if sketch.anchor:
        options += f", anchor={sketch.anchor.value}"
    # #\fontsize{32}{38}\selectfont
    # # f"\\node at ({x}, {y}) {{{sketch.text}}};\n" +
    if sketch.font_color is not None:
        text = f"{{\\textcolor{color2tikz(sketch.font_color)}{{{sketch.text}}}}}"
    else:
        text = f"{{{sketch.text}}}"
    res = ""
    # if sketch.font:
    #     res = f"\\fontspec{{{sketch.font}}};\n"
    if sketch.font_size is None or sketch.font_size == defaults["font_size"]:
        #     #res += f"\\node at ({x}, {y}) {{{sketch.text}}};\n"
        res += f"\\node[{options}] at ({x}, {y}) {text};\n"
    else:
        #     # res += (f"\\node at ({x}, {y}) {{\\fontsize{{{sketch.font_size}}}"
        #     #        f"{{{sketch.font_size * 1.2}}}\selectfont {{{sketch.text}}}}};\n")
        res += (
            f"\\node[{options}] at ({x}, {y}) {{\\fontsize{{{sketch.font_size}}}"
            f"{{{sketch.font_size * 1.2}}}\\selectfont {text}}};\n"
        )

    return res


def get_dash_pattern(line_dash_array):
    """Returns the dash pattern for a line."""
    dash_pattern = []
    for i, dash in enumerate(line_dash_array):
        if i % 2 == 0:
            dash_pattern.extend(["on", f"{dash}pt"])
        else:
            dash_pattern.extend(["off", f"{dash}pt"])

    return " ".join(dash_pattern)


def sg_to_tikz(sketch, attrib_list, attrib_map, conditions=None, exceptions=None):
    """Converts the attributes of a sketch to TikZ options."""
    skip = ["marker_color", "fill_color"]
    if exceptions:
        skip += exceptions
    d_converters = {
        "line_color": color2tikz,
        "fill_color": color2tikz,
        "draw": color2tikz,
        "line_dash_array": get_dash_pattern,
    }
    options = []
    for attrib in attrib_list:
        if attrib not in attrib_map:
            continue
        if conditions and attrib in conditions and not conditions[attrib]:
            continue
        tikz_attrib = attrib_map[attrib]
        if hasattr(sketch, attrib):
            value = getattr(sketch, attrib)
            if value is not None and tikz_attrib in list(attrib_map.values()):
                if attrib in skip:
                    value = color2tikz(getattr(sketch, attrib))
                    options.append(f"{tikz_attrib}={value}")
                elif value != tikz_defaults[tikz_attrib]:
                    if attrib in d_converters:
                        value = d_converters[attrib](value)
                    options.append(f"{tikz_attrib}={value}")

    return options


def get_line_style_options(sketch, exceptions=None, frame=False):
    """Returns the options for the line style."""
    attrib_map = {
        "line_color": "color",
        "line_width": "line width",
        "line_dash_array": "dash pattern",
        "line_cap": "line cap",
        "line_join": "line join",
        "line_miter_limit": "miter limit",
        "line_dash_phase": "dash phase",
        "line_alpha": "draw opacity",
        "smooth": "smooth",
        "fillet_radius": "rounded corners",
    }
    if frame:
        exceptions = ["line_color"]
        attribs = list(line_style_map.keys())
        attribs.remove("line_color")
    else:
        attribs = list(line_style_map.keys())
    if sketch.stroke:
        if exceptions and "draw_fillets" not in exceptions:
            conditions = {"fillet_radius": sketch.draw_fillets}
        elif frame:
            conditions = {"fillet_radius": sketch.draw_fillets}
        else:
            conditions = None
        if sketch.line_alpha not in [None, 1]:
            sketch.line_alpha = sketch.line_alpha
        elif sketch.alpha not in [None, 1]:
            sketch.fill_alpha = sketch.alpha
        else:
            attribs.remove("line_alpha")
        if not sketch.smooth:
            attribs.remove("smooth")
        res = sg_to_tikz(sketch, attribs, attrib_map, conditions, exceptions)
        if frame:
            res = [f"draw = {color2tikz(getattr(sketch, 'line_color'))}"] + res

    else:
        res = []

    return res


def get_fill_style_options(sketch, exceptions=None, frame=False):
    """Returns the options for the fill style."""
    attrib_map = {
        "fill_color": "fill",
        "fill_alpha": "fill opacity",
        #'fill_mode': 'even odd rule',
        "blend_mode": "blend mode",
        "frame_back_color": "fill",
    }
    attribs = list(shape_style_map.keys())
    if sketch.fill_alpha not in [None, 1]:
        sketch.fill_alpha = sketch.fill_alpha
    elif sketch.alpha not in [None, 1]:
        sketch.fill_alpha = sketch.alpha
    else:
        attribs.remove("fill_alpha")
    if sketch.fill and not sketch.back_style == BackStyle.PATTERN:
        res = sg_to_tikz(sketch, attribs, attrib_map, exceptions=exceptions)
        if frame:
            res = [f"fill = {color2tikz(getattr(sketch, 'frame_back_color'))}"] + res
    else:
        res = []

    return res


def get_axis_shading_colors(sketch):
    """Returns the shading colors for the axis."""

    def get_color(color, color_key):
        if isinstance(color, Color):
            res = color2tikz(color)
        else:
            res = defaults[color_key]

        return res

    left = get_color(sketch.shade_left_color, "shade_left_color")
    right = get_color(sketch.shade_right_color, "shade_right_color")
    top = get_color(sketch.shade_top_color, "shade_top_color")
    bottom = get_color(sketch.shade_bottom_color, "shade_bottom_color")
    middle = get_color(sketch.shade_middle_color, "shade_middle_color")

    axis_colors = {
        ShadeType.AXIS_BOTTOM_MIDDLE: f"bottom color={bottom}, middle color={middle}",
        ShadeType.AXIS_LEFT_MIDDLE: f"left color={left}, middle color={middle}",
        ShadeType.AXIS_RIGHT_MIDDLE: f"right color={right}, middle color={middle}",
        ShadeType.AXIS_TOP_MIDDLE: f"top color={top}, middle color={middle}",
        ShadeType.AXIS_LEFT_RIGHT: f"left color={left}, right color={right}",
        ShadeType.AXIS_TOP_BOTTOM: f"top color={top}, bottom color={bottom}",
    }

    res = axis_colors[sketch.shade_type]
    return res


def get_bilinear_shading_colors(sketch):
    """Returns the shading colors for the bilinear shading."""

    res = []
    if sketch.shade_upper_left_color:
        res.append(f"upper left = {color2tikz(sketch.shade_upper_left_color)}")
    if sketch.shade_upper_right_color:
        res.append(f"upper right = {color2tikz(sketch.shade_upper_right_color)}")
    if sketch.shade_lower_left_color:
        res.append(f"lower left = {color2tikz(sketch.shade_lower_left_color)}")
    if sketch.shade_lower_right_color:
        res.append(f"lower right = {color2tikz(sketch.shade_lower_right_color)}")

    return ", ".join(res)


def get_radial_shading_colors(sketch):
    """Returns the shading colors for the radial shading."""
    res = []
    if sketch.shade_type == ShadeType.RADIAL_INNER:
        res.append(f"inner color = {color2tikz(sketch.shade_inner_color)}")
    elif sketch.shade_type == ShadeType.RADIAL_OUTER:
        res.append(f"outer color = {color2tikz(sketch.shade_outer_color)}")
    elif sketch.shade_type == ShadeType.RADIAL_INNER_OUTER:
        res.append(f"inner color = {color2tikz(sketch.shade_inner_color)}")
        res.append(f"outer color = {color2tikz(sketch.shade_outer_color)}")

    return ", ".join(res)


axis_shading_types = [
    ShadeType.AXIS_BOTTOM_MIDDLE,
    ShadeType.AXIS_LEFT_MIDDLE,
    ShadeType.AXIS_RIGHT_MIDDLE,
    ShadeType.AXIS_TOP_MIDDLE,
    ShadeType.AXIS_LEFT_RIGHT,
    ShadeType.AXIS_TOP_BOTTOM,
]

radial_shading_types = [
    ShadeType.RADIAL_INNER,
    ShadeType.RADIAL_OUTER,
    ShadeType.RADIAL_INNER_OUTER,
]


def get_shading_options(sketch):
    """Returns the options for the shading."""
    shade_type = sketch.shade_type
    if shade_type in axis_shading_types:
        res = get_axis_shading_colors(sketch)
        if sketch.shade_axis_angle:
            res += f", shading angle={sketch.shade_axis_angle}"
    elif shade_type == ShadeType.BILINEAR:
        res = get_bilinear_shading_colors(sketch)
    elif shade_type in radial_shading_types:
        res = get_radial_shading_colors(sketch)
    elif shade_type == ShadeType.BALL:
        res = f"ball color = {color2tikz(sketch.shade_ball_color)}"
    elif shade_type == ShadeType.COLORWHEEL:
        res = "shading=color wheel"
    elif shade_type == ShadeType.COLORWHEEL_BLACK:
        res = "shading=color wheel black center"
    elif shade_type == ShadeType.COLORWHEEL_WHITE:
        res = "shading=color wheel white center"

    return [res]


def get_pattern_options(sketch):
    """Returns the options for the patterns."""
    pattern_type = sketch.pattern_type
    if pattern_type:
        distance = sketch.pattern_distance
        options = f"pattern={{{pattern_type}[distance={distance}, "
        angle = degrees(sketch.pattern_angle)
        if angle:
            options += f"angle={angle}, "
        line_width = sketch.pattern_line_width
        if line_width:
            options += f"line width={line_width}, "
        x_shift = sketch.pattern_x_shift
        if x_shift:
            options += f"xshift={x_shift}, "
        y_shift = sketch.pattern_y_shift
        if y_shift:
            options += f"yshift={y_shift}, "
        if pattern_type in ["Stars", "Dots"]:
            radius = sketch.pattern_radius
            if radius:
                options += f"radius={radius}, "
            if pattern_type == "Stars":
                points = sketch.pattern_points
                if points:
                    options += f"points={points}, "
        options = options.strip()
        if options.endswith(","):
            options = options[:-1]
        options += "]"
        color = sketch.pattern_color
        if color and color != sg.black:
            options += f", pattern color={color2tikz(color)}, "

        options += "}"
        res = [options]
    else:
        res = []

    return res


def get_marker_options(sketch):
    """Returns the options for the markers."""
    attrib_map = {
        # 'marker': 'mark',
        "marker_size": "mark size",
        "marker_angle": "rotate",
        # 'fill_color': 'color',
        "marker_color": "color",
        "marker_fill": "fill",
        "marker_opacity": "opacity",
        "marker_repeat": "mark repeat",
        "marker_phase": "mark phase",
        "marker_tension": "tension",
        "marker_line_width": "line width",
        "marker_line_style": "style",
        # 'line_color': 'line color',
    }
    # if mark_stroke is false make line color same as fill color
    if sketch.draw_markers:
        res = sg_to_tikz(sketch, marker_style_map.keys(), attrib_map)
    else:
        res = []

    return res


def draw_shape_sketch_with_indices(sketch, ind):
    """Draws a shape sketch with circle markers with index numbers in them."""
    begin_scope = get_begin_scope(ind)
    body = get_draw(sketch)
    options = get_line_style_options(sketch)
    if sketch.fill and sketch.closed:
        options += get_fill_style_options(sketch)
    if sketch.smooth:
        if sketch.closed:
            options += ["smooth cycle"]
        else:
            options += ["smooth"]
    options = ", ".join(options)
    body += f"[{options}]"
    vertices = [str(x) for x in sketch.vertices]
    str_lines = [vertices[0] + "node{0}"]
    n = len(vertices)
    for i, vertice in enumerate(vertices[1:]):
        if (i + 1) % 6 == 0:
            if i == n - 1:
                str_lines.append(f" -- {vertice} node{{{i+1}}}\n")
            else:
                str_lines.append(f"\n\t-- {vertice} node{{{i+1}}}")
        else:
            str_lines.append(f"-- {vertice} node{{{i+1}}}")
    if sketch.closed:
        str_lines.append(" -- cycle;\n")
    str_lines.append(";\n")
    end_scope = get_end_scope()

    return begin_scope + body + "".join(str_lines) + end_scope


def draw_shape_sketch_with_markers(sketch):
    """Draws a shape sketch with markers."""
    # begin_scope = get_begin_scope()
    body = get_draw(sketch)
    options = get_line_style_options(sketch)
    if sketch.fill and sketch.closed:
        options += get_fill_style_options(sketch)
    if sketch.smooth and sketch.closed:
        options += ["smooth cycle"]
    elif sketch.smooth:
        options += ["smooth"]
    options = ", ".join(options)
    if options:
        body += f"[{options}]"
    if sketch.draw_markers:
        marker_options = ", ".join(get_marker_options(sketch))
    else:
        marker_options = ""

    vertices = [str(x) for x in sketch.vertices]

    str_lines = [vertices[0]]
    for i, vertice in enumerate(vertices[1:]):
        if (i + 1) % 6 == 0:
            str_lines.append(f"\n\t{vertice} ")
        else:
            str_lines.append(f" {vertice} ")
    if sketch.closed:
        str_lines.append(f" {vertices[0]}")
    coordinates = "".join(str_lines)
    marker = get_enum_value(MarkerType, sketch.marker_type)
    # marker = sketch.marker_type.value
    if sketch.markers_only:
        markers_only = "only marks ,"
    else:
        markers_only = ""
    if sketch.draw_markers and marker_options:
        body += (
            f" plot[mark = {marker}, {markers_only}mark options = {{{marker_options}}}] "
            f"\ncoordinates {{{coordinates}}};\n"
        )
    elif sketch.draw_markers:
        body += (
            f" plot[mark = {marker}, {markers_only}] coordinates {{{coordinates}}};\n"
        )
    else:
        body += f" plot[tension=.5] coordinates {{{coordinates}}};\n"

    return body


def get_begin_scope(ind=None):
    """Returns \begin{scope}[every node/.append style=nodestyle{ind}]."""
    if ind is None:
        res = "\\begin{scope}[]\n"
    else:
        res = f"\\begin{{scope}}[every node/.append style=nodestyle{ind}]\n"

    return res


def get_end_scope():
    """Returns \\end{scope}."""
    return "\\end{scope}\n"


def draw_sketch(sketch):
    """Draws a plain shape sketch."""
    res = get_draw(sketch)
    if not res:
        return ""
    options = []

    if sketch.back_style == BackStyle.PATTERN and sketch.fill and sketch.closed:
        options += get_pattern_options(sketch)
    if sketch.stroke:
        options += get_line_style_options(sketch)
    if sketch.closed and sketch.fill:
        options += get_fill_style_options(sketch)
    if sketch.smooth:
        options += ["smooth"]
    if sketch.back_style == BackStyle.SHADING and sketch.fill and sketch.closed:
        options += get_shading_options(sketch)
    options = ", ".join(options)
    if options:
        res += f"[{options}]"
    vertices = sketch.vertices
    n = len(vertices)
    str_lines = [f"{vertices[0]}"]
    for i, vertice in enumerate(vertices[1:]):
        if (i + 1) % 4 == 0:
            if i == n - 1:
                str_lines.append(f"-- {vertice} \n")
            else:
                str_lines.append(f"\n\t-- {vertice} ")
        else:
            str_lines.append(f"-- {vertice} ")
    if sketch.closed:
        str_lines.append("-- cycle;\n")
    else:
        str_lines.append(";\n")
    if res:
        res += "".join(str_lines)
    else:
        res = "".join(str_lines)
    return res


def draw_shape_sketch(sketch, ind=None):
    """Draws a shape sketch."""
    d_subtype_draw = {
        sg.Types.ARCSKETCH: draw_arc_sketch,
        sg.Types.CIRCLESKETCH: draw_circle_sketch,
        sg.Types.ELLIPSESKETCH: draw_ellipse_sketch,
        sg.Types.LINESKETCH: draw_line_sketch,
    }
    if sketch.subtype in d_subtype_draw:
        res = d_subtype_draw[sketch.subtype](sketch)
    elif sketch.draw_markers and sketch.marker_type == MarkerType.INDICES:
        res = draw_shape_sketch_with_indices(sketch, ind)
    elif sketch.draw_markers or sketch.smooth:
        res = draw_shape_sketch_with_markers(sketch)
    else:
        res = draw_sketch(sketch)

    return res


def draw_line_sketch(sketch):
    """Draws a line sketch."""
    begin_scope = get_begin_scope()
    res = "\\draw"
    exceptions = ["draw_fillets", "fillet_radius", "line_join", "line_miter_limit"]
    options = get_line_style_options(sketch, exceptions=exceptions)

    start = sketch.vertices[0]
    end = sketch.vertices[1]
    options = ", ".join(options)
    res += f"[{options}]"
    res += f" {start[:2]} -- {end[:2]};\n"
    end_scope = get_end_scope()

    return begin_scope + res + end_scope


def draw_circle_sketch(sketch):
    """Draws a circle sketch."""
    begin_scope = get_begin_scope()
    res = get_draw(sketch)
    options = get_line_style_options(sketch)
    fill_options = get_fill_style_options(sketch)
    options += fill_options
    if sketch.smooth:
        options += ["smooth"]
    options = ", ".join(options)
    res += f"[{options}]"
    x, y = sketch.center
    res += f"({x}, {y}) circle ({sketch.radius});\n"
    end_scope = get_end_scope()

    return begin_scope + res + end_scope


def draw_ellipse_sketch(sketch):
    """Draws a circle sketch."""
    begin_scope = get_begin_scope()
    res = get_draw(sketch)
    options = get_line_style_options(sketch)
    fill_options = get_fill_style_options(sketch)
    options += fill_options
    if sketch.smooth:
        options += ["smooth"]
    options = ", ".join(options)
    res += f"[{options}]"
    x, y = sketch.center
    a = sketch.width / 2
    b = sketch.height / 2
    res += f"({x}, {y}) ellipse ({a} and {b});\n"
    end_scope = get_end_scope()

    return begin_scope + res + end_scope


def draw_arc_sketch(sketch):
    """Draws an arc sketch."""
    begin_scope = get_begin_scope()
    res = get_draw(sketch)
    options = get_line_style_options(sketch)
    options = ", ".join(options)
    x, y = sketch.center[:2]
    x = x + sketch.radius * cos(sketch.start_angle)
    y = y + sketch.radius * sin(sketch.start_angle)
    start_angle = degrees(sketch.start_angle)
    end_angle = degrees(sketch.end_angle)
    res += f"[{options}]({x}, {y}) arc ({start_angle}:{end_angle}:{sketch.radius});\n"
    res += f" arc ({sketch.start_angle}:{sketch.end_angle}:{sketch.radius});\n"
    end_scope = get_end_scope()
    return begin_scope + res + end_scope


def draw_line(line):
    """Tikz code for a line."""
    p1 = line.start[:2]
    p2 = line.end[:2]
    options = []
    if line.line_width is not None:
        options.append(line.line_width)
    if line.color is not None:
        color = color2tikz(line.color)
        options.append(color)
    if line.dash_array is not None:
        options.append(line.dash_array)
    # options = [line.width, line.color, line.dash_array, line.cap, line.join]
    if line.line_width == 0:
        res = f"\\path[{', '.join(options)}] {p1} -- {p2};\n"
    else:
        res = f"\\draw[{', '.join(options)}] {p1} -- {p2};\n"

    return res


def is_stroked(shape: Shape) -> bool:
    """Returns True if the shape is stroked."""
    return shape.stroke and shape.line_color is not None and shape.line_width > 0


d_sketch_draw = {
    sg.Types.SHAPE: draw_shape_sketch,
    sg.Types.TAGSKETCH: draw_tag_sketch,
    sg.Types.LACESKETCH: draw_lace_sketch,
    sg.Types.LINE: draw_line_sketch,
    sg.Types.CIRCLE: draw_circle_sketch,
    sg.Types.ARC: draw_arc_sketch,
    sg.Types.BATCH: draw_batch_sketch,
}
