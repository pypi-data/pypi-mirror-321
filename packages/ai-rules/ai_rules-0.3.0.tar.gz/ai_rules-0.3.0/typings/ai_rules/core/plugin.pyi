"""
This type stub file was generated by pyright.
"""

import abc
import logging
import click
from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional, Type, Union
from pydantic import BaseModel

"""
This type stub file was generated by pyright.
"""
logger: logging.Logger = ...
class BasePluginResponse(BaseModel):
    """Base class for plugin response models.

    This class provides a standardized format for all plugin responses,
    making them easier for LLMs to parse and process.

    Attributes:
        status: Response status, either 'success' or 'error'
        message: Optional response message
        data: Response data with specific structure
        error: Optional error details if status is error
        metadata: Additional metadata about the response
        timestamp: ISO format timestamp of when the response was created
    """
    model_config = ...
    class ErrorDetails(BaseModel):
        """Structure for error details."""
        code: str = ...
        message: str = ...
        details: Optional[Dict[str, Any]] = ...
    
    
    class ResponseMetadata(BaseModel):
        """Structure for response metadata."""
        timestamp: datetime = ...
        duration_ms: Optional[float] = ...
        source: Optional[str] = ...
        version: Optional[str] = ...
    
    
    status: str = ...
    message: Optional[str] = ...
    data: Dict[str, Any] = ...
    error: Optional[ErrorDetails] = ...
    metadata: ResponseMetadata = ...
    def format_for_llm(self) -> str:
        """Format response in a structured way that's easy for LLM to parse.

        Returns:
            A formatted string representation of the response.
        """
        ...
    


class PluginMetadata(BaseModel):
    """Plugin metadata model."""
    model_config = ...
    name: str = ...
    description: str = ...
    version: str = ...
    author: str = ...
    source: str = ...
    script_path: Optional[str] = ...


class PluginParameter(BaseModel):
    """Plugin parameter model."""
    model_config = ...
    name: str = ...
    type: Any = ...
    required: bool = ...
    help: str = ...


class PluginSpec(BaseModel):
    """Plugin specification model."""
    model_config = ...
    params: List[PluginParameter] = ...


class Plugin(metaclass=abc.ABCMeta):
    """Base class for all plugins."""
    def __init__(self) -> None:
        """Initialize plugin."""
        ...
    
    @property
    def metadata(self) -> PluginMetadata:
        """Get plugin metadata."""
        ...
    
    @property
    @abc.abstractmethod
    def name(self) -> str:
        """Get plugin name."""
        ...
    
    @property
    @abc.abstractmethod
    def description(self) -> str:
        """Get plugin description."""
        ...
    
    @abc.abstractmethod
    def execute(self, **kwargs) -> Any:
        """Execute plugin with given parameters."""
        ...
    
    @property
    @abc.abstractmethod
    def click_command(self) -> click.Command:
        """Get Click command for the plugin.
        
        Returns:
            click.Command: A Click command that wraps this plugin's functionality.
            
        Example:
            @click.command()
            @click.option("--url", required=True, help="URL to scrape")
            def my_command(url):
                return self.execute(url=url)
                
            return my_command
        """
        ...
    
    def format_response(self, data: Any, message: Optional[str] = ...) -> str:
        """Format response using the base response model.

        Args:
            data: The data to include in the response
            message: Optional message to include

        Returns:
            Formatted string suitable for LLM parsing
        """
        ...
    
    def format_error(self, error: str, data: Any = ...) -> str:
        """Format error response using the base response model.

        Args:
            error: Error message
            data: Optional data to include

        Returns:
            Formatted string suitable for LLM parsing
        """
        ...
    


class PluginManager:
    """Plugin manager singleton."""
    _instance: Optional[PluginManager] = ...
    _plugins: ClassVar[Dict[str, Plugin]] = ...
    def __new__(cls) -> PluginManager:
        """Create or return singleton instance."""
        ...
    
    @classmethod
    def register(cls, plugin_class: Union[Type[Plugin], Plugin]) -> Union[Type[Plugin], Plugin]:
        """Register a plugin class or instance.

        Args:
            plugin_class: Plugin class or instance to register.

        Returns:
            Registered plugin class or instance.

        Raises:
            click.ClickException: If plugin registration fails.
        """
        ...
    
    @classmethod
    def register_script(cls, script_path: str) -> None:
        """Register a plugin from a script file.

        Args:
            script_path: Path to script file.

        Raises:
            click.ClickException: If script registration fails.
        """
        ...
    
    @classmethod
    def get_plugin(cls, name: str) -> Optional[Plugin]:
        """Get a plugin by name.

        Args:
            name: Plugin name.

        Returns:
            Plugin instance if found, None otherwise.
        """
        ...
    
    @classmethod
    def get_all_plugins(cls) -> Dict[str, Plugin]:
        """Get all registered plugins.

        Returns:
            Dictionary of plugin name to plugin instance.
        """
        ...
    


class UVScriptPlugin(Plugin):
    """Plugin that wraps a UV script."""
    def __init__(self, script_path: str, name: str, description: str) -> None:
        """Initialize UV script plugin.

        Args:
            script_path: Path to the UV script.
            name: Name of the plugin.
            description: Description of the plugin.
        """
        ...
    
    @property
    def click_command(self) -> click.Command:
        """Get Click command for the plugin.
        
        Returns:
            click.Command: A Click command that wraps this plugin's functionality.
            
        Example:
            @click.command()
            @click.option("--url", required=True, help="URL to scrape")
            def my_command(url):
                return self.execute(url=url)
                
            return my_command
        """
        ...
    
    def execute(self, args: Optional[str] = ...) -> str:
        """Execute the UV script.

        Args:
            args: Arguments to pass to the script.

        Returns:
            Formatted string containing execution results.
        """
        ...
    
    def run_script(self, script_path: str) -> str:
        """Run a script and return its output.

        Args:
            script_path: Path to script to run.

        Returns:
            Script output.

        Raises:
            click.ClickException: If script execution fails.
        """
        ...
    


