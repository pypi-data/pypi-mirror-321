# Generated by cloudcoil-model-codegen v0.0.33
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import BaseModel
from cloudcoil.resources import Resource


class Owner(BaseModel):
    api_version: Annotated[
        str, Field(alias="apiVersion", description="API version of the referent.")
    ]
    block_owner_deletion: Annotated[
        Optional[bool],
        Field(
            alias="blockOwnerDeletion",
            description='If true, AND if the owner has the "foregroundDeletion" finalizer, then\nthe owner cannot be deleted from the key-value store until this\nreference is removed.\nSee https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion\nfor how the garbage collector interacts with this field and enforces the foreground deletion.\nDefaults to false.\nTo set this field, a user needs "delete" permission of the owner,\notherwise 422 (Unprocessable Entity) will be returned.',
        ),
    ] = None
    controller: Annotated[
        Optional[bool],
        Field(description="If true, this reference points to the managing controller."),
    ] = None
    kind: Annotated[
        str,
        Field(
            description="Kind of the referent.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ]
    name: Annotated[
        str,
        Field(
            description="Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names"
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        ),
    ]


class MatchExpression(BaseModel):
    key: Annotated[str, Field(description="key is the label key that the selector applies to.")]
    operator: Annotated[
        str,
        Field(
            description="operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist."
        ),
    ]
    values: Annotated[
        Optional[List[str]],
        Field(
            description="values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch."
        ),
    ] = None


class ResourceSelector(BaseModel):
    match_expressions: Annotated[
        Optional[List[MatchExpression]],
        Field(
            alias="matchExpressions",
            description="matchExpressions is a list of label selector requirements. The requirements are ANDed.",
        ),
    ] = None
    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description='matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array contains only "value". The requirements are ANDed.',
        ),
    ] = None


class ResourceModel(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="API version of the referent."),
    ] = None
    field_path: Annotated[
        Optional[str],
        Field(
            alias="fieldPath",
            description='If referring to a piece of an object instead of an entire object, this string\nshould contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].\nFor example, if the object reference is to a container within a pod, this would take on a value like:\n"spec.containers{name}" (where "name" refers to the name of the container that triggered\nthe event) or if no container name is specified "spec.containers[2]" (container with\nindex 2 in this pod). This syntax is chosen only to have some well-defined way of\nreferencing a part of an object.\nTODO: this design is not final and this field is subject to change in the future.',
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description="Kind of the referent.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        ),
    ] = None
    namespace: Annotated[
        Optional[str],
        Field(
            description="Namespace of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"
        ),
    ] = None
    resource_version: Annotated[
        Optional[str],
        Field(
            alias="resourceVersion",
            description="Specific resourceVersion to which this reference is made, if any.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
        ),
    ] = None
    uid: Annotated[
        Optional[str],
        Field(
            description="UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"
        ),
    ] = None


class Timestamp(BaseModel):
    nanos: Annotated[
        int,
        Field(
            description="Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context."
        ),
    ]
    seconds: Annotated[
        int,
        Field(
            description="Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive."
        ),
    ]


class Result(BaseModel):
    category: Annotated[Optional[str], Field(description="Category indicates policy category")] = (
        None
    )
    message: Annotated[
        Optional[str],
        Field(description="Description is a short user friendly message for the policy rule"),
    ] = None
    policy: Annotated[str, Field(description="Policy is the name or identifier of the policy")]
    properties: Annotated[
        Optional[Dict[str, str]],
        Field(description="Properties provides additional information for the policy rule"),
    ] = None
    resource_selector: Annotated[
        Optional[ResourceSelector],
        Field(
            alias="resourceSelector",
            description="SubjectSelector is an optional label selector for checked Kubernetes resources.\nFor example, a policy result may apply to all pods that match a label.\nEither a Subject or a SubjectSelector can be specified.\nIf neither are provided, the result is assumed to be for the policy report scope.",
        ),
    ] = None
    resources: Annotated[
        Optional[List[ResourceModel]],
        Field(description="Subjects is an optional reference to the checked Kubernetes resources"),
    ] = None
    result: Annotated[
        Optional[Literal["pass", "fail", "warn", "error", "skip"]],
        Field(description="Result indicates the outcome of the policy rule execution"),
    ] = None
    rule: Annotated[
        Optional[str],
        Field(description="Rule is the name or identifier of the rule within the policy"),
    ] = None
    scored: Annotated[
        Optional[bool], Field(description="Scored indicates if this result is scored")
    ] = None
    severity: Annotated[
        Optional[Literal["critical", "high", "low", "medium", "info"]],
        Field(description="Severity indicates policy check result criticality"),
    ] = None
    source: Annotated[
        Optional[str],
        Field(description="Source is an identifier for the policy engine that manages this report"),
    ] = None
    timestamp: Annotated[
        Optional[Timestamp],
        Field(description="Timestamp indicates the time the result was found"),
    ] = None


class Summary(BaseModel):
    error: Annotated[
        Optional[int],
        Field(description="Error provides the count of policies that could not be evaluated"),
    ] = None
    fail: Annotated[
        Optional[int],
        Field(description="Fail provides the count of policies whose requirements were not met"),
    ] = None
    pass_: Annotated[
        Optional[int],
        Field(
            alias="pass",
            description="Pass provides the count of policies whose requirements were met",
        ),
    ] = None
    skip: Annotated[
        Optional[int],
        Field(
            description="Skip indicates the count of policies that were not selected for evaluation"
        ),
    ] = None
    warn: Annotated[
        Optional[int],
        Field(
            description="Warn provides the count of non-scored policies whose requirements were not met"
        ),
    ] = None


class AdmissionReportSpec(BaseModel):
    owner: Annotated[
        Owner,
        Field(
            description="Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)"
        ),
    ]
    results: Annotated[
        Optional[List[Result]],
        Field(description="PolicyReportResult provides result details"),
    ] = None
    summary: Annotated[
        Optional[Summary],
        Field(description="PolicyReportSummary provides a summary of results"),
    ] = None


class BackgroundScanReportSpec(BaseModel):
    results: Annotated[
        Optional[List[Result]],
        Field(description="PolicyReportResult provides result details"),
    ] = None
    summary: Annotated[
        Optional[Summary],
        Field(description="PolicyReportSummary provides a summary of results"),
    ] = None


class All(BaseModel):
    key: Annotated[
        Optional[Any],
        Field(
            description="Key is the context entry (using JMESPath) for conditional rule evaluation."
        ),
    ] = None
    message: Annotated[
        Optional[str], Field(description="Message is an optional display message")
    ] = None
    operator: Annotated[
        Optional[
            Literal[
                "Equals",
                "NotEquals",
                "AnyIn",
                "AllIn",
                "AnyNotIn",
                "AllNotIn",
                "GreaterThanOrEquals",
                "GreaterThan",
                "LessThanOrEquals",
                "LessThan",
                "DurationGreaterThanOrEquals",
                "DurationGreaterThan",
                "DurationLessThanOrEquals",
                "DurationLessThan",
            ]
        ],
        Field(
            description="Operator is the conditional operation to perform. Valid operators are:\nEquals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,\nGreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,\nDurationLessThanOrEquals, DurationLessThan"
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description="Value is the conditional value, or set of values. The values can be fixed set\nor can be variables declared using JMESPath."
        ),
    ] = None


class AnyModel(BaseModel):
    key: Annotated[
        Optional[Any],
        Field(
            description="Key is the context entry (using JMESPath) for conditional rule evaluation."
        ),
    ] = None
    message: Annotated[
        Optional[str], Field(description="Message is an optional display message")
    ] = None
    operator: Annotated[
        Optional[
            Literal[
                "Equals",
                "NotEquals",
                "AnyIn",
                "AllIn",
                "AnyNotIn",
                "AllNotIn",
                "GreaterThanOrEquals",
                "GreaterThan",
                "LessThanOrEquals",
                "LessThan",
                "DurationGreaterThanOrEquals",
                "DurationGreaterThan",
                "DurationLessThanOrEquals",
                "DurationLessThan",
            ]
        ],
        Field(
            description="Operator is the conditional operation to perform. Valid operators are:\nEquals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,\nGreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,\nDurationLessThanOrEquals, DurationLessThan"
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description="Value is the conditional value, or set of values. The values can be fixed set\nor can be variables declared using JMESPath."
        ),
    ] = None


class Conditions(BaseModel):
    all: Annotated[
        Optional[List[All]],
        Field(
            description="AllConditions enable variable-based conditional rule execution. This is useful for\nfiner control of when an rule is applied. A condition can reference object data\nusing JMESPath notation.\nHere, all of the conditions need to pass."
        ),
    ] = None
    any: Annotated[
        Optional[List[AnyModel]],
        Field(
            description="AnyConditions enable variable-based conditional rule execution. This is useful for\nfiner control of when an rule is applied. A condition can reference object data\nusing JMESPath notation.\nHere, at least one of the conditions need to pass."
        ),
    ] = None


class Datum(BaseModel):
    key: Annotated[str, Field(description="Key is a unique identifier for the data value")]
    value: Annotated[Any, Field(description="Value is the data value")]


class Service(BaseModel):
    ca_bundle: Annotated[
        Optional[str],
        Field(
            alias="caBundle",
            description="CABundle is a PEM encoded CA bundle which will be used to validate\nthe server certificate.",
        ),
    ] = None
    url: Annotated[
        str,
        Field(
            description="URL is the JSON web service URL. A typical form is\n`https://{service}.{namespace}:{port}/{path}`."
        ),
    ]


class ApiCall(BaseModel):
    data: Annotated[
        Optional[List[Datum]],
        Field(
            description="The data object specifies the POST data sent to the server.\nOnly applicable when the method field is set to POST."
        ),
    ] = None
    jmes_path: Annotated[
        Optional[str],
        Field(
            alias="jmesPath",
            description='JMESPath is an optional JSON Match Expression that can be used to\ntransform the JSON response returned from the server. For example\na JMESPath of "items | length(@)" applied to the API server response\nfor the URLPath "/apis/apps/v1/deployments" will return the total count\nof deployments across all namespaces.',
        ),
    ] = None
    method: Annotated[
        Optional[Literal["GET", "POST"]],
        Field(description="Method is the HTTP request type (GET or POST)."),
    ] = "GET"
    service: Annotated[
        Optional[Service],
        Field(
            description="Service is an API call to a JSON web service.\nThis is used for non-Kubernetes API server calls.\nIt's mutually exclusive with the URLPath field."
        ),
    ] = None
    url_path: Annotated[
        Optional[str],
        Field(
            alias="urlPath",
            description='URLPath is the URL path to be used in the HTTP GET or POST request to the\nKubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").\nThe format required is the same format used by the `kubectl get --raw` command.\nSee https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls\nfor details.\nIt\'s mutually exclusive with the Service field.',
        ),
    ] = None


class ConfigMap(BaseModel):
    name: Annotated[str, Field(description="Name is the ConfigMap name.")]
    namespace: Annotated[
        Optional[str], Field(description="Namespace is the ConfigMap namespace.")
    ] = None


class GlobalReference(BaseModel):
    jmes_path: Annotated[
        Optional[str],
        Field(
            alias="jmesPath",
            description='JMESPath is an optional JSON Match Expression that can be used to\ntransform the JSON response returned from the server. For example\na JMESPath of "items | length(@)" applied to the API server response\nfor the URLPath "/apis/apps/v1/deployments" will return the total count\nof deployments across all namespaces.',
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="Name of the global context entry")] = None


class ImageRegistryCredentials(BaseModel):
    allow_insecure_registry: Annotated[
        Optional[bool],
        Field(
            alias="allowInsecureRegistry",
            description="AllowInsecureRegistry allows insecure access to a registry.",
        ),
    ] = None
    providers: Annotated[
        Optional[List[Literal["default", "amazon", "azure", "google", "github"]]],
        Field(
            description="Providers specifies a list of OCI Registry names, whose authentication providers are provided.\nIt can be of one of these values: default,google,azure,amazon,github."
        ),
    ] = None
    secrets: Annotated[
        Optional[List[str]],
        Field(
            description="Secrets specifies a list of secrets that are provided for credentials.\nSecrets must live in the Kyverno namespace."
        ),
    ] = None


class ImageRegistry(BaseModel):
    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials],
        Field(
            alias="imageRegistryCredentials",
            description="ImageRegistryCredentials provides credentials that will be used for authentication with registry",
        ),
    ] = None
    jmes_path: Annotated[
        Optional[str],
        Field(
            alias="jmesPath",
            description="JMESPath is an optional JSON Match Expression that can be used to\ntransform the ImageData struct returned as a result of processing\nthe image reference.",
        ),
    ] = None
    reference: Annotated[
        str,
        Field(
            description="Reference is image reference to a container image in the registry.\nExample: ghcr.io/kyverno/kyverno:latest"
        ),
    ]


class Variable(BaseModel):
    default: Annotated[
        Optional[Any],
        Field(
            description="Default is an optional arbitrary JSON object that the variable may take if the JMESPath\nexpression evaluates to nil"
        ),
    ] = None
    jmes_path: Annotated[
        Optional[str],
        Field(
            alias="jmesPath",
            description="JMESPath is an optional JMESPath Expression that can be used to\ntransform the variable.",
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(description="Value is any arbitrary JSON object representable in YAML or JSON form."),
    ] = None


class Context(BaseModel):
    api_call: Annotated[
        Optional[ApiCall],
        Field(
            alias="apiCall",
            description="APICall is an HTTP request to the Kubernetes API server, or other JSON web service.\nThe data returned is stored in the context with the name for the context entry.",
        ),
    ] = None
    config_map: Annotated[
        Optional[ConfigMap],
        Field(alias="configMap", description="ConfigMap is the ConfigMap reference."),
    ] = None
    global_reference: Annotated[
        Optional[GlobalReference],
        Field(
            alias="globalReference",
            description="GlobalContextEntryReference is a reference to a cached global context entry.",
        ),
    ] = None
    image_registry: Annotated[
        Optional[ImageRegistry],
        Field(
            alias="imageRegistry",
            description="ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image\ndetails.",
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="Name is the variable name.")] = None
    variable: Annotated[
        Optional[Variable],
        Field(
            description="Variable defines an arbitrary JMESPath context variable that can be defined inline."
        ),
    ] = None


class NamespaceSelector(BaseModel):
    match_expressions: Annotated[
        Optional[List[MatchExpression]],
        Field(
            alias="matchExpressions",
            description="matchExpressions is a list of label selector requirements. The requirements are ANDed.",
        ),
    ] = None
    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description='matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array contains only "value". The requirements are ANDed.',
        ),
    ] = None


class Selector(BaseModel):
    match_expressions: Annotated[
        Optional[List[MatchExpression]],
        Field(
            alias="matchExpressions",
            description="matchExpressions is a list of label selector requirements. The requirements are ANDed.",
        ),
    ] = None
    match_labels: Annotated[
        Optional[Dict[str, str]],
        Field(
            alias="matchLabels",
            description='matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is "key", the\noperator is "In", and the values array contains only "value". The requirements are ANDed.',
        ),
    ] = None


class Resources(BaseModel):
    annotations: Annotated[
        Optional[Dict[str, str]],
        Field(
            description='Annotations is a  map of annotations (key-value pairs of type string). Annotation keys\nand values support the wildcard characters "*" (matches zero or many characters) and\n"?" (matches at least one character).'
        ),
    ] = None
    kinds: Annotated[
        Optional[List[str]], Field(description="Kinds is a list of resource kinds.")
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description='Name is the name of the resource. The name supports wildcard characters\n"*" (matches zero or many characters) and "?" (at least one character).\nNOTE: "Name" is being deprecated in favor of "Names".'
        ),
    ] = None
    names: Annotated[
        Optional[List[str]],
        Field(
            description='Names are the names of the resources. Each name supports wildcard characters\n"*" (matches zero or many characters) and "?" (at least one character).'
        ),
    ] = None
    namespace_selector: Annotated[
        Optional[NamespaceSelector],
        Field(
            alias="namespaceSelector",
            description='NamespaceSelector is a label selector for the resource namespace. Label keys and values\nin `matchLabels` support the wildcard characters `*` (matches zero or many characters)\nand `?` (matches one character).Wildcards allows writing label selectors like\n["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but\ndoes not match an empty label set.',
        ),
    ] = None
    namespaces: Annotated[
        Optional[List[str]],
        Field(
            description='Namespaces is a list of namespaces names. Each name supports wildcard characters\n"*" (matches zero or many characters) and "?" (at least one character).'
        ),
    ] = None
    operations: Annotated[
        Optional[List[Literal["CREATE", "CONNECT", "UPDATE", "DELETE"]]],
        Field(
            description='Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.'
        ),
    ] = None
    selector: Annotated[
        Optional[Selector],
        Field(
            description='Selector is a label selector. Label keys and values in `matchLabels` support the wildcard\ncharacters `*` (matches zero or many characters) and `?` (matches one character).\nWildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that\nusing ["*" : "*"] matches any key and value but does not match an empty label set.'
        ),
    ] = None


class Subject(BaseModel):
    api_group: Annotated[
        Optional[str],
        Field(
            alias="apiGroup",
            description='APIGroup holds the API group of the referenced subject.\nDefaults to "" for ServiceAccount subjects.\nDefaults to "rbac.authorization.k8s.io" for User and Group subjects.',
        ),
    ] = None
    kind: Annotated[
        str,
        Field(
            description='Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".\nIf the Authorizer does not recognized the kind value, the Authorizer should report an error.'
        ),
    ]
    name: Annotated[str, Field(description="Name of the object being referenced.")]
    namespace: Annotated[
        Optional[str],
        Field(
            description='Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty\nthe Authorizer should report an error.'
        ),
    ] = None


class AllModel(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is the list of cluster-wide role names for the user.",
        ),
    ] = None
    resources: Annotated[
        Optional[Resources],
        Field(
            description="ResourceDescription contains information about the resource being created or modified."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is the list of namespaced role names for the user."),
    ] = None
    subjects: Annotated[
        Optional[List[Subject]],
        Field(
            description="Subjects is the list of subject names like users, user groups, and service accounts."
        ),
    ] = None


class AnyModel1(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is the list of cluster-wide role names for the user.",
        ),
    ] = None
    resources: Annotated[
        Optional[Resources],
        Field(
            description="ResourceDescription contains information about the resource being created or modified."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is the list of namespaced role names for the user."),
    ] = None
    subjects: Annotated[
        Optional[List[Subject]],
        Field(
            description="Subjects is the list of subject names like users, user groups, and service accounts."
        ),
    ] = None


class Exclude(BaseModel):
    all: Annotated[
        Optional[List[AllModel]],
        Field(description="All allows specifying resources which will be ANDed"),
    ] = None
    any: Annotated[
        Optional[List[AnyModel1]],
        Field(description="Any allows specifying resources which will be ORed"),
    ] = None


class Match(BaseModel):
    all: Annotated[
        Optional[List[AllModel]],
        Field(description="All allows specifying resources which will be ANDed"),
    ] = None
    any: Annotated[
        Optional[List[AnyModel1]],
        Field(description="Any allows specifying resources which will be ORed"),
    ] = None


class CleanupPolicySpec(BaseModel):
    conditions: Annotated[
        Optional[Conditions],
        Field(
            description="Conditions defines the conditions used to select the resources which will be cleaned up."
        ),
    ] = None
    context: Annotated[
        Optional[List[Context]],
        Field(
            description="Context defines variables and data sources that can be used during rule execution."
        ),
    ] = None
    exclude: Annotated[
        Optional[Exclude],
        Field(
            description="ExcludeResources defines when cleanuppolicy should not be applied. The exclude\ncriteria can include resource information (e.g. kind, name, namespace, labels)\nand admission review request information like the name or role."
        ),
    ] = None
    match: Annotated[
        Optional[Match],
        Field(
            description="MatchResources defines when cleanuppolicy should be applied. The match\ncriteria can include resource information (e.g. kind, name, namespace, labels)\nand admission review request information like the user name or role.\nAt least one kind is required."
        ),
    ] = None
    schedule: Annotated[str, Field(description="The schedule in Cron format")]


class Condition(BaseModel):
    last_transition_time: Annotated[
        datetime,
        Field(
            alias="lastTransitionTime",
            description="lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
        ),
    ]
    message: Annotated[
        str,
        Field(
            description="message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            max_length=32768,
        ),
    ]
    observed_generation: Annotated[
        Optional[int],
        Field(
            alias="observedGeneration",
            description="observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            ge=0,
        ),
    ] = None
    reason: Annotated[
        str,
        Field(
            description="reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    status: Annotated[
        Literal["True", "False", "Unknown"],
        Field(description="status of the condition, one of True, False, Unknown."),
    ]
    type: Annotated[
        str,
        Field(
            description="type of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]


class CleanupPolicyStatus(BaseModel):
    conditions: Optional[List[Condition]] = None
    last_execution_time: Annotated[Optional[datetime], Field(alias="lastExecutionTime")] = None


class ClusterAdmissionReportSpec(BaseModel):
    owner: Annotated[
        Owner,
        Field(
            description="Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)"
        ),
    ]
    results: Annotated[
        Optional[List[Result]],
        Field(description="PolicyReportResult provides result details"),
    ] = None
    summary: Annotated[
        Optional[Summary],
        Field(description="PolicyReportSummary provides a summary of results"),
    ] = None


class ClusterBackgroundScanReportSpec(BaseModel):
    results: Annotated[
        Optional[List[Result]],
        Field(description="PolicyReportResult provides result details"),
    ] = None
    summary: Annotated[
        Optional[Summary],
        Field(description="PolicyReportSummary provides a summary of results"),
    ] = None


class AllModel1(BaseModel):
    key: Annotated[
        Optional[Any],
        Field(
            description="Key is the context entry (using JMESPath) for conditional rule evaluation."
        ),
    ] = None
    message: Annotated[
        Optional[str], Field(description="Message is an optional display message")
    ] = None
    operator: Annotated[
        Optional[
            Literal[
                "Equals",
                "NotEquals",
                "AnyIn",
                "AllIn",
                "AnyNotIn",
                "AllNotIn",
                "GreaterThanOrEquals",
                "GreaterThan",
                "LessThanOrEquals",
                "LessThan",
                "DurationGreaterThanOrEquals",
                "DurationGreaterThan",
                "DurationLessThanOrEquals",
                "DurationLessThan",
            ]
        ],
        Field(
            description="Operator is the conditional operation to perform. Valid operators are:\nEquals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,\nGreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,\nDurationLessThanOrEquals, DurationLessThan"
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description="Value is the conditional value, or set of values. The values can be fixed set\nor can be variables declared using JMESPath."
        ),
    ] = None


class AnyModel2(BaseModel):
    key: Annotated[
        Optional[Any],
        Field(
            description="Key is the context entry (using JMESPath) for conditional rule evaluation."
        ),
    ] = None
    message: Annotated[
        Optional[str], Field(description="Message is an optional display message")
    ] = None
    operator: Annotated[
        Optional[
            Literal[
                "Equals",
                "NotEquals",
                "AnyIn",
                "AllIn",
                "AnyNotIn",
                "AllNotIn",
                "GreaterThanOrEquals",
                "GreaterThan",
                "LessThanOrEquals",
                "LessThan",
                "DurationGreaterThanOrEquals",
                "DurationGreaterThan",
                "DurationLessThanOrEquals",
                "DurationLessThan",
            ]
        ],
        Field(
            description="Operator is the conditional operation to perform. Valid operators are:\nEquals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,\nGreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,\nDurationLessThanOrEquals, DurationLessThan"
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description="Value is the conditional value, or set of values. The values can be fixed set\nor can be variables declared using JMESPath."
        ),
    ] = None


class AllModel2(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is the list of cluster-wide role names for the user.",
        ),
    ] = None
    resources: Annotated[
        Optional[Resources],
        Field(
            description="ResourceDescription contains information about the resource being created or modified."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is the list of namespaced role names for the user."),
    ] = None
    subjects: Annotated[
        Optional[List[Subject]],
        Field(
            description="Subjects is the list of subject names like users, user groups, and service accounts."
        ),
    ] = None


class AnyModel3(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is the list of cluster-wide role names for the user.",
        ),
    ] = None
    resources: Annotated[
        Optional[Resources],
        Field(
            description="ResourceDescription contains information about the resource being created or modified."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is the list of namespaced role names for the user."),
    ] = None
    subjects: Annotated[
        Optional[List[Subject]],
        Field(
            description="Subjects is the list of subject names like users, user groups, and service accounts."
        ),
    ] = None


class ClusterCleanupPolicySpec(BaseModel):
    conditions: Annotated[
        Optional[Conditions],
        Field(
            description="Conditions defines the conditions used to select the resources which will be cleaned up."
        ),
    ] = None
    context: Annotated[
        Optional[List[Context]],
        Field(
            description="Context defines variables and data sources that can be used during rule execution."
        ),
    ] = None
    exclude: Annotated[
        Optional[Exclude],
        Field(
            description="ExcludeResources defines when cleanuppolicy should not be applied. The exclude\ncriteria can include resource information (e.g. kind, name, namespace, labels)\nand admission review request information like the name or role."
        ),
    ] = None
    match: Annotated[
        Optional[Match],
        Field(
            description="MatchResources defines when cleanuppolicy should be applied. The match\ncriteria can include resource information (e.g. kind, name, namespace, labels)\nand admission review request information like the user name or role.\nAt least one kind is required."
        ),
    ] = None
    schedule: Annotated[str, Field(description="The schedule in Cron format")]


class ClusterCleanupPolicyStatus(BaseModel):
    conditions: Optional[List[Condition]] = None
    last_execution_time: Annotated[Optional[datetime], Field(alias="lastExecutionTime")] = None


class AllModel3(BaseModel):
    key: Annotated[
        Optional[Any],
        Field(
            description="Key is the context entry (using JMESPath) for conditional rule evaluation."
        ),
    ] = None
    message: Annotated[
        Optional[str], Field(description="Message is an optional display message")
    ] = None
    operator: Annotated[
        Optional[
            Literal[
                "Equals",
                "NotEquals",
                "AnyIn",
                "AllIn",
                "AnyNotIn",
                "AllNotIn",
                "GreaterThanOrEquals",
                "GreaterThan",
                "LessThanOrEquals",
                "LessThan",
                "DurationGreaterThanOrEquals",
                "DurationGreaterThan",
                "DurationLessThanOrEquals",
                "DurationLessThan",
            ]
        ],
        Field(
            description="Operator is the conditional operation to perform. Valid operators are:\nEquals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,\nGreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,\nDurationLessThanOrEquals, DurationLessThan"
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description="Value is the conditional value, or set of values. The values can be fixed set\nor can be variables declared using JMESPath."
        ),
    ] = None


class AnyModel4(BaseModel):
    key: Annotated[
        Optional[Any],
        Field(
            description="Key is the context entry (using JMESPath) for conditional rule evaluation."
        ),
    ] = None
    message: Annotated[
        Optional[str], Field(description="Message is an optional display message")
    ] = None
    operator: Annotated[
        Optional[
            Literal[
                "Equals",
                "NotEquals",
                "AnyIn",
                "AllIn",
                "AnyNotIn",
                "AllNotIn",
                "GreaterThanOrEquals",
                "GreaterThan",
                "LessThanOrEquals",
                "LessThan",
                "DurationGreaterThanOrEquals",
                "DurationGreaterThan",
                "DurationLessThanOrEquals",
                "DurationLessThan",
            ]
        ],
        Field(
            description="Operator is the conditional operation to perform. Valid operators are:\nEquals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,\nGreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,\nDurationLessThanOrEquals, DurationLessThan"
        ),
    ] = None
    value: Annotated[
        Optional[Any],
        Field(
            description="Value is the conditional value, or set of values. The values can be fixed set\nor can be variables declared using JMESPath."
        ),
    ] = None


class Exception(BaseModel):
    policy_name: Annotated[
        str,
        Field(
            alias="policyName",
            description="PolicyName identifies the policy to which the exception is applied.\nThe policy name uses the format <namespace>/<name> unless it\nreferences a ClusterPolicy.",
        ),
    ]
    rule_names: Annotated[
        List[str],
        Field(
            alias="ruleNames",
            description="RuleNames identifies the rules to which the exception is applied.",
        ),
    ]


class AllModel4(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is the list of cluster-wide role names for the user.",
        ),
    ] = None
    resources: Annotated[
        Optional[Resources],
        Field(
            description="ResourceDescription contains information about the resource being created or modified."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is the list of namespaced role names for the user."),
    ] = None
    subjects: Annotated[
        Optional[List[Subject]],
        Field(
            description="Subjects is the list of subject names like users, user groups, and service accounts."
        ),
    ] = None


class AnyModel5(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is the list of cluster-wide role names for the user.",
        ),
    ] = None
    resources: Annotated[
        Optional[Resources],
        Field(
            description="ResourceDescription contains information about the resource being created or modified."
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is the list of namespaced role names for the user."),
    ] = None
    subjects: Annotated[
        Optional[List[Subject]],
        Field(
            description="Subjects is the list of subject names like users, user groups, and service accounts."
        ),
    ] = None


class PodSecurity(BaseModel):
    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(
            alias="controlName",
            description="ControlName specifies the name of the Pod Security Standard control.\nSee: https://kubernetes.io/docs/concepts/security/pod-security-standards/",
        ),
    ]
    images: Annotated[
        Optional[List[str]],
        Field(
            description="Images selects matching containers and applies the container level PSS.\nEach image is the image name consisting of the registry address, repository, image, and tag.\nEmpty list matches no containers, PSS checks are applied at the pod level only.\nWildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images."
        ),
    ] = None
    restricted_field: Annotated[
        Optional[str],
        Field(
            alias="restrictedField",
            description="RestrictedField selects the field for the given Pod Security Standard control.\nWhen not set, all restricted fields for the control are selected.",
        ),
    ] = None
    values: Annotated[
        Optional[List[str]],
        Field(description="Values defines the allowed values that can be excluded."),
    ] = None


class PolicyExceptionSpec(BaseModel):
    background: Annotated[
        Optional[bool],
        Field(
            description='Background controls if exceptions are applied to existing policies during a background scan.\nOptional. Default value is "true". The value must be set to "false" if the policy rule\nuses variables that are only available in the admission review request (e.g. user name).'
        ),
    ] = None
    conditions: Annotated[
        Optional[Conditions],
        Field(
            description="Conditions are used to determine if a resource applies to the exception by evaluating a\nset of conditions. The declaration can contain nested `any` or `all` statements."
        ),
    ] = None
    exceptions: Annotated[
        List[Exception],
        Field(description="Exceptions is a list policy/rules to be excluded"),
    ]
    match: Annotated[
        Match,
        Field(
            description="Match defines match clause used to check if a resource applies to the exception"
        ),
    ]
    pod_security: Annotated[
        Optional[List[PodSecurity]],
        Field(
            alias="podSecurity",
            description="PodSecurity specifies the Pod Security Standard controls to be excluded.\nApplicable only to policies that have validate.podSecurity subrule.",
        ),
    ] = None


class Kind(BaseModel):
    group: str
    kind: str
    version: str


class RequestKind(BaseModel):
    group: str
    kind: str
    version: str


class RequestResource(BaseModel):
    group: str
    resource: str
    version: str


class ResourceModel1(BaseModel):
    group: str
    resource: str
    version: str


class UserInfo(BaseModel):
    extra: Annotated[
        Optional[Dict[str, List[str]]],
        Field(description="Any additional information provided by the authenticator."),
    ] = None
    groups: Annotated[
        Optional[List[str]],
        Field(description="The names of groups this user is a part of."),
    ] = None
    uid: Annotated[
        Optional[str],
        Field(
            description="A unique value that identifies this user across time. If this user is\ndeleted and another user by the same name is added, they will have\ndifferent UIDs."
        ),
    ] = None
    username: Annotated[
        Optional[str],
        Field(description="The name that uniquely identifies this user among all active users."),
    ] = None


class AdmissionRequest(BaseModel):
    dry_run: Annotated[
        Optional[bool],
        Field(
            alias="dryRun",
            description="DryRun indicates that modifications will definitely not be persisted for this request.\nDefaults to false.",
        ),
    ] = None
    kind: Annotated[
        Kind,
        Field(
            description="Kind is the fully-qualified type of object being submitted (for example, v1.Pod or autoscaling.v1.Scale)"
        ),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description="Name is the name of the object as presented in the request.  On a CREATE operation, the client may omit name and\nrely on the server to generate the name.  If that is the case, this field will contain an empty string."
        ),
    ] = None
    namespace: Annotated[
        Optional[str],
        Field(description="Namespace is the namespace associated with the request (if any)."),
    ] = None
    object: Annotated[
        Optional[Dict[str, Any]],
        Field(description="Object is the object from the incoming request."),
    ] = None
    old_object: Annotated[
        Optional[Dict[str, Any]],
        Field(
            alias="oldObject",
            description="OldObject is the existing object. Only populated for DELETE and UPDATE requests.",
        ),
    ] = None
    operation: Annotated[
        str,
        Field(
            description="Operation is the operation being performed. This may be different than the operation\nrequested. e.g. a patch can result in either a CREATE or UPDATE Operation."
        ),
    ]
    options: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="Options is the operation option structure of the operation being performed.\ne.g. `meta.k8s.io/v1.DeleteOptions` or `meta.k8s.io/v1.CreateOptions`. This may be\ndifferent than the options the caller provided. e.g. for a patch request the performed\nOperation might be a CREATE, in which case the Options will a\n`meta.k8s.io/v1.CreateOptions` even though the caller provided `meta.k8s.io/v1.PatchOptions`."
        ),
    ] = None
    request_kind: Annotated[
        Optional[RequestKind],
        Field(
            alias="requestKind",
            description='RequestKind is the fully-qualified type of the original API request (for example, v1.Pod or autoscaling.v1.Scale).\nIf this is specified and differs from the value in "kind", an equivalent match and conversion was performed.\n\n\nFor example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of\n`apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,\nan API request to apps/v1beta1 deployments would be converted and sent to the webhook\nwith `kind: {group:"apps", version:"v1", kind:"Deployment"}` (matching the rule the webhook registered for),\nand `requestKind: {group:"apps", version:"v1beta1", kind:"Deployment"}` (indicating the kind of the original API request).\n\n\nSee documentation for the "matchPolicy" field in the webhook configuration type for more details.',
        ),
    ] = None
    request_resource: Annotated[
        Optional[RequestResource],
        Field(
            alias="requestResource",
            description='RequestResource is the fully-qualified resource of the original API request (for example, v1.pods).\nIf this is specified and differs from the value in "resource", an equivalent match and conversion was performed.\n\n\nFor example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of\n`apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,\nan API request to apps/v1beta1 deployments would be converted and sent to the webhook\nwith `resource: {group:"apps", version:"v1", resource:"deployments"}` (matching the resource the webhook registered for),\nand `requestResource: {group:"apps", version:"v1beta1", resource:"deployments"}` (indicating the resource of the original API request).\n\n\nSee documentation for the "matchPolicy" field in the webhook configuration type.',
        ),
    ] = None
    request_sub_resource: Annotated[
        Optional[str],
        Field(
            alias="requestSubResource",
            description='RequestSubResource is the name of the subresource of the original API request, if any (for example, "status" or "scale")\nIf this is specified and differs from the value in "subResource", an equivalent match and conversion was performed.\nSee documentation for the "matchPolicy" field in the webhook configuration type.',
        ),
    ] = None
    resource: Annotated[
        ResourceModel1,
        Field(
            description="Resource is the fully-qualified resource being requested (for example, v1.pods)"
        ),
    ]
    sub_resource: Annotated[
        Optional[str],
        Field(
            alias="subResource",
            description='SubResource is the subresource being requested, if any (for example, "status" or "scale")',
        ),
    ] = None
    uid: Annotated[
        str,
        Field(
            description="UID is an identifier for the individual request/response. It allows us to distinguish instances of requests which are\notherwise identical (parallel requests, requests when earlier requests did not modify etc)\nThe UID is meant to track the round trip (request/response) between the KAS and the WebHook, not the user request.\nIt is suitable for correlating log entries between the webhook and apiserver, for either auditing or debugging."
        ),
    ]
    user_info: Annotated[
        UserInfo,
        Field(
            alias="userInfo",
            description="UserInfo is information about the requesting user",
        ),
    ]


class AdmissionRequestInfo(BaseModel):
    admission_request: Annotated[
        Optional[AdmissionRequest],
        Field(
            alias="admissionRequest",
            description="AdmissionRequest describes the admission.Attributes for the admission request.",
        ),
    ] = None
    operation: Annotated[
        Optional[str],
        Field(
            description="Operation is the type of resource operation being checked for admission control"
        ),
    ] = None


class UserInfoModel(BaseModel):
    cluster_roles: Annotated[
        Optional[List[str]],
        Field(
            alias="clusterRoles",
            description="ClusterRoles is a list of possible clusterRoles send the request.",
        ),
    ] = None
    roles: Annotated[
        Optional[List[str]],
        Field(description="Roles is a list of possible role send the request."),
    ] = None
    user_info: Annotated[
        Optional[UserInfo],
        Field(
            alias="userInfo",
            description="UserInfo is the userInfo carried in the admission request.",
        ),
    ] = None


class ContextModel(BaseModel):
    admission_request_info: Annotated[
        Optional[AdmissionRequestInfo],
        Field(
            alias="admissionRequestInfo",
            description="AdmissionRequestInfoObject stores the admission request and operation details",
        ),
    ] = None
    user_info: Annotated[
        Optional[UserInfoModel],
        Field(
            alias="userInfo",
            description="RequestInfo contains permission info carried in an admission request.",
        ),
    ] = None


class ResourceModel2(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="APIVersion specifies resource apiVersion."),
    ] = None
    kind: Annotated[Optional[str], Field(description="Kind specifies resource kind.")] = None
    name: Annotated[Optional[str], Field(description="Name specifies the resource name.")] = None
    namespace: Annotated[
        Optional[str], Field(description="Namespace specifies resource namespace.")
    ] = None
    uid: Annotated[Optional[str], Field(description="UID specifies the resource uid.")] = None


class UpdateRequestSpec(BaseModel):
    context: Annotated[ContextModel, Field(description="Context ...")]
    delete_downstream: Annotated[
        bool,
        Field(
            alias="deleteDownstream",
            description="DeleteDownstream represents whether the downstream needs to be deleted.",
        ),
    ]
    policy: Annotated[str, Field(description="Specifies the name of the policy.")]
    request_type: Annotated[
        Optional[Literal["mutate", "generate"]],
        Field(
            alias="requestType",
            description="Type represents request type for background processing",
        ),
    ] = None
    resource: Annotated[
        ResourceModel2,
        Field(description="ResourceSpec is the information to identify the trigger resource."),
    ]
    rule: Annotated[str, Field(description="Rule is the associate rule name of the current UR.")]
    synchronize: Annotated[
        Optional[bool],
        Field(
            description='Synchronize represents the sync behavior of the corresponding rule\nOptional. Defaults to "false" if not specified.'
        ),
    ] = None


class GeneratedResource(BaseModel):
    api_version: Annotated[
        Optional[str],
        Field(alias="apiVersion", description="APIVersion specifies resource apiVersion."),
    ] = None
    kind: Annotated[Optional[str], Field(description="Kind specifies resource kind.")] = None
    name: Annotated[Optional[str], Field(description="Name specifies the resource name.")] = None
    namespace: Annotated[
        Optional[str], Field(description="Namespace specifies resource namespace.")
    ] = None
    uid: Annotated[Optional[str], Field(description="UID specifies the resource uid.")] = None


class UpdateRequestStatus(BaseModel):
    generated_resources: Annotated[
        Optional[List[GeneratedResource]],
        Field(
            alias="generatedResources",
            description="This will track the resources that are updated by the generate Policy.\nWill be used during clean up resources.",
        ),
    ] = None
    message: Annotated[Optional[str], Field(description="Specifies request status message.")] = None
    retry_count: Annotated[Optional[int], Field(alias="retryCount")] = None
    state: Annotated[str, Field(description="State represents state of the update request.")]


class AdmissionReport(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["AdmissionReport"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "AdmissionReport"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: AdmissionReportSpec


class BackgroundScanReport(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["BackgroundScanReport"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "BackgroundScanReport"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: BackgroundScanReportSpec


class CleanupPolicy(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["CleanupPolicy"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "CleanupPolicy"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: CleanupPolicySpec
    status: Optional[CleanupPolicyStatus] = None


class ClusterAdmissionReport(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["ClusterAdmissionReport"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "ClusterAdmissionReport"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterAdmissionReportSpec


class ClusterBackgroundScanReport(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["ClusterBackgroundScanReport"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "ClusterBackgroundScanReport"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterBackgroundScanReportSpec


class ClusterCleanupPolicy(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["ClusterCleanupPolicy"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "ClusterCleanupPolicy"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterCleanupPolicySpec
    status: Optional[ClusterCleanupPolicyStatus] = None


class PolicyException(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["PolicyException"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "PolicyException"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PolicyExceptionSpec


class UpdateRequest(Resource):
    api_version: Annotated[
        Optional[Literal["kyverno.io/v2"]],
        Field(
            alias="apiVersion",
            description="APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
        ),
    ] = "kyverno.io/v2"
    kind: Annotated[
        Optional[Literal["UpdateRequest"]],
        Field(
            description="Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        ),
    ] = "UpdateRequest"
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[UpdateRequestSpec] = None
    status: Optional[UpdateRequestStatus] = None
