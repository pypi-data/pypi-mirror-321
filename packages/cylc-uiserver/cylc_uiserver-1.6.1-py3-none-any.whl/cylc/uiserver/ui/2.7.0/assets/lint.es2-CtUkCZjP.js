import{C as Y}from"./codemirror.es-Bh644rv_.js";import{d as O,i as ce,a as C,n as fe,b as A,s as _,t as I,c as w,e as q,f as we,h as _e,j as b,k as V,l as E,m as L,o as te,p as de,q as k,r as Re,v as $e,G as Fe,u as Ve,w as Ce,x as H,y as Ae,z as Le,A as re,T as pe,B as me,C as ke,D as Ue,E as je}from"./GraphiQL-WQqZCqCP.js";import{R as ge,P as U}from"./Range-CZNrBk8u.js";import{dR as Me,aR as f,aT as p,aZ as T,a$ as S,aX as N,a_ as y,b0 as B,dS as ve,dT as Pe,dU as Ge,dV as qe,b5 as Ne,aS as Ye,dW as Be,b4 as Qe}from"./index-Hyq34tSM.js";import"./codemirror.es2-CXusOVRv.js";function ye(n){return{Document(t){for(const e of t.definitions)if(!Me(e)){const r=e.kind===f.SCHEMA_DEFINITION||e.kind===f.SCHEMA_EXTENSION?"schema":'"'+e.name.value+'"';n.reportError(new p(`The ${r} definition is not executable.`,{nodes:e}))}return!1}}}function He(n){return{Field(t){const e=n.getParentType();if(e&&!n.getFieldDef()){const s=n.getSchema(),i=t.name.value;let o=O("to use an inline fragment on",We(s,e,i));o===""&&(o=O(Xe(e,i))),n.reportError(new p(`Cannot query field "${i}" on type "${e.name}".`+o,{nodes:t}))}}}}function We(n,t,e){if(!ce(t))return[];const r=new Set,s=Object.create(null);for(const o of n.getPossibleTypes(t))if(o.getFields()[e]){r.add(o),s[o.name]=1;for(const a of o.getInterfaces()){var i;a.getFields()[e]&&(r.add(a),s[a.name]=((i=s[a.name])!==null&&i!==void 0?i:0)+1)}}return[...r].sort((o,a)=>{const l=s[a.name]-s[o.name];return l!==0?l:C(o)&&n.isSubType(o,a)?-1:C(a)&&n.isSubType(a,o)?1:fe(o.name,a.name)}).map(o=>o.name)}function Xe(n,t){if(A(n)||C(n)){const e=Object.keys(n.getFields());return _(t,e)}return[]}function Je(n){return{InlineFragment(t){const e=t.typeCondition;if(e){const r=I(n.getSchema(),e);if(r&&!w(r)){const s=T(e);n.reportError(new p(`Fragment cannot condition on non composite type "${s}".`,{nodes:e}))}}},FragmentDefinition(t){const e=I(n.getSchema(),t.typeCondition);if(e&&!w(e)){const r=T(t.typeCondition);n.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,{nodes:t.typeCondition}))}}}}function Ke(n){return{...ze(n),Argument(t){const e=n.getArgument(),r=n.getFieldDef(),s=n.getParentType();if(!e&&r&&s){const i=t.name.value,o=r.args.map(l=>l.name),a=_(i,o);n.reportError(new p(`Unknown argument "${i}" on field "${s.name}.${r.name}".`+O(a),{nodes:t}))}}}}function ze(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():q;for(const o of r)t[o.name]=o.args.map(a=>a.name);const s=n.getDocument().definitions;for(const o of s)if(o.kind===f.DIRECTIVE_DEFINITION){var i;const a=(i=o.arguments)!==null&&i!==void 0?i:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const c=u.name.value;if(!l.includes(c)){const d=_(c,l);n.reportError(new p(`Unknown argument "${c}" on directive "@${a}".`+O(d),{nodes:u}))}}return!1}}}function Ze(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():q;for(const i of r)t[i.name]=i.locations;const s=n.getDocument().definitions;for(const i of s)i.kind===f.DIRECTIVE_DEFINITION&&(t[i.name.value]=i.locations.map(o=>o.value));return{Directive(i,o,a,l,u){const c=i.name.value,d=t[c];if(!d){n.reportError(new p(`Unknown directive "@${c}".`,{nodes:i}));return}const m=xe(u);m&&!d.includes(m)&&n.reportError(new p(`Directive "@${c}" may not be used on ${m}.`,{nodes:i}))}}}function xe(n){const t=n[n.length-1];switch("kind"in t||S(!1),t.kind){case f.OPERATION_DEFINITION:return en(t.operation);case f.FIELD:return y.FIELD;case f.FRAGMENT_SPREAD:return y.FRAGMENT_SPREAD;case f.INLINE_FRAGMENT:return y.INLINE_FRAGMENT;case f.FRAGMENT_DEFINITION:return y.FRAGMENT_DEFINITION;case f.VARIABLE_DEFINITION:return y.VARIABLE_DEFINITION;case f.SCHEMA_DEFINITION:case f.SCHEMA_EXTENSION:return y.SCHEMA;case f.SCALAR_TYPE_DEFINITION:case f.SCALAR_TYPE_EXTENSION:return y.SCALAR;case f.OBJECT_TYPE_DEFINITION:case f.OBJECT_TYPE_EXTENSION:return y.OBJECT;case f.FIELD_DEFINITION:return y.FIELD_DEFINITION;case f.INTERFACE_TYPE_DEFINITION:case f.INTERFACE_TYPE_EXTENSION:return y.INTERFACE;case f.UNION_TYPE_DEFINITION:case f.UNION_TYPE_EXTENSION:return y.UNION;case f.ENUM_TYPE_DEFINITION:case f.ENUM_TYPE_EXTENSION:return y.ENUM;case f.ENUM_VALUE_DEFINITION:return y.ENUM_VALUE;case f.INPUT_OBJECT_TYPE_DEFINITION:case f.INPUT_OBJECT_TYPE_EXTENSION:return y.INPUT_OBJECT;case f.INPUT_VALUE_DEFINITION:{const e=n[n.length-3];return"kind"in e||S(!1),e.kind===f.INPUT_OBJECT_TYPE_DEFINITION?y.INPUT_FIELD_DEFINITION:y.ARGUMENT_DEFINITION}default:S(!1,"Unexpected kind: "+N(t.kind))}}function en(n){switch(n){case B.QUERY:return y.QUERY;case B.MUTATION:return y.MUTATION;case B.SUBSCRIPTION:return y.SUBSCRIPTION}}function nn(n){return{FragmentSpread(t){const e=t.name.value;n.getFragment(e)||n.reportError(new p(`Unknown fragment "${e}".`,{nodes:t.name}))}}}function tn(n){const t=n.getSchema(),e=t?t.getTypeMap():Object.create(null),r=Object.create(null);for(const i of n.getDocument().definitions)ve(i)&&(r[i.name.value]=!0);const s=[...Object.keys(e),...Object.keys(r)];return{NamedType(i,o,a,l,u){const c=i.name.value;if(!e[c]&&!r[c]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&rn(m);if(g&&ie.includes(c))return;const v=_(c,g?ie.concat(s):s);n.reportError(new p(`Unknown type "${c}".`+O(v),{nodes:i}))}}}}const ie=[...we,..._e].map(n=>n.name);function rn(n){return"kind"in n&&(Pe(n)||Ge(n))}function sn(n){let t=0;return{Document(e){t=e.definitions.filter(r=>r.kind===f.OPERATION_DEFINITION).length},OperationDefinition(e){!e.name&&t>1&&n.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:e}))}}}const an=3;function on(n){function t(e,r=Object.create(null),s=0){if(e.kind===f.FRAGMENT_SPREAD){const i=e.name.value;if(r[i]===!0)return!1;const o=n.getFragment(i);if(!o)return!1;try{return r[i]=!0,t(o,r,s)}finally{r[i]=void 0}}if(e.kind===f.FIELD&&(e.name.value==="fields"||e.name.value==="interfaces"||e.name.value==="possibleTypes"||e.name.value==="inputFields")&&(s++,s>=an))return!0;if("selectionSet"in e&&e.selectionSet){for(const i of e.selectionSet.selections)if(t(i,r,s))return!0}return!1}return{Field(e){if((e.name.value==="__schema"||e.name.value==="__type")&&t(e))return n.reportError(new p("Maximum introspection depth exceeded",{nodes:[e]})),!1}}}function ln(n){const t=Object.create(null),e=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(i){return s(i),!1}};function s(i){if(t[i.name.value])return;const o=i.name.value;t[o]=!0;const a=n.getFragmentSpreads(i.selectionSet);if(a.length!==0){r[o]=e.length;for(const l of a){const u=l.name.value,c=r[u];if(e.push(l),c===void 0){const d=n.getFragment(u);d&&s(d)}else{const d=e.slice(c),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");n.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}e.pop()}r[o]=void 0}}}function un(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s}of r){const i=s.name.value;t[i]!==!0&&n.reportError(new p(e.name?`Variable "$${i}" is not defined by operation "${e.name.value}".`:`Variable "$${i}" is not defined.`,{nodes:[s,e]}))}}},VariableDefinition(e){t[e.variable.name.value]=!0}}}function Te(n){const t=[],e=[];return{OperationDefinition(r){return t.push(r),!1},FragmentDefinition(r){return e.push(r),!1},Document:{leave(){const r=Object.create(null);for(const s of t)for(const i of n.getRecursivelyReferencedFragments(s))r[i.name.value]=!0;for(const s of e){const i=s.name.value;r[i]!==!0&&n.reportError(new p(`Fragment "${i}" is never used.`,{nodes:s}))}}}}}function cn(n){let t=[];return{OperationDefinition:{enter(){t=[]},leave(e){const r=Object.create(null),s=n.getRecursiveVariableUsages(e);for(const{node:i}of s)r[i.name.value]=!0;for(const i of t){const o=i.variable.name.value;r[o]!==!0&&n.reportError(new p(e.name?`Variable "$${o}" is never used in operation "${e.name.value}".`:`Variable "$${o}" is never used.`,{nodes:i}))}}},VariableDefinition(e){t.push(e)}}}function z(n){switch(n.kind){case f.OBJECT:return{...n,fields:fn(n.fields)};case f.LIST:return{...n,values:n.values.map(z)};case f.INT:case f.FLOAT:case f.STRING:case f.BOOLEAN:case f.NULL:case f.ENUM:case f.VARIABLE:return n}}function fn(n){return n.map(t=>({...t,value:z(t.value)})).sort((t,e)=>fe(t.name.value,e.name.value))}function Ee(n){return Array.isArray(n)?n.map(([t,e])=>`subfields "${t}" conflict because `+Ee(e)).join(" and "):n}function dn(n){const t=new be,e=new yn,r=new Map;return{SelectionSet(s){const i=pn(n,r,t,e,n.getParentType(),s);for(const[[o,a],l,u]of i){const c=Ee(a);n.reportError(new p(`Fields "${o}" conflict because ${c}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:l.concat(u)}))}}}}function pn(n,t,e,r,s,i){const o=[],[a,l]=P(n,t,s,i);if(gn(n,o,t,e,r,a),l.length!==0)for(let u=0;u<l.length;u++){j(n,o,t,e,r,!1,a,l[u]);for(let c=u+1;c<l.length;c++)M(n,o,t,e,r,!1,l[u],l[c])}return o}function j(n,t,e,r,s,i,o,a){if(r.has(o,a,i))return;r.add(o,a,i);const l=n.getFragment(a);if(!l)return;const[u,c]=X(n,e,l);if(o!==u){Z(n,t,e,r,s,i,o,u);for(const d of c)j(n,t,e,r,s,i,o,d)}}function M(n,t,e,r,s,i,o,a){if(o===a||s.has(o,a,i))return;s.add(o,a,i);const l=n.getFragment(o),u=n.getFragment(a);if(!l||!u)return;const[c,d]=X(n,e,l),[m,g]=X(n,e,u);Z(n,t,e,r,s,i,c,m);for(const v of g)M(n,t,e,r,s,i,o,v);for(const v of d)M(n,t,e,r,s,i,v,a)}function mn(n,t,e,r,s,i,o,a,l){const u=[],[c,d]=P(n,t,i,o),[m,g]=P(n,t,a,l);Z(n,u,t,e,r,s,c,m);for(const v of g)j(n,u,t,e,r,s,c,v);for(const v of d)j(n,u,t,e,r,s,m,v);for(const v of d)for(const h of g)M(n,u,t,e,r,s,v,h);return u}function gn(n,t,e,r,s,i){for(const[o,a]of Object.entries(i))if(a.length>1)for(let l=0;l<a.length;l++)for(let u=l+1;u<a.length;u++){const c=he(n,e,r,s,!1,o,a[l],a[u]);c&&t.push(c)}}function Z(n,t,e,r,s,i,o,a){for(const[l,u]of Object.entries(o)){const c=a[l];if(c)for(const d of u)for(const m of c){const g=he(n,e,r,s,i,l,d,m);g&&t.push(g)}}}function he(n,t,e,r,s,i,o,a){const[l,u,c]=o,[d,m,g]=a,v=s||l!==d&&A(l)&&A(d);if(!v){const $=u.name.value,ne=m.name.value;if($!==ne)return[[i,`"${$}" and "${ne}" are different fields`],[u],[m]];if(!vn(u,m))return[[i,"they have differing arguments"],[u],[m]]}const h=c==null?void 0:c.type,R=g==null?void 0:g.type;if(h&&R&&W(h,R))return[[i,`they return conflicting types "${N(h)}" and "${N(R)}"`],[u],[m]];const x=u.selectionSet,ee=m.selectionSet;if(x&&ee){const $=mn(n,t,e,r,v,b(h),x,b(R),ee);return Nn($,i,u,m)}}function vn(n,t){const e=n.arguments,r=t.arguments;if(e===void 0||e.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||e.length!==r.length)return!1;const s=new Map(r.map(({name:i,value:o})=>[i.value,o]));return e.every(i=>{const o=i.value,a=s.get(i.name.value);return a===void 0?!1:se(o)===se(a)})}function se(n){return T(z(n))}function W(n,t){return V(n)?V(t)?W(n.ofType,t.ofType):!0:V(t)?!0:E(n)?E(t)?W(n.ofType,t.ofType):!0:E(t)?!0:L(n)||L(t)?n!==t:!1}function P(n,t,e,r){const s=t.get(r);if(s)return s;const i=Object.create(null),o=Object.create(null);Ie(n,e,r,i,o);const a=[i,Object.keys(o)];return t.set(r,a),a}function X(n,t,e){const r=t.get(e.selectionSet);if(r)return r;const s=I(n.getSchema(),e.typeCondition);return P(n,t,s,e.selectionSet)}function Ie(n,t,e,r,s){for(const i of e.selections)switch(i.kind){case f.FIELD:{const o=i.name.value;let a;(A(t)||C(t))&&(a=t.getFields()[o]);const l=i.alias?i.alias.value:o;r[l]||(r[l]=[]),r[l].push([t,i,a]);break}case f.FRAGMENT_SPREAD:s[i.name.value]=!0;break;case f.INLINE_FRAGMENT:{const o=i.typeCondition,a=o?I(n.getSchema(),o):t;Ie(n,a,i.selectionSet,r,s);break}}}function Nn(n,t,e,r){if(n.length>0)return[[t,n.map(([s])=>s)],[e,...n.map(([,s])=>s).flat()],[r,...n.map(([,,s])=>s).flat()]]}class be{constructor(){this._data=new Map}has(t,e,r){var s;const i=(s=this._data.get(t))===null||s===void 0?void 0:s.get(e);return i===void 0?!1:r?!0:r===i}add(t,e,r){const s=this._data.get(t);s===void 0?this._data.set(t,new Map([[e,r]])):s.set(e,r)}}class yn{constructor(){this._orderedPairSet=new be}has(t,e,r){return t<e?this._orderedPairSet.has(t,e,r):this._orderedPairSet.has(e,t,r)}add(t,e,r){t<e?this._orderedPairSet.add(t,e,r):this._orderedPairSet.add(e,t,r)}}function Tn(n){return{InlineFragment(t){const e=n.getType(),r=n.getParentType();if(w(e)&&w(r)&&!te(n.getSchema(),e,r)){const s=N(r),i=N(e);n.reportError(new p(`Fragment cannot be spread here as objects of type "${s}" can never be of type "${i}".`,{nodes:t}))}},FragmentSpread(t){const e=t.name.value,r=En(n,e),s=n.getParentType();if(r&&s&&!te(n.getSchema(),r,s)){const i=N(s),o=N(r);n.reportError(new p(`Fragment "${e}" cannot be spread here as objects of type "${i}" can never be of type "${o}".`,{nodes:t}))}}}}function En(n,t){const e=n.getFragment(t);if(e){const r=I(n.getSchema(),e.typeCondition);if(w(r))return r}}function hn(n){return{...In(n),Field:{leave(t){var e;const r=n.getFieldDef();if(!r)return!1;const s=new Set((e=t.arguments)===null||e===void 0?void 0:e.map(i=>i.name.value));for(const i of r.args)if(!s.has(i.name)&&de(i)){const o=N(i.type);n.reportError(new p(`Field "${r.name}" argument "${i.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function In(n){var t;const e=Object.create(null),r=n.getSchema(),s=(t=r==null?void 0:r.getDirectives())!==null&&t!==void 0?t:q;for(const a of s)e[a.name]=k(a.args.filter(de),l=>l.name);const i=n.getDocument().definitions;for(const a of i)if(a.kind===f.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];e[a.name.value]=k(l.filter(bn),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=e[l];if(u){var c;const d=(c=a.arguments)!==null&&c!==void 0?c:[],m=new Set(d.map(g=>g.name.value));for(const[g,v]of Object.entries(u))if(!m.has(g)){const h=Re(v.type)?N(v.type):T(v.type);n.reportError(new p(`Directive "@${l}" argument "${g}" of type "${h}" is required, but it was not provided.`,{nodes:a}))}}}}}}function bn(n){return n.type.kind===f.NON_NULL_TYPE&&n.defaultValue==null}function Dn(n){return{Field(t){const e=n.getType(),r=t.selectionSet;if(e)if(L(b(e))){if(r){const s=t.name.value,i=N(e);n.reportError(new p(`Field "${s}" must not have a selection since type "${i}" has no subfields.`,{nodes:r}))}}else if(r){if(r.selections.length===0){const s=t.name.value,i=N(e);n.reportError(new p(`Field "${s}" of type "${i}" must have at least one field selected.`,{nodes:t}))}}else{const s=t.name.value,i=N(e);n.reportError(new p(`Field "${s}" of type "${i}" must have a selection of subfields. Did you mean "${s} { ... }"?`,{nodes:t}))}}}}function Sn(n,t,e){var r;const s={},i=(r=t.arguments)!==null&&r!==void 0?r:[],o=k(i,a=>a.name.value);for(const a of n.args){const l=a.name,u=a.type,c=o[l];if(!c){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(E(u))throw new p(`Argument "${l}" of required type "${N(u)}" was not provided.`,{nodes:t});continue}const d=c.value;let m=d.kind===f.NULL;if(d.kind===f.VARIABLE){const v=d.name.value;if(e==null||!On(e,v)){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(E(u))throw new p(`Argument "${l}" of required type "${N(u)}" was provided the variable "$${v}" which was not provided a runtime value.`,{nodes:d});continue}m=e[v]==null}if(m&&E(u))throw new p(`Argument "${l}" of non-null type "${N(u)}" must not be null.`,{nodes:d});const g=$e(d,u,e);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${T(d)}.`,{nodes:d});s[l]=g}return s}function ae(n,t,e){var r;const s=(r=t.directives)===null||r===void 0?void 0:r.find(i=>i.name.value===n.name);if(s)return Sn(n,s,e)}function On(n,t){return Object.prototype.hasOwnProperty.call(n,t)}function wn(n,t,e,r,s){const i=new Map;return J(n,t,e,r,s,i,new Set),i}function J(n,t,e,r,s,i,o){for(const a of s.selections)switch(a.kind){case f.FIELD:{if(!Q(e,a))continue;const l=_n(a),u=i.get(l);u!==void 0?u.push(a):i.set(l,[a]);break}case f.INLINE_FRAGMENT:{if(!Q(e,a)||!oe(n,a,r))continue;J(n,t,e,r,a.selectionSet,i,o);break}case f.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!Q(e,a))continue;o.add(l);const u=t[l];if(!u||!oe(n,u,r))continue;J(n,t,e,r,u.selectionSet,i,o);break}}}function Q(n,t){const e=ae(Fe,t,n);if((e==null?void 0:e.if)===!0)return!1;const r=ae(Ve,t,n);return(r==null?void 0:r.if)!==!1}function oe(n,t,e){const r=t.typeCondition;if(!r)return!0;const s=I(n,r);return s===e?!0:ce(s)?n.isSubType(s,e):!1}function _n(n){return n.alias?n.alias.value:n.name.value}function Rn(n){return{OperationDefinition(t){if(t.operation==="subscription"){const e=n.getSchema(),r=e.getSubscriptionType();if(r){const s=t.name?t.name.value:null,i=Object.create(null),o=n.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===f.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=wn(e,a,i,r,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();n.reportError(new p(s!=null?`Subscription "${s}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&n.reportError(new p(s!=null?`Subscription "${s}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function De(n,t){const e=new Map;for(const r of n){const s=t(r),i=e.get(s);i===void 0?e.set(s,[r]):i.push(r)}return e}function $n(n){return{Field:t,Directive:t};function t(e){var r;const s=(r=e.arguments)!==null&&r!==void 0?r:[],i=De(s,o=>o.name.value);for(const[o,a]of i)a.length>1&&n.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Fn(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():q;for(const a of r)t[a.name]=!a.isRepeatable;const s=n.getDocument().definitions;for(const a of s)a.kind===f.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const i=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===f.SCHEMA_DEFINITION||a.kind===f.SCHEMA_EXTENSION)l=i;else if(ve(a)||qe(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const c=u.name.value;t[c]&&(l[c]?n.reportError(new p(`The directive "@${c}" can only be used once at this location.`,{nodes:[l[c],u]})):l[c]=u)}}}}function Vn(n){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(e){const r=e.name.value;return t[r]?n.reportError(new p(`There can be only one fragment named "${r}".`,{nodes:[t[r],e.name]})):t[r]=e.name,!1}}}function Cn(n){const t=[];let e=Object.create(null);return{ObjectValue:{enter(){t.push(e),e=Object.create(null)},leave(){const r=t.pop();r||S(!1),e=r}},ObjectField(r){const s=r.name.value;e[s]?n.reportError(new p(`There can be only one input field named "${s}".`,{nodes:[e[s],r.name]})):e[s]=r.name}}}function An(n){const t=Object.create(null);return{OperationDefinition(e){const r=e.name;return r&&(t[r.value]?n.reportError(new p(`There can be only one operation named "${r.value}".`,{nodes:[t[r.value],r]})):t[r.value]=r),!1},FragmentDefinition:()=>!1}}function Ln(n){return{OperationDefinition(t){var e;const r=(e=t.variableDefinitions)!==null&&e!==void 0?e:[],s=De(r,i=>i.variable.name.value);for(const[i,o]of s)o.length>1&&n.reportError(new p(`There can be only one variable named "$${i}".`,{nodes:o.map(a=>a.variable.name)}))}}}function kn(n){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(e){t[e.variable.name.value]=e},ListValue(e){const r=Ce(n.getParentInputType());if(!V(r))return D(n,e),!1},ObjectValue(e){const r=b(n.getInputType());if(!H(r))return D(n,e),!1;const s=k(e.fields,i=>i.name.value);for(const i of Object.values(r.getFields()))if(!s[i.name]&&Ae(i)){const a=N(i.type);n.reportError(new p(`Field "${r.name}.${i.name}" of required type "${a}" was not provided.`,{nodes:e}))}r.isOneOf&&Un(n,e,r,s,t)},ObjectField(e){const r=b(n.getParentInputType());if(!n.getInputType()&&H(r)){const i=_(e.name.value,Object.keys(r.getFields()));n.reportError(new p(`Field "${e.name.value}" is not defined by type "${r.name}".`+O(i),{nodes:e}))}},NullValue(e){const r=n.getInputType();E(r)&&n.reportError(new p(`Expected value of type "${N(r)}", found ${T(e)}.`,{nodes:e}))},EnumValue:e=>D(n,e),IntValue:e=>D(n,e),FloatValue:e=>D(n,e),StringValue:e=>D(n,e),BooleanValue:e=>D(n,e)}}function D(n,t){const e=n.getInputType();if(!e)return;const r=b(e);if(!L(r)){const s=N(e);n.reportError(new p(`Expected value of type "${s}", found ${T(t)}.`,{nodes:t}));return}try{if(r.parseLiteral(t,void 0)===void 0){const i=N(e);n.reportError(new p(`Expected value of type "${i}", found ${T(t)}.`,{nodes:t}))}}catch(s){const i=N(e);s instanceof p?n.reportError(s):n.reportError(new p(`Expected value of type "${i}", found ${T(t)}; `+s.message,{nodes:t,originalError:s}))}}function Un(n,t,e,r,s){var i;const o=Object.keys(r);if(o.length!==1){n.reportError(new p(`OneOf Input Object "${e.name}" must specify exactly one key.`,{nodes:[t]}));return}const l=(i=r[o[0]])===null||i===void 0?void 0:i.value,u=!l||l.kind===f.NULL,c=(l==null?void 0:l.kind)===f.VARIABLE;if(u){n.reportError(new p(`Field "${e.name}.${o[0]}" must be non-null.`,{nodes:[t]}));return}if(c){const d=l.name.value;s[d].type.kind!==f.NON_NULL_TYPE&&n.reportError(new p(`Variable "${d}" must be non-nullable to be used for OneOf Input Object "${e.name}".`,{nodes:[t]}))}}function jn(n){return{VariableDefinition(t){const e=I(n.getSchema(),t.type);if(e!==void 0&&!Le(e)){const r=t.variable.name.value,s=T(t.type);n.reportError(new p(`Variable "$${r}" cannot be non-input type "${s}".`,{nodes:t.type}))}}}}function Mn(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s,type:i,defaultValue:o}of r){const a=s.name.value,l=t[a];if(l&&i){const u=n.getSchema(),c=I(u,l.type);if(c&&!Pn(u,c,l.defaultValue,i,o)){const d=N(c),m=N(i);n.reportError(new p(`Variable "$${a}" of type "${d}" used in position expecting type "${m}".`,{nodes:[l,s]}))}}}}},VariableDefinition(e){t[e.variable.name.value]=e}}}function Pn(n,t,e,r,s){if(E(r)&&!E(t)){if(!(e!=null&&e.kind!==f.NULL)&&!(s!==void 0))return!1;const a=r.ofType;return re(n,t,a)}return re(n,t,r)}const Gn=Object.freeze([on]),Se=Object.freeze([ye,An,sn,Rn,tn,Je,jn,Dn,He,Vn,nn,Te,Tn,ln,Ln,un,cn,Ze,Fn,Ke,$n,kn,hn,Mn,dn,Cn,...Gn]);class qn{constructor(t,e){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=e}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let e;if(this._fragments)e=this._fragments;else{e=Object.create(null);for(const r of this.getDocument().definitions)r.kind===f.FRAGMENT_DEFINITION&&(e[r.name.value]=r);this._fragments=e}return e[t]}getFragmentSpreads(t){let e=this._fragmentSpreads.get(t);if(!e){e=[];const r=[t];let s;for(;s=r.pop();)for(const i of s.selections)i.kind===f.FRAGMENT_SPREAD?e.push(i):i.selectionSet&&r.push(i.selectionSet);this._fragmentSpreads.set(t,e)}return e}getRecursivelyReferencedFragments(t){let e=this._recursivelyReferencedFragments.get(t);if(!e){e=[];const r=Object.create(null),s=[t.selectionSet];let i;for(;i=s.pop();)for(const o of this.getFragmentSpreads(i)){const a=o.name.value;if(r[a]!==!0){r[a]=!0;const l=this.getFragment(a);l&&(e.push(l),s.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,e)}return e}}class Yn extends qn{constructor(t,e,r,s){super(e,s),this._schema=t,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let e=this._variableUsages.get(t);if(!e){const r=[],s=new pe(this._schema);Ne(t,me(s,{VariableDefinition:()=>!1,Variable(i){r.push({node:i,type:s.getInputType(),defaultValue:s.getDefaultValue()})}})),e=r,this._variableUsages.set(t,e)}return e}getRecursiveVariableUsages(t){let e=this._recursiveVariableUsages.get(t);if(!e){e=this.getVariableUsages(t);for(const r of this.getRecursivelyReferencedFragments(t))e=e.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(t,e)}return e}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Oe(n,t,e=Se,r,s=new pe(n)){var i;const o=(i=void 0)!==null&&i!==void 0?i:100;t||Ye(!1,"Must provide document."),ke(n);const a=Object.freeze({}),l=[],u=new Yn(n,t,s,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),c=Be(e.map(d=>d(u)));try{Ne(t,me(s,c))}catch(d){if(d!==a)throw d}return l}function Bn(n){return{Field(t){const e=n.getFieldDef(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=n.getParentType();s!=null||S(!1),n.reportError(new p(`The field ${s.name}.${e.name} is deprecated. ${r}`,{nodes:t}))}},Argument(t){const e=n.getArgument(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=n.getDirective();if(s!=null)n.reportError(new p(`Directive "@${s.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}));else{const i=n.getParentType(),o=n.getFieldDef();i!=null&&o!=null||S(!1),n.reportError(new p(`Field "${i.name}.${o.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}))}}},ObjectField(t){const e=b(n.getParentInputType());if(H(e)){const r=e.getFields()[t.name.value],s=r==null?void 0:r.deprecationReason;s!=null&&n.reportError(new p(`The input field ${e.name}.${r.name} is deprecated. ${s}`,{nodes:t}))}},EnumValue(t){const e=n.getEnumValue(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=b(n.getInputType());s!=null||S(!1),n.reportError(new p(`The enum value "${s.name}.${e.name}" is deprecated. ${r}`,{nodes:t}))}}}}function Qn(n,t,e,r,s){const i=Se.filter(a=>!(a===Te||a===ye));return e&&Array.prototype.push.apply(i,e),Oe(n,t,i).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===f.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}const F={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},K={[F.Error]:1,[F.Warning]:2,[F.Information]:3,[F.Hint]:4},G=(n,t)=>{if(!n)throw new Error(t)};function Hn(n,t=null,e,r,s){var i,o;let a=null,l="";s&&(l=typeof s=="string"?s:s.reduce((c,d)=>c+T(d)+`

`,""));const u=l?`${n}

${l}`:n;try{a=Qe(u)}catch(c){if(c instanceof p){const d=Xn((o=(i=c.locations)===null||i===void 0?void 0:i[0])!==null&&o!==void 0?o:{line:0,column:0},u);return[{severity:K.Error,message:c.message,source:"GraphQL: Syntax",range:d}]}throw c}return Wn(a,t,e)}function Wn(n,t=null,e,r){if(!t)return[];const s=Qn(t,n,e).flatMap(o=>le(o,K.Error,"Validation")),i=Oe(t,n,[Bn]).flatMap(o=>le(o,K.Warning,"Deprecation"));return s.concat(i)}function le(n,t,e){if(!n.nodes)return[];const r=[];for(const[s,i]of n.nodes.entries()){const o=i.kind!=="Variable"&&"name"in i&&i.name!==void 0?i.name:"variable"in i&&i.variable!==void 0?i.variable:i;if(o){G(n.locations,"GraphQL validation error requires locations.");const a=n.locations[s],l=Jn(o),u=a.column+(l.end-l.start);r.push({source:`GraphQL: ${e}`,message:n.message,severity:t,range:new ge(new U(a.line-1,a.column-1),new U(a.line-1,u))})}}return r}function Xn(n,t){const e=je(),r=e.startState(),s=t.split(`
`);G(s.length>=n.line,"Query text must have more lines than where the error happened");let i=null;for(let u=0;u<n.line;u++)for(i=new Ue(s[u]);!i.eol()&&e.token(i,r)!=="invalidchar";);G(i,"Expected Parser stream to be available.");const o=n.line-1,a=i.getStartOfToken(),l=i.getCurrentPosition();return new ge(new U(o,a),new U(o,l))}function Jn(n){const e=n.loc;return G(e,"Expected ASTNode to have a location."),e}const ue=["error","warning","information","hint"],Kn={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};Y.registerHelper("lint","graphql",(n,t)=>{const{schema:e,validationRules:r,externalFragments:s}=t;return Hn(n,e,r,void 0,s).map(a=>({message:a.message,severity:a.severity?ue[a.severity-1]:ue[0],type:a.source?Kn[a.source]:void 0,from:Y.Pos(a.range.start.line,a.range.start.character),to:Y.Pos(a.range.end.line,a.range.end.character)}))});
